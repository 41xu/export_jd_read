<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><link rel="stylesheet" type="text/css" href="http://storage.360buyimg.com/ebooks/9fd8bb77eb40456b746aaae41785499a_new_.css" /><title>第11章 使用可观察对象的数据架构，第2部分：视图组件</title></head><body><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20272/17/214354863/89636/5ca122e/5b03d541N62489366.jpg" class="fullscreen" alt="" href="./image/Figure-011.jpg" /></p><p class="sectionTitle biaoti3"><a id="sec001"></a>11.1 构建视图：顶层组件ChatApp</p><p class="content">现在把注意力转向应用并来完成视图组件。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　为了简洁以及节省空间起见，本章会省去一些import声明、CSS和一些其他类似的代码行。如果你对这些细节的每一行代码都感兴趣的话，可以打开示例代码，那里囊括了运行程序所需要的一切。</p><p class="content">首先要做的就是创建顶层组件chat-app。</p><p class="content">正如之前讨论过的，页面会被分解成三个顶层组件（如图11-1所示）。</p><p class="content">●ChatNavBar：包含未读消息数。</p><p class="content">●ChatThreads：展示一个可点击的会话列表，每个会话都包含最新消息和会话头像。</p><p class="content">●ChatWindow：展示当前会话的消息和一个用来发送新消息的输入框。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21415/47/197193163/88527/865a0843/5b03d541N32a213e1.jpg" class="enlarge" alt="" href="./image/a-80.jpg" /></p><p class="descrip"><b>图11-1　聊天应用的顶层组件</b></p><p class="content">下面是组件的代码。</p><p class="reference"><b>code/rxjs/chat/app/ts/app.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'chat-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;div&gt;</p><p class="daima">　　&lt;nav-bar&gt;&lt;/nav-bar&gt;</p><p class="daima">　　&lt;div class="container"&gt;</p><p class="daima">　　　&lt;chat-threads&gt;&lt;/chat-threads&gt;</p><p class="daima">　　　&lt;chat-window&gt;&lt;/chat-window&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class ChatApp {</p><p class="daima">　constructor（private messagesService：MessagesService,</p><p class="daima">　　　　　　　private threadsService：ThreadsService,</p><p class="daima">　　　　　　　private userService：UserService）{</p><p class="daima">　　ChatExampleData.init（messagesService, threadsService, userService）;</p><p class="daima">　}</p><p class="daima">}</p><p class="daima">@NgModule（{</p><p class="daima">　declarations：[</p><p class="daima">　　ChatApp,</p><p class="daima">　　ChatNavBar,</p><p class="daima">　　ChatThreads,</p><p class="daima">　　ChatThread,</p><p class="daima">　　ChatWindow,</p><p class="daima">　　ChatMessage,</p><p class="daima">　　utilInjectables</p><p class="daima">　],</p><p class="daima">　imports：[</p><p class="daima">　　BrowserModule,</p><p class="daima">　　FormsModule</p><p class="daima">　],</p><p class="daima">　bootstrap：[ ChatApp ],</p><p class="daima">　providers：[ servicesInjectables ]</p><p class="daima">}）</p><p class="daima">export class ChatAppModule {}</p><p class="daima">platformBrowserDynamic（）.bootstrapModule（ChatAppModule）;</p><p class="content">注意constructor，在这个构造函数中我们要注入三个服务：MessagesService、ThreadsService和 UserService。我们使用这些服务来初始化示例数据。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　如果你对示例数据感兴趣的话，可以在code/rxjs/chat/app/ts/ChatExampleData.ts中找到它。</p><p class="sectionTitle biaoti3"><a id="sec002"></a>11.2 ChatThreads组件</p><p class="content">接下来，我们在ChatThreads组件中构建会话列表。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20971/13/201341939/125328/3716a578/5b03d540N6933ee81.jpg" class="enlarge" alt="" href="./image/a-81.jpg" /></p><p class="descrip"><b>图11-2　按时间排序的会话列表</b></p><p class="content">selector非常直观，我们要匹配chat-threads元素。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatThreads.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'chat-threads',</p><p class="listTitle1 biaoti8">11.2.1 ChatThreads控制器</p><p class="content">下面看看组件的控制器ChatThreads类。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatThreads.ts</b></p><p class="daima">export class ChatThreads {</p><p class="daima">　threads：Observable&lt;any&gt;;</p><p class="daima">　constructor（private threadsService：ThreadsService）{</p><p class="daima">　　this.threads = threadsService.orderedThreads;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">我们在这里注入了ThreadsService，然后保存了orderedThreads的引用。</p><p class="listTitle1 biaoti8">11.2.2 ChatThreads的template</p><p class="content">最后，我们来看一下template及其配置。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatThreads.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'chat-threads',</p><p class="daima">　changeDetection：ChangeDetectionStrategy.OnPush,</p><p class="daima">　template：`</p><p class="daima">　　&lt;！—— conversations ——&gt;</p><p class="daima">　　&lt;div class="row"&gt;</p><p class="daima">　　　&lt;div class="conversation-wrap"&gt;</p><p class="daima">　　　　&lt;chat-thread</p><p class="daima">　　　　　　 *ngFor="let thread of threads | async"</p><p class="daima">　　　　　　 [thread]="thread"&gt;</p><p class="daima">　　　　&lt;/chat-thread&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　`</p><p class="content">这里需要注意的是，使用async管道的ngFor指令、ChangeDetectionStrategy和ChatThread组件。</p><p class="content">ChatThread组件（在标记中匹配chat-thread）将展现聊天会话的视图。我们稍后就会来定义它。</p><p class="content">ngFor遍历threads属性并把值通过输入属性[thread]传给ChatThread组件。但你可能注意到*ngFor中出现了新东西：async管道。</p><p class="content">async是通过AsyncPipe实现的，它可以让我们在视图中使用RxJS的Observable。async的强大之处在于可以让我们像使用同步集合一样来使用异步可观察对象。这个特性极其方便并且非常棒。</p><p class="content">在这个组件中，我们指定了一个特定的changeDetection。Angular提供一个灵活高效的变更探测系统。它的好处之一就是如果一个组件拥有不变的或者可观察的绑定，那么我们可以向变更探测系统发送提示，让应用高效地运行。</p><p class="content">在这个例子中，Angular不再观察Thread数组的变化；取而代之的是订阅可观察对象threads的变化，并且在一个新的事件发出后触发更新。</p><p class="content">下面是完整的ChatThreads组件。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatThreads.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'chat-threads',</p><p class="daima">　changeDetection：ChangeDetectionStrategy.OnPush,</p><p class="daima">　template：`</p><p class="daima">　　&lt;！—— conversations ——&gt;</p><p class="daima">　　&lt;div class="row"&gt;</p><p class="daima">　　　&lt;div class="conversation-wrap"&gt;</p><p class="daima">　　　　&lt;chat-thread</p><p class="daima">　　　　　　 *ngFor="let thread of threads | async"</p><p class="daima">　　　　　　 [thread]="thread"&gt;</p><p class="daima">　　　　&lt;/chat-thread&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class ChatThreads {</p><p class="daima">　threads：Observable&lt;any&gt;;</p><p class="daima">　constructor（private threadsService：ThreadsService）{</p><p class="daima">　　this.threads = threadsService.orderedThreads;</p><p class="daima">　}</p><p class="daima">}</p><p class="sectionTitle biaoti3"><a id="sec003"></a>11.3 单个ChatThread组件</p><p class="content">下面来看一下ChatThread组件，它用来展示<b>单个会话</b>。我们先从@Component开始。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatThreads.ts</b></p><p class="daima">@Component（{</p><p class="daima">　inputs：['thread'],</p><p class="daima">　selector：'chat-thread',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="media conversation"&gt;</p><p class="daima">　　&lt;div class="pull-left"&gt;</p><p class="daima">　　　&lt;img class="media-object avatar"</p><p class="daima">　　　　　 src="{{thread.avatarSrc}}"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;div class="media-body"&gt;</p><p class="daima">　　　&lt;h5 class="media-heading contact-name"&gt;{{thread.name}}</p><p class="daima">　　　　&lt;span *ngIf="selected"&gt;&amp;bull;&lt;/span&gt;</p><p class="daima">　　　&lt;/h5&gt;</p><p class="daima">　　　&lt;small class="message-preview"&gt;{{thread.lastMessage.text}}&lt;/small&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;a（click）="clicked（$event）" class="div-link"&gt;Select&lt;/a&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="content">稍后再回来看template，我们先来看看组件定义的控制器。</p><p class="listTitle1 biaoti8">11.3.1 ChatThread控制器和ngOnInit</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatThreads.ts</b></p><p class="daima">export class ChatThread implements OnInit {</p><p class="daima">　thread：Thread;</p><p class="daima">　selected：boolean = false;</p><p class="daima">　constructor（private threadsService：ThreadsService）{</p><p class="daima">　}</p><p class="daima">　ngOnInit（）：void {</p><p class="daima">　　this.threadsService.currentThread</p><p class="daima">　　　.subscribe（（currentThread：Thread）=&gt; {</p><p class="daima">　　　　this.selected = currentThread &amp;&amp;</p><p class="daima">　　　　　this.thread &amp;&amp;</p><p class="daima">　　　　　（currentThread.id === this.thread.id）;</p><p class="daima">　　　}）;</p><p class="daima">　}</p><p class="daima">　clicked（event：any）：void {</p><p class="daima">　　this.threadsService.setCurrentThread（this.thread）;</p><p class="daima">　　event.preventDefault（）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">注意这里实现了一个新的接口：OnInit。Angular组件可以声明它们监听了某些生命周期事件。第14章会进一步讨论生命周期事件。</p><p class="content">在这个例子中，因为我们已经声明实现了OnInit，所以当组件第一次检查变化后就会调用组件中的ngOnInit方法。</p><p class="content">使用ngOnInit的一个关键原因在于<b>输入属性thread在constructor中是获取不到的</b>。</p><p class="content">在上面可以看到，我们在ngOnInit中订阅了threadsService.currentThread。如果currentThread匹配组件中的thread属性，那么就把selected属性设置为true。（如果不匹配，就把selected属性设置为false。）</p><p class="content">我们还设置了一个事件处理器clicked，用来处理选择当前会话的事件。在template中（参见11.3.2节），我们会把会话视图上的点击和clicked（）绑定。如果触发了clicked（），就告诉threadsService要把组件的Thread设置成当前会话设置。</p><p class="listTitle1 biaoti8">11.3.2 ChatThread的template</p><p class="content">下面是template的代码。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatThreads.ts</b></p><p class="daima">　template：`</p><p class="daima">　&lt;div class="media conversation"&gt;</p><p class="daima">　　&lt;div class="pull-left"&gt;</p><p class="daima">　　　&lt;img class="media-object avatar"</p><p class="daima">　　　　　 src="{{thread.avatarSrc}}"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;div class="media-body"&gt;</p><p class="daima">　　　&lt;h5 class="media-heading contact-name"&gt;{{thread.name}}</p><p class="daima">　　　　&lt;span *ngIf="selected"&gt;&amp;bull;&lt;/span&gt;</p><p class="daima">　　　&lt;/h5&gt;</p><p class="daima">　　　&lt;small class="message-preview"&gt;{{thread.lastMessage.text}}&lt;/small&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;a（click）="clicked（$event）" class="div-link"&gt;Select&lt;/a&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="content">注意这里有一些简单的绑定，如{{thread.avatarSrc}}、{{thread.name}}和{{thread.lastMessage.text}}。</p><p class="content">我们还用*ngIf来显示符号&amp;bull;，只有已选择的会话才会显示。</p><p class="content">最后绑定了（click）事件来调用clicked（）处理器。注意，调用clicked时传入了参数$event，这是一个用来描述事件的特殊变量，由Angular提供。我们在clicked处理器中通过调用方法event.preventDefault（）;使用了$event变量。这可以确保我们不会跳转至其他页面。</p><p class="listTitle1 biaoti8">11.3.3 ChatThread的完整代码</p><p class="content">下面是完整的ChatThread组件。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatThreads.ts</b></p><p class="daima">@Component（{</p><p class="daima">　inputs：['thread'],</p><p class="daima">　selector：'chat-thread',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="media conversation"&gt;</p><p class="daima">　　&lt;div class="pull-left"&gt;</p><p class="daima">　　　&lt;img class="media-object avatar"</p><p class="daima">　　　　　 src="{{thread.avatarSrc}}"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;div class="media-body"&gt;</p><p class="daima">　　　&lt;h5 class="media-heading contact-name"&gt;{{thread.name}}</p><p class="daima">　　　　&lt;span *ngIf="selected"&gt;&amp;bull;&lt;/span&gt;</p><p class="daima">　　　&lt;/h5&gt;</p><p class="daima">　　　&lt;small class="message-preview"&gt;{{thread.lastMessage.text}}&lt;/small&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;a（click）="clicked（$event）" class="div-link"&gt;Select&lt;/a&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class ChatThread implements OnInit {</p><p class="daima">　thread：Thread;</p><p class="daima">　selected：boolean = false;</p><p class="daima">　constructor（private threadsService：ThreadsService）{</p><p class="daima">　}</p><p class="daima">　ngOnInit（）：void {</p><p class="daima">　　this.threadsService.currentThread</p><p class="daima">　　　.subscribe（（currentThread：Thread）=&gt; {</p><p class="daima">　　　　this.selected = currentThread &amp;&amp;</p><p class="daima">　　　　　this.thread &amp;&amp;</p><p class="daima">　　　　　（currentThread.id === this.thread.id）;</p><p class="daima">　　　}）;</p><p class="daima">　}</p><p class="daima">　clicked（event：any）：void {</p><p class="daima">　　this.threadsService.setCurrentThread（this.thread）;</p><p class="daima">　　event.preventDefault（）;</p><p class="daima">　}</p><p class="daima">}</p><p class="sectionTitle biaoti3"><a id="sec004"></a>11.4 ChatWindow组件</p><p class="content">ChatWindow是此应用中最复杂的组件（如图11-3所示）。我们一步一步来完成它。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21580/13/212315922/98171/c838bdf2/5b03d541Nfc3b4081.jpg" class="enlarge" alt="" href="./image/a-82.jpg" /></p><p class="descrip"><b>图11-3　聊天窗口</b></p><p class="content">首先从定义@Component开始。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'chat-window',</p><p class="daima">　changeDetection：ChangeDetectionStrategy.OnPush,</p><p class="listTitle1 biaoti8">11.4.1 ChatWindow组件类属性</p><p class="content">ChatWindow类有四个属性。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">export class ChatWindow implements OnInit {</p><p class="daima">　messages：Observable&lt;any&gt;;</p><p class="daima">　currentThread：Thread;</p><p class="daima">　draftMessage：Message;</p><p class="daima">　currentUser：User;</p><p class="content">图11-4表明了每一个属性在何处使用。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17746/82/2605815644/80554/d50dc928/5b03d540N0389d47a.jpg" class="enlarge" alt="" href="./image/a-83.jpg" /></p><p class="descrip"><b>图11-4　聊天窗口的属性</b></p><p class="content">我们会在constructor中注入四样东西。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">　constructor（private messagesService：MessagesService,</p><p class="daima">　　　　　　　private threadsService：ThreadsService,</p><p class="daima">　　　　　　　private userService：UserService,</p><p class="daima">　　　　　　　private el：ElementRef）{</p><p class="daima">　}</p><p class="content">前面的三个都是我们创建的服务。最后的el是一个ElementRef对象，可以获取当前的宿主DOM元素。当创建和接收新消息时，我们会使用它把聊天窗口滚动到底部。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　请记住：通过在构造函数中使用public messagesService：MessagesService，我们在注入MessagesService的同时创建了一个实例变量，这个变量可以在类中通过this.messagesService来使用。</p><p class="listTitle1 biaoti8">11.4.2 ChatWindow的ngOnInit</p><p class="content">我们会把这个组件的初始化放在ngOnInit中。在这里主要要做的是，对于可以改变组件属性的可观察对象创建订阅。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">　ngOnInit（）：void {</p><p class="daima">　　this.messages = this.threadsService.currentThreadMessages;</p><p class="daima">　　this.draftMessage = new Message（）;</p><p class="content">首先，我们会把currentThreadMessages保存到messages属性中。接下来，创建一个空的Message实例作为draftMessage属性的默认值。</p><p class="content">当发送一条新消息的时候，需要确保这个Message保存了一份将要发送的Thread的引用。因为这个要发送的会话会成为当前会话，所以我们保存了当前已选会话的引用。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">　this.threadsService.currentThread.subscribe（</p><p class="daima">　　（thread：Thread）=&gt; {</p><p class="daima">　　　this.currentThread = thread;</p><p class="daima">　　}）;</p><p class="content">我们还希望新消息是由当前用户发送的，所以对currentUser做了同样的事。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">　this.userService.currentUser</p><p class="daima">　　.subscribe（</p><p class="daima">　　　（user：User）=&gt; {</p><p class="daima">　　　　this.currentUser = user;</p><p class="daima">　　　}）;</p><p class="listTitle1 biaoti8">11.4.3 ChatWindow的sendMessage</p><p class="content">既然讨论到这了，那就来实现sendMessage方法，它可以发送一条新消息。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">　sendMessage（）：void {</p><p class="daima">　　let m：Message = this.draftMessage;</p><p class="daima">　　m.author = this.currentUser;</p><p class="daima">　　m.thread = this.currentThread;</p><p class="daima">　　m.isRead = true;</p><p class="daima">　　this.messagesService.addMessage（m）;</p><p class="daima">　　this.draftMessage = new Message（）;</p><p class="daima">　}</p><p class="content">sendMessage函数先获取draftMessage并用组件属性设置了author和thread属性。每条已发送的信息其实都已经被读过了（因为是我们写的），所以将其标记为已读。</p><p class="content">注意，我们没有更新draftMessage的文本。这是因为很快就会将draftMessage的文本值绑定到视图中。</p><p class="content">当draftMessage属性更新后，我们将它发送给messagesService，然后<b>创建一个新的Message</b>对象并赋值给this.draftMessage。这样做是为了确保不会改变已发送出去的消息。</p><p class="listTitle1 biaoti8">11.4.4 ChatWindow的onEnter</p><p class="content">在视图中，我们希望在下面两种场景发送消息：</p><p class="content">（1）用户点击Send按钮；</p><p class="content">（2）用户敲击回车键。</p><p class="content">我们定义一个函数来处理这两种事件。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">　onEnter（event：any）：void {</p><p class="daima">　　this.sendMessage（）;</p><p class="daima">　　event.preventDefault（）;</p><p class="daima">　}</p><p class="listTitle1 biaoti8">11.4.5 ChatWindow的scrollToBottom</p><p class="content">当发送或者收到一条新消息时，我们想滚动到聊天窗口底部。为此要设置宿主元素的scrollTop属性。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">　scrollToBottom（）：void {</p><p class="daima">　　let scrollPane：any = this.el</p><p class="daima">　　　.nativeElement.querySelector（'.msg-container-base'）;</p><p class="daima">　　scrollPane.scrollTop = scrollPane.scrollHeight;</p><p class="daima">　}</p><p class="content">现在有了滚动到底部的函数，还需要确保在恰当的时间调用它。回到ngOnInit方法中，订阅currentThreadMessages的消息集合并在得到一条新消息的时候滚动到底部。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">　　this.messages</p><p class="daima">　　　.subscribe（</p><p class="daima">　　　　（messages：Array&lt;Message&gt;）=&gt; {</p><p class="daima">　　　　　setTimeout（（）=&gt; {</p><p class="daima">　　　　　　this.scrollToBottom（）;</p><p class="daima">　　　　　}）;</p><p class="daima">　　　　}）;</p><p class="daima">　}</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21052/24/196067947/10469/3e96e1ef/5b03d540Ncb29ebe3.jpg" class="enlarge" alt="" href="./image/a-20.jpg" /></p><p class="content"><b>为什么要使用setTimeout?</b></p><p class="content">如果我们得到新消息时立即调用scrollToBottom，那么滚动到底部的动作就是在新消息渲染完成之前执行的。使用setTimeout可以告诉JavaScript我们要在当前执行队列完成后再运行这个函数。该函数会在组件渲染完成<b>之后</b>执行，这正是我们想要的效果。</p><p class="listTitle1 biaoti8">11.4.6 ChatWindow的template</p><p class="content">template的开头部分看起来应该很眼熟，我们定义了一些标记和面板标题。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'chat-window',</p><p class="daima">　changeDetection：ChangeDetectionStrategy.OnPush,</p><p class="daima">　template：`</p><p class="daima">　　&lt;div class="chat-window-container"&gt;</p><p class="daima">　　　&lt;div class="chat-window"&gt;</p><p class="daima">　　　　&lt;div class="panel-container"&gt;</p><p class="daima">　　　　　&lt;div class="panel panel-default"&gt;</p><p class="daima">　　　　　　&lt;div class="panel-heading top-bar"&gt;</p><p class="daima">　　　　　　　&lt;div class="panel-title-container"&gt;</p><p class="daima">　　　　　　　　&lt;h3 class="panel-title"&gt;</p><p class="daima">　　　　　　　　　&lt;span class="glyphicon glyphicon-comment"&gt;&lt;/span&gt;</p><p class="daima">　　　　　　　　　Chat - {{currentThread.name}}</p><p class="daima">　　　　　　　　&lt;/h3&gt;</p><p class="daima">　　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　　&lt;div class="panel-buttons-container"&gt;</p><p class="daima">　　　　　　　　&lt;！—— you could put minimize or close buttons here ——&gt;</p><p class="daima">　　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　&lt;/div&gt;</p><p class="content">接下来显示消息列表。这里使用带async管道的ngFor指令来遍历消息列表。我们很快就会讲解单个的chat-message组件。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">　　　　　　　&lt;div class="panel-body msg-container-base"&gt;</p><p class="daima">　　　　　　　　&lt;chat-message</p><p class="daima">　　　　　　　　　　 *ngFor="let message of messages | async"</p><p class="daima">　　　　　　　　　　 [message]="message"&gt;</p><p class="daima">　　　　　　　　&lt;/chat-message&gt;</p><p class="daima">　　　　　　　&lt;/div&gt;</p><p class="content">最后是消息输入框和各个结束标签。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">　　　　　　&lt;div class="panel-footer"&gt;</p><p class="daima">　　　　　　　&lt;div class="input-group"&gt;</p><p class="daima">　　　　　　　　&lt;input type="text"</p><p class="daima">　　　　　　　　　　　 class="chat-input"</p><p class="daima">　　　　　　　　　　　 placeholder="Write your message here……"</p><p class="daima">　　　　　　　　　　　（keydown.enter）="onEnter（$event）"</p><p class="daima">　　　　　　　　　　　 [（ngModel）]="draftMessage.text" /&gt;</p><p class="daima">　　　　　　　　&lt;span class="input-group-btn"&gt;</p><p class="daima">　　　　　　　　　&lt;button class="btn-chat"</p><p class="daima">　　　　　　　　　　（click）="onEnter（$event）"</p><p class="daima">　　　　　　　　　　&gt;Send&lt;/button&gt;</p><p class="daima">　　　　　　　　&lt;/span&gt;</p><p class="daima">　　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　&lt;/div&gt;</p><p class="daima">　　　　&lt;/div&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　`</p><p class="content">消息输入框是视图中最有意思的部分，我们来看看其中两个有趣的属性：（keydown.enter）和[（ngModel）]。</p><p class="listTitle1 biaoti8">11.4.7 处理键盘动作</p><p class="content">Angular提供了一种简明的方式来处理键盘动作：在元素上绑定事件。在这个例子中，我们绑定了keydown.enter。这表示如果用户按下回车键，就会调用表达式里的函数onEnter（$event）。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">　　　　　　　　&lt;input type="text"</p><p class="daima">　　　　　　　　　　　 class="chat-input"</p><p class="daima">　　　　　　　　　　　 placeholder="Write your message here……"</p><p class="daima">　　　　　　　　　　　（keydown.enter）="onEnter（$event）"</p><p class="daima">　　　　　　　　　　　 [（ngModel）]="draftMessage.text" /&gt;</p><p class="listTitle1 biaoti8">11.4.8 使用ngModel</p><p class="content">如前所述，Angular并没有把双向绑定作为一般模式。然而，组件和组件对应视图之间的双向绑定是非常有用的。只要把双向绑定的副作用限制在组件之中，那么保持一个组件属性和视图中同步还是非常方便的。</p><p class="content">在这个例子中，我们在输入框的值和draftMessage.text之间建立了一个双向绑定。如果在输入框中输入文字，draftMessage.text就会自动设置为输入的文字。同样，如果在代码中更新draftMessage.text，那么视图中输入框的值也会随之改变。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">　　　　　　　　&lt;input type="text"</p><p class="daima">　　　　　　　　　　　 class="chat-input"</p><p class="daima">　　　　　　　　　　　 placeholder="Write your message here……"</p><p class="daima">　　　　　　　　　　　（keydown.enter）="onEnter（$event）"</p><p class="daima">　　　　　　　　　　　 [（ngModel）]="draftMessage.text" /&gt;</p><p class="listTitle1 biaoti8">11.4.9 点击Send按钮</p><p class="content">在Send按钮上将（click）属性绑定到组件中的onEnter函数。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">　　　　　　　　&lt;span class="input-group-btn"&gt;</p><p class="daima">　　　　　　　　　&lt;button class="btn-chat"</p><p class="daima">　　　　　　　　　　（click）="onEnter（$event）"</p><p class="daima">　　　　　　　　　　&gt;Send&lt;/button&gt;</p><p class="daima">　　　　　　　　&lt;/span&gt;</p><p class="listTitle1 biaoti8">11.4.10 完整的ChatWindow组件</p><p class="content">下面是ChatWindow组件的完整代码清单。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'chat-window',</p><p class="daima">　changeDetection：ChangeDetectionStrategy.OnPush,</p><p class="daima">　template：`</p><p class="daima">　　&lt;div class="chat-window-container"&gt;</p><p class="daima">　　　&lt;div class="chat-window"&gt;</p><p class="daima">　　　　&lt;div class="panel-container"&gt;</p><p class="daima">　　　　　&lt;div class="panel panel-default"&gt;</p><p class="daima">　　　　　　&lt;div class="panel-heading top-bar"&gt;</p><p class="daima">　　　　　　　&lt;div class="panel-title-container"&gt;</p><p class="daima">　　　　　　　　&lt;h3 class="panel-title"&gt;</p><p class="daima">　　　　　　　　　&lt;span class="glyphicon glyphicon-comment"&gt;&lt;/span&gt;</p><p class="daima">　　　　　　　　　Chat - {{currentThread.name}}</p><p class="daima">　　　　　　　　&lt;/h3&gt;</p><p class="daima">　　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　　&lt;div class="panel-buttons-container"&gt;</p><p class="daima">　　　　　　　　&lt;！—— you could put minimize or close buttons here ——&gt;</p><p class="daima">　　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　&lt;div class="panel-body msg-container-base"&gt;</p><p class="daima">　　　　　　　&lt;chat-message</p><p class="daima">　　　　　　　　　 *ngFor="let message of messages | async"</p><p class="daima">　　　　　　　　　 [message]="message"&gt;</p><p class="daima">　　　　　　　&lt;/chat-message&gt;</p><p class="daima">　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　&lt;div class="panel-footer"&gt;</p><p class="daima">　　　　　　　&lt;div class="input-group"&gt;</p><p class="daima">　　　　　　　　&lt;input type="text"</p><p class="daima">　　　　　　　　　　　 class="chat-input"</p><p class="daima">　　　　　　　　　　　 placeholder="Write your message here……"</p><p class="daima">　　　　　　　　　　　（keydown.enter）="onEnter（$event）"</p><p class="daima">　　　　　　　　　　　 [（ngModel）]="draftMessage.text" /&gt;</p><p class="daima">　　　　　　　　&lt;span class="input-group-btn"&gt;</p><p class="daima">　　　　　　　　　&lt;button class="btn-chat"</p><p class="daima">　　　　　　　　　　（click）="onEnter（$event）"</p><p class="daima">　　　　　　　　　　&gt;Send&lt;/button&gt;</p><p class="daima">　　　　　　　　&lt;/span&gt;</p><p class="daima">　　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　&lt;/div&gt;</p><p class="daima">　　　　&lt;/div&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class ChatWindow implements OnInit {</p><p class="daima">　messages：Observable&lt;any&gt;;</p><p class="daima">　currentThread：Thread;</p><p class="daima">　draftMessage：Message;</p><p class="daima">　currentUser：User;</p><p class="daima">　constructor（private messagesService：MessagesService,</p><p class="daima">　　　　　　　private threadsService：ThreadsService,</p><p class="daima">　　　　　　　private userService：UserService,</p><p class="daima">　　　　　　　private el：ElementRef）{</p><p class="daima">　}</p><p class="daima">　ngOnInit（）：void {</p><p class="daima">　　this.messages = this.threadsService.currentThreadMessages;</p><p class="daima">　　this.draftMessage = new Message（）;</p><p class="daima">　　this.threadsService.currentThread.subscribe（</p><p class="daima">　　　（thread：Thread）=&gt; {</p><p class="daima">　　　　this.currentThread = thread;</p><p class="daima">　　　}）;</p><p class="daima">　　this.userService.currentUser</p><p class="daima">　　　.subscribe（</p><p class="daima">　　　　（user：User）=&gt; {</p><p class="daima">　　　　　this.currentUser = user;</p><p class="daima">　　　　}）;</p><p class="daima">　　this.messages</p><p class="daima">　　　.subscribe（</p><p class="daima">　　　　（messages：Array&lt;Message&gt;）=&gt; {</p><p class="daima">　　　　　setTimeout（（）=&gt; {</p><p class="daima">　　　　　　this.scrollToBottom（）;</p><p class="daima">　　　　 }）;</p><p class="daima">　　　}）;</p><p class="daima">　}</p><p class="daima">　onEnter（event：any）：void {</p><p class="daima">　　this.sendMessage（）;</p><p class="daima">　　event.preventDefault（）;</p><p class="daima">　}</p><p class="daima">　sendMessage（）：void {</p><p class="daima">　　let m：Message = this.draftMessage;</p><p class="daima">　　m.author = this.currentUser;</p><p class="daima">　　m.thread = this.currentThread;</p><p class="daima">　　m.isRead = true;</p><p class="daima">　　this.messagesService.addMessage（m）;</p><p class="daima">　　this.draftMessage = new Message（）;</p><p class="daima">　}</p><p class="daima">　scrollToBottom（）：void {</p><p class="daima">　　let scrollPane：any = this.el</p><p class="daima">　　　.nativeElement.querySelector（'.msg-container-base'）;</p><p class="daima">　　scrollPane.scrollTop = scrollPane.scrollHeight;</p><p class="daima">　}</p><p class="daima">}</p><p class="sectionTitle biaoti3"><a id="sec005"></a>11.5 ChatMessage组件</p><p class="content">每条消息都是通过ChatMessage组件渲染的，如图11-5所示。</p><p class="content">该组件相对简明，其主要逻辑是根据消息是否由当前用户所创建来渲染出略有不同的视图。如果该消息<b>不是</b>当前用户创建的，就认为消息是收到的（incoming）。</p><p class="content">我们先从定义@Component开始。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">@Component（{</p><p class="daima">　inputs：['message'],</p><p class="daima">　selector：'chat-message',</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18310/101/2677100761/71285/dece9110/5b03d541Ndad8d8cb.jpg" class="enlarge" alt="" href="./image/a-84.jpg" /></p><p class="descrip"><b>图11-5　ChatMessage组件</b></p><p class="listTitle1 biaoti8">11.5.1 设置incoming属性</p><p class="content">记住，每个ChatMessage组件都属于一条Message。因此，要在ngOnInit方法里订阅currentUser流并根据这条Message是否由当前用户所创建来设置incoming。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">export class ChatMessage implements OnInit {</p><p class="daima">　message：Message;</p><p class="daima">　currentUser：User;</p><p class="daima">　incoming：boolean;</p><p class="daima">　constructor（private userService：UserService）{</p><p class="daima">　}</p><p class="daima">　ngOnInit（）：void {</p><p class="daima">　　this.userService.currentUser</p><p class="daima">　　　.subscribe（</p><p class="daima">　　　　（user：User）=&gt; {</p><p class="daima">　　　　　this.currentUser = user;</p><p class="daima">　　　　　if（this.message.author &amp;&amp; user）{</p><p class="daima">　　　　　　this.incoming = this.message.author.id！== user.id;</p><p class="daima">　　　　　}</p><p class="daima">　　　　}）;</p><p class="daima">　}</p><p class="daima">}</p><p class="listTitle1 biaoti8">11.5.2 ChatMessage的template</p><p class="content">在template中有两处值得注意：</p><p class="content">（1）FromNowPipe管道</p><p class="content">（2）[ngClass]属性</p><p class="content">先来看看它的代码。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">@Component（{</p><p class="daima">　inputs：['message'],</p><p class="daima">　selector：'chat-message',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="msg-container"</p><p class="daima">　　　 [ngClass]="{'base-sent'：！incoming, 'base-receive'：incoming}"&gt;</p><p class="daima">　　&lt;div class="avatar"</p><p class="daima">　　　　 *ngIf="！incoming"&gt;</p><p class="daima">　　　&lt;img src="{{message.author.avatarSrc}}"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;div class="messages"</p><p class="daima">　　　[ngClass]="{'msg-sent'：！incoming, 'msg-receive'：incoming}"&gt;</p><p class="daima">　　　&lt;p&gt;{{message.text}}&lt;/p&gt;</p><p class="daima">　　　&lt;p class="time"&gt;{{message.author.name}} ? {{message.sentAt | fromNow}}&lt;/p&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;div class="avatar"</p><p class="daima">　　　　 *ngIf="incoming"&gt;</p><p class="daima">　　　&lt;img src="{{message.author.avatarSrc}}"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="content">FromNowPipe是一个管道，把消息的发送时间转换为像“×秒前”这样对用户友好的信息。如你所见，我们要这样用它：{{message.sentAt | fromNow}}。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　FromNowPipe使用优秀的moment.js<sup><a class="mz-footnote-link" href="#footnote1"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>类库。如果你想学习如何创建自定义管道，可以阅读FromNowPipe的源代码：code/rxjs/chat/app/ts/util/FromNowPipe.ts。</p><p class="content">我们也在视图中充分利用了ngClass。当这样写时：</p><p class="daima">　　[ngClass]="{'msg-sent'：！incoming, 'msg-receive'：incoming}"</p><p class="content">我们是在告诉Angular，如果incoming为真就使用msg-receive类（否则使用msg-sent类）。</p><p class="content">借助incoming属性，我们就能以不同的形式来显示收到和发出的消息。</p><p class="listTitle1 biaoti8">11.5.3 完整的ChatMessage代码清单</p><p class="content">下面是完整的ChatMessage组件。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatWindow.ts</b></p><p class="daima">import {</p><p class="daima">　Component,</p><p class="daima">　OnInit,</p><p class="daima">　ElementRef,</p><p class="daima">　ChangeDetectionStrategy</p><p class="daima">} from '@angular/core';</p><p class="daima">import {</p><p class="daima">　MessagesService,</p><p class="daima">　ThreadsService,</p><p class="daima">　UserService</p><p class="daima">} from '../services/services';</p><p class="daima">import {Observable} from 'rxjs';</p><p class="daima">import {User, Thread, Message} from '../models';</p><p class="daima">@Component（{</p><p class="daima">　inputs：['message'],</p><p class="daima">　selector：'chat-message',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="msg-container"</p><p class="daima">　　　 [ngClass]="{'base-sent'：！incoming, 'base-receive'：incoming}"&gt;</p><p class="daima">　　&lt;div class="avatar"</p><p class="daima">　　　　 *ngIf="！incoming"&gt;</p><p class="daima">　　　&lt;img src="{{message.author.avatarSrc}}"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;div class="messages"</p><p class="daima">　　　[ngClass]="{'msg-sent'：！incoming, 'msg-receive'：incoming}"&gt;</p><p class="daima">　　　&lt;p&gt;{{message.text}}&lt;/p&gt;</p><p class="daima">　　　&lt;p class="time"&gt;{{message.author.name}} ? {{message.sentAt | fromNow}}&lt;/p&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;div class="avatar"</p><p class="daima">　　　　 *ngIf="incoming"&gt;</p><p class="daima">　　　&lt;img src="{{message.author.avatarSrc}}"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class ChatMessage implements OnInit {</p><p class="daima">　message：Message;</p><p class="daima">　currentUser：User;</p><p class="daima">　incoming：boolean;</p><p class="daima">　constructor（private userService：UserService）{</p><p class="daima">　}</p><p class="daima">　ngOnInit（）：void {</p><p class="daima">　　this.userService.currentUser</p><p class="daima">　　　.subscribe（</p><p class="daima">　　　　（user：User）=&gt; {</p><p class="daima">　　　　　this.currentUser = user;</p><p class="daima">　　　　　if（this.message.author &amp;&amp; user）{</p><p class="daima">　　　　　　this.incoming = this.message.author.id！== user.id;</p><p class="daima">　　　　　}</p><p class="daima">　　　　}）;</p><p class="daima">　}</p><p class="daima">}</p><p class="daima">@Component（{</p><p class="daima">　selector：'chat-window',</p><p class="daima">　changeDetection：ChangeDetectionStrategy.OnPush,</p><p class="daima">　template：`</p><p class="daima">　　&lt;div class="chat-window-container"&gt;</p><p class="daima">　　　&lt;div class="chat-window"&gt;</p><p class="daima">　　　　&lt;div class="panel-container"&gt;</p><p class="daima">　　　　　&lt;div class="panel panel-default"&gt;</p><p class="daima">　　　　　　&lt;div class="panel-heading top-bar"&gt;</p><p class="daima">　　　　　　　&lt;div class="panel-title-container"&gt;</p><p class="daima">　　　　　　　　&lt;h3 class="panel-title"&gt;</p><p class="daima">　　　　　　　　　&lt;span class="glyphicon glyphicon-comment"&gt;&lt;/span&gt;</p><p class="daima">　　　　　　　　　Chat - {{currentThread.name}}</p><p class="daima">　　　　　　　　&lt;/h3&gt;</p><p class="daima">　　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　　&lt;div class="panel-buttons-container"&gt;</p><p class="daima">　　　　　　　　&lt;！—— you could put minimize or close buttons here ——&gt;</p><p class="daima">　　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　&lt;div class="panel-body msg-container-base"&gt;</p><p class="daima">　　　　　　　&lt;chat-message</p><p class="daima">　　　　　　　　 *ngFor="let message of messages | async"</p><p class="daima">　　　　　　　　 [message]="message"&gt;</p><p class="daima">　　　　　　　&lt;/chat-message&gt;</p><p class="daima">　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　&lt;div class="panel-footer"&gt;</p><p class="daima">　　　　　　　&lt;div class="input-group"&gt;</p><p class="daima">　　　　　　　　&lt;input type="text"</p><p class="daima">　　　　　　　　　　　 class="chat-input"</p><p class="daima">　　　　　　　　　　　 placeholder="Write your message here……"</p><p class="daima">　　　　　　　　　　　（keydown.enter）="onEnter（$event）"</p><p class="daima">　　　　　　　　　　　 [（ngModel）]="draftMessage.text" /&gt;</p><p class="daima">　　　　　　　　&lt;span class="input-group-btn"&gt;</p><p class="daima">　　　　　　　　　&lt;button class="btn-chat"</p><p class="daima">　　　　　　　　　　（click）="onEnter（$event）"</p><p class="daima">　　　　　　　　　　&gt;Send&lt;/button&gt;</p><p class="daima">　　　　　　　　&lt;/span&gt;</p><p class="daima">　　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　&lt;/div&gt;</p><p class="daima">　　　　&lt;/div&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class ChatWindow implements OnInit {</p><p class="daima">　messages：Observable&lt;any&gt;;</p><p class="daima">　currentThread：Thread;</p><p class="daima">　draftMessage：Message;</p><p class="daima">　currentUser：User;</p><p class="daima">　constructor（private messagesService：MessagesService,</p><p class="daima">　　　　　　　private threadsService：ThreadsService,</p><p class="daima">　　　　　　　private userService：UserService,</p><p class="daima">　　　　　　　private el：ElementRef）{</p><p class="daima">　}</p><p class="daima">　ngOnInit（）：void {</p><p class="daima">　　this.messages = this.threadsService.currentThreadMessages;</p><p class="daima">　　this.draftMessage = new Message（）;</p><p class="daima">　　this.threadsService.currentThread.subscribe（</p><p class="daima">　　　（thread：Thread）=&gt; {</p><p class="daima">　　　　this.currentThread = thread;</p><p class="daima">　　　}）;</p><p class="daima">　　this.userService.currentUser</p><p class="daima">　　　.subscribe（</p><p class="daima">　　　　（user：User）=&gt; {</p><p class="daima">　　　　　this.currentUser = user;</p><p class="daima">　　　　}）;</p><p class="daima">　　this.messages</p><p class="daima">　　　.subscribe（</p><p class="daima">　　　　（messages：Array&lt;Message&gt;）=&gt; {</p><p class="daima">　　　　　setTimeout（（）=&gt; {</p><p class="daima">　　　　　　this.scrollToBottom（）;</p><p class="daima">　　　　　}）;</p><p class="daima">　　　　}）;</p><p class="daima">　}</p><p class="daima">　onEnter（event：any）：void {</p><p class="daima">　　this.sendMessage（）;</p><p class="daima">　　event.preventDefault（）;</p><p class="daima">　}</p><p class="daima">　sendMessage（）：void {</p><p class="daima">　　let m：Message = this.draftMessage;</p><p class="daima">　　m.author = this.currentUser;</p><p class="daima">　　m.thread = this.currentThread;</p><p class="daima">　　m.isRead = true;</p><p class="daima">　　this.messagesService.addMessage（m）;</p><p class="daima">　　this.draftMessage = new Message（）;</p><p class="daima">　}</p><p class="daima">　scrollToBottom（）：void {</p><p class="daima">　　let scrollPane：any = this.el</p><p class="daima">　　　.nativeElement.querySelector（'.msg-container-base'）;</p><p class="daima">　　scrollPane.scrollTop = scrollPane.scrollHeight;</p><p class="daima">　}</p><p class="daima">}</p><p class="sectionTitle biaoti3"><a id="sec006"></a>11.6 ChatNavBar组件</p><p class="content">我们要讨论的最后一个组件是ChatNavBar。导航条中会显示当前用户的未读消息数，如图11-6所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21427/48/191897794/9299/4b8ded5f/5b03d541N28c4a5af.jpg" class="enlarge" alt="" href="./image/a-85.jpg" /></p><p class="descrip"><b>图11-6　ChatNavBar组件中的未读数</b></p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="inline1" alt="" href="./image/a-9.jpg" />　试验未读消息数量最好的办法是使用等待机器人（Waiting Bot）。如何你还没有试过，尝试发消息“3”给等待机器人，然后切换到其他聊天窗口。等待机器人会等3秒再给你回复消息，这样你就会看到未读消息数量的增长。</p><p class="listTitle1 biaoti8">11.6.1 ChatNavBar的@Component</p><p class="content">首先，我们定义了非常简单的@Component配置。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatNavBar.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'nav-bar',</p><p class="listTitle1 biaoti8">11.6.2 ChatNavBar控制器</p><p class="content">ChatNavBar控制器唯一需要做的就是记录unreadMessagesCount属性。这其实比表面看上去稍微复杂一些。</p><p class="content">最简明的方式就是监听messagesService.messages，然后计算属性isRead是false的Messages数量总和。对于当前会话外的所有消息，这种方法可以正常工作。然而，当messages流发出新值时，无法保证当前会话的新消息被标记为已读。</p><p class="content">最安全的方式就合并messages流和currentThread流，以确保不会把任何属于当前会话的消息算入总数。</p><p class="content">我们用combineLatest操作符来进行实现（本章前面也使用过它）。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatNavBar.ts</b></p><p class="daima">export class ChatNavBar implements OnInit {</p><p class="daima">　unreadMessagesCount：number;</p><p class="daima">　constructor（private messagesService：MessagesService,</p><p class="daima">　　　　　　　private threadsService：ThreadsService）{</p><p class="daima">　}</p><p class="daima">　ngOnInit（）：void {</p><p class="daima">　　this.messagesService.messages</p><p class="daima">　　　.combineLatest（</p><p class="daima">　　　　this.threadsService.currentThread,</p><p class="daima">　　　　（messages：Message[], currentThread：Thread）=&gt;</p><p class="daima">　　　　　[currentThread, messages]）</p><p class="daima">　　　.subscribe（（[currentThread, messages]：[Thread, Message[]]）=&gt; {</p><p class="daima">　　　　this.unreadMessagesCount =</p><p class="daima">　　　　　_.reduce（</p><p class="daima">　　　　　　messages,</p><p class="daima">　　　　　　（sum：number, m：Message）=&gt; {</p><p class="daima">　　　　　　　let messageIsInCurrentThread：boolean = m.thread &amp;&amp;</p><p class="daima">　　　　　　　　currentThread &amp;&amp;</p><p class="daima">　　　　　　　　（currentThread.id === m.thread.id）;</p><p class="daima">　　　　　　　if（m &amp;&amp;！m.isRead &amp;&amp;！messageIsInCurrentThread）{</p><p class="daima">　　　　　　　　sum = sum + 1;</p><p class="daima">　　　　　　　}</p><p class="daima">　　　　　　　　return sum;</p><p class="daima">　　　　　　},</p><p class="daima">　　　　　　0）;</p><p class="daima">　　　}）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">如果你不熟悉TypeScript的话，会觉得上面的语法有些不太容易理解。我们在combineLatest回调函数中返回了一个数组，这个数组包含两个元素：currentThread和messages。</p><p class="content">然后我们订阅了combineLatest操作符返回的流，在函数调用中<b>解构</b>这些对象。接下来，我们用reduce化简了messages集合，对所有未读并且不属于当前会话的消息进行计数。</p><p class="listTitle1 biaoti8">11.6.3 ChatNavBar的template</p><p class="content">在视图中，唯一需要做的事就是显示unreadMessagesCount属性。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatNavBar.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'nav-bar',</p><p class="daima">　template：`</p><p class="daima">　&lt;nav class="navbar navbar-default"&gt;</p><p class="daima">　　&lt;div class="container-fluid"&gt;</p><p class="daima">　　　&lt;div class="navbar-header"&gt;</p><p class="daima">　　　　&lt;a class="navbar-brand" href="https：//ng-book.com/2"&gt;</p><p class="daima">　　　　　&lt;img src="${require（'images/logos/ng-book-2-minibook.png'）}"/&gt;</p><p class="daima">　　　　　 ng-book 2</p><p class="daima">　　　　&lt;/a&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　　&lt;p class="navbar-text navbar-right"&gt;</p><p class="daima">　　　　&lt;button class="btn btn-primary" type="button"&gt;</p><p class="daima">　　　　　Messages &lt;span class="badge"&gt;{<span class="underline">nreadMessagesCount</span>}&lt;/span&gt;</p><p class="daima">　　　　&lt;/button&gt;</p><p class="daima">　　　&lt;/p&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/nav&gt;</p><p class="daima">　`</p><p class="listTitle1 biaoti8">11.6.4 完整的ChatNavBar组件</p><p class="content">下面是完整的ChatNavBar组件代码清单。</p><p class="reference"><b>code/rxjs/chat/app/ts/components/ChatNavBar.ts</b></p><p class="daima">import {Component, OnInit} from '@angular/core';</p><p class="daima">import {MessagesService, ThreadsService} from '../services/services';</p><p class="daima">import {Message, Thread} from '../models';</p><p class="daima">import * as _ from 'underscore';</p><p class="daima">@Component（{</p><p class="daima">　selector：'nav-bar',</p><p class="daima">　template：`</p><p class="daima">　&lt;nav class="navbar navbar-default"&gt;</p><p class="daima">　　&lt;div class="container-fluid"&gt;</p><p class="daima">　　　&lt;div class="navbar-header"&gt;</p><p class="daima">　　　　&lt;a class="navbar-brand" href="https：//ng-book.com/2"&gt;</p><p class="daima">　　　　　&lt;img src="${require（'images/logos/ng-book-2-minibook.png'）}"/&gt;</p><p class="daima">　　　　　 ng-book 2</p><p class="daima">　　　　&lt;/a&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　　&lt;p class="navbar-text navbar-right"&gt;</p><p class="daima">　　　　&lt;button class="btn btn-primary" type="button"&gt;</p><p class="daima">　　　　　Messages &lt;span class="badge"&gt;{<span class="underline">nreadMessagesCount</span>}&lt;/span&gt;</p><p class="daima">　　　　&lt;/button&gt;</p><p class="daima">　　　&lt;/p&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/nav&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class ChatNavBar implements OnInit {</p><p class="daima">　unreadMessagesCount：number;</p><p class="daima">　constructor（private messagesService：MessagesService,</p><p class="daima">　　　　　　　private threadsService：ThreadsService）{</p><p class="daima">　}</p><p class="daima">　ngOnInit（）：void {</p><p class="daima">　　this.messagesService.messages</p><p class="daima">　　　.combineLatest（</p><p class="daima">　　　　this.threadsService.currentThread,</p><p class="daima">　　　　（messages：Message[], currentThread：Thread）=&gt;</p><p class="daima">　　　　　[currentThread, messages]）</p><p class="daima">　　　.subscribe（（[currentThread, messages]：[Thread, Message[]]）=&gt; {</p><p class="daima">　　　　this.unreadMessagesCount =</p><p class="daima">　　　　　_.reduce（</p><p class="daima">　　　　　　messages,</p><p class="daima">　　　　　　（sum：number, m：Message）=&gt; {</p><p class="daima">　　　　　　　let messageIsInCurrentThread：boolean = m.thread &amp;&amp;</p><p class="daima">　　　　　　　　currentThread &amp;&amp;</p><p class="daima">　　　　　　　　（currentThread.id === m.thread.id）;</p><p class="daima">　　　　　　　if（m &amp;&amp;！m.isRead &amp;&amp;！messageIsInCurrentThread）{</p><p class="daima">　　　　　　　　sum = sum + 1;</p><p class="daima">　　　　　　　}</p><p class="daima">　　　　　　　return sum;</p><p class="daima">　　　　　　},</p><p class="daima">　　　　　　0）;</p><p class="daima">　　　}）;</p><p class="daima">　}</p><p class="daima">}</p><p class="sectionTitle biaoti3"><a id="sec007"></a>11.7 总结</p><p class="content">好了，把它们全部放在一起，就是一个完整的聊天应用了（如图11-7所示）！</p><p class="content">查看文件code/redux/angular2-redux-chat/app/ts/ChatExampleData.ts，你会发现我们已经写好了少量可以跟你聊天的机器人。下面是从反转机器人中截取的一些代码：</p><p class="daima">let rev：User = new User（"Reverse Bot", require（"images/avatars/female-avatar-4.png"））;</p><p class="daima">let tRev：Thread = new Thread（"tRev", rev.name, rev.avatarSrc）;</p><p class="reference"><b>code/rxjs/chat/app/ts/ChatExampleData.ts</b></p><p class="daima">　　messagesService.messagesForThreadUser（tRev, rev）</p><p class="daima">　　　.forEach（（message：Message）：void =&gt; {</p><p class="daima">　　　　messagesService.addMessage（</p><p class="daima">　　　　　new Message（{</p><p class="daima">　　　　　　author：rev,</p><p class="daima">　　　　　　text：message.text.split（''）.reverse（）.join（''）,</p><p class="daima">　　　　　　thread：tRev</p><p class="daima">　　　　　}）</p><p class="daima">　　　　）;</p><p class="daima">　　　 },</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17296/321/2701683522/67246/564afbd7/5b03d541N729b6ad8.jpg" class="enlarge" alt="" href="./image/a-86.jpg" /></p><p class="descrip"><b>图11-7　完成后的聊天应用</b></p><p class="content">如你所见，我们已经通过messagesForThreadUser方法为反转机器人订阅了消息。你可以试着写几个自己的机器人。</p><p class="sectionTitle biaoti3"><a id="sec008"></a>11.8 更进一步</p><p class="content">改进这个聊天应用的一些方法包括加强RxJS的使用并连接到一个真实的API。发起API请求的方法我们已经在第6章中讨论过了。眼下请尽情享受你的聊天应用吧！</p><ol class="mz-footnote"><li id="footnote1">http：//momentjs.com/</li></ol></body></html>