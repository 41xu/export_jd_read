<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><link rel="stylesheet" type="text/css" href="http://storage.360buyimg.com/ebooks/9fd8bb77eb40456b746aaae41785499a_new_.css" /><title>第13章 在Angular中引入Redux</title></head><body><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19504/229/2687907500/53496/ea4138fd/5b03d540Nfe475d23.jpg" class="fullscreen" alt="" href="./image/Figure-013.jpg" /></p><p class="content">Redux是一种流行且优雅的数据架构，我们在上一章学习了它的相关知识。我们还构建了一个非常基础的应用，结合了Angular组件和Redux的store。</p><p class="content">在本章中，我们将进一步展开讲解这些概念，并在其基础之上构建一个更复杂的聊天应用。</p><p class="content">我们最终要构建出的应用如图13-1所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21622/341/199988202/67424/faeac896/5b03d541Nd07dedb9.jpg" class="enlarge" alt="" href="./image/a-92.jpg" /></p><p class="descrip"><b>图13-1　完成后的聊天应用</b></p><p class="sectionTitle biaoti3"><a id="sec001"></a>13.1 阅读背景</p><p class="content">在第10章和第11章中，我们用RxJS构建了一个聊天应用。我们打算再构建一个完全相同的应用，但这次改用Redux。这样你就能对比同一个应用在不同数据架构策略下的实现方式了。</p><p class="content">你不用为阅读本章的内容而先去阅读第10章和第11章，它们是相互独立的。如果你已经读过了那两章，就可以跳过本章中代码相同的那部分内容（比如，数据模型本身并没有什么变化）。</p><p class="content">不过我们<b>确实</b>希望你先读完第12章或至少比较熟悉Redux。</p><p class="sectionTitle biaoti3"><a id="sec002"></a>13.2 聊天应用概览</p><p class="content">这个应用提供了几个机器人，你可以和它们聊天。先运行这些代码看看：</p><p class="daima">　cd code/redux/angular2-redux-chat</p><p class="daima">　npm install</p><p class="daima">　npm run go</p><p class="content">现在在浏览器中打开http：//localhost：8080。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="inline1" alt="" href="./image/a-9.jpg" />　如果上面的链接无法打开，请尝试这个链接：http：//localhost：8080/webpack-dev-server/index.html。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17728/48/2715397358/11728/16045511/5b03d541N9720f866.jpg" class="inline1" alt="" href="./image/a-4.jpg" />　一些Windows用户在这个目录下运行npm install时可能会遇到问题。如果遇到了，请先确保自己是在Cygwin<sup><a class="mz-footnote-link" href="#footnote1"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>中运行这些命令行。</p><p class="content">在本应用中，你要注意以下几点：</p><p class="content">●你可以点击会话（thread）和另一个机器人聊天；</p><p class="content">●机器人会根据各自的性格来回复你的消息；</p><p class="content">●右上角的未读消息总数会自动同步。</p><p class="content">下面来看看本应用是如何构造的。我们有：</p><p class="content">●三个顶层Angular组件</p><p class="content">●三个数据模型</p><p class="content">●两个reducer及其各自的action creator</p><p class="content">我们来逐个看看。</p><p class="listTitle1 biaoti8">13.2.1 组件</p><p class="content">将页面分解成三个顶层组件，如图13-2所示。</p><p class="content">●ChatNavBar：包含未读消息数。</p><p class="content">●ChatThreads：展示一个可点击的会话列表，每个会话都包含最新消息和会话头像。</p><p class="content">●ChatWindow：展示当前会话的消息和一个用来发送新消息的输入框。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19675/293/2665077906/88711/cec3a17/5b03d540N726900b3.jpg" class="enlarge" alt="" href="./image/a-93.jpg" /></p><p class="descrip"><b>图13-2　Redux聊天应用的顶层组件</b></p><p class="listTitle1 biaoti8">13.2.2 数据模型</p><p class="content">本应用同样包含三个数据模型，如图13-3所示。</p><p class="content">●User：存储聊天参与者的相关信息。</p><p class="content">●Message：存储一条单独的信息。</p><p class="content">●Thread：存储一组消息的集合以及一些与这次会话有关的其他数据。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18532/281/2646003940/27748/aeb14475/5b03d540N95267683.jpg" class="enlarge" alt="" href="./image/a-94.jpg" /></p><p class="descrip"><b>图13-3　Redux聊天应用的数据模型</b></p><p class="listTitle1 biaoti8">13.2.3 reducer</p><p class="content">本应用有两个reducer。</p><p class="content">●UsersReducer：处理当前用户的相关信息。</p><p class="content">●ThreadsReducer：处理会话及其相关的消息。</p><p class="listTitle1 biaoti8">13.2.4 总结</p><p class="content">大体来说，本应用的数据架构是这样的：</p><p class="content">●所有用户和会话（它保存着该会话的消息列表）相关的信息都保存在中心store之中；</p><p class="content">●组件订阅store的变化并显示合适的数据（未读消息数、会话列表和消息列表本身）；</p><p class="content">●当用户发送一条消息时，组件就会向store中分发一个action。</p><p class="content">本章其余部分将深入讲解如何用Angular和Redux来实现此应用。我们先实现数据模型，然后看看如何创建应用的state和reducer，最后实现组件。</p><p class="sectionTitle biaoti3"><a id="sec003"></a>13.3 实现数据模型</p><p class="content">我们先从简单的部分开始，看看数据模型。</p><p class="content">我们会用interface（接口）来规定每个数据模型的定义。这不是必需的，你也可以使用更复杂一些的对象。尽管如此，带方法的对象可能会改变自己的内部状态，而这会破坏我们努力建立的函数式模型。</p><p class="content">也就是说，应用中state的所有变化都只能由reducer发起；state中的对象本身应该是不可变的。</p><p class="content">因此，通过把数据模型定义为interface，就可以：</p><p class="content">（1）在编译阶段确保我们使用的对象是符合预期格式的；</p><p class="content">（2）减少风险，比如不小心往数据模型对象中添加了某个方法而导致意想不到的行为。</p><p class="listTitle1 biaoti8">13.3.1 User</p><p class="content">User接口中有id、name和avatarSrc。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/models/User.ts</b></p><p class="daima">export interface User {</p><p class="daima">　id：string;</p><p class="daima">　name：string;</p><p class="daima">　avatarSrc：string;</p><p class="daima">　isClient?：boolean;</p><p class="daima">}</p><p class="content">我们还有一个布尔值属性isClient（问号表明这个字段是可选的）。当使用本应用的是人而不是机器人时，我们会把User中的该字段设为true。</p><p class="listTitle1 biaoti8">13.3.2 Thread</p><p class="content">同样，Thread也是一个TypeScript接口。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/models/Thread.ts</b></p><p class="daima">export interface Thread {</p><p class="daima">　id：string;</p><p class="daima">　name：string;</p><p class="daima">　avatarSrc：string;</p><p class="daima">　messages：Message[];</p><p class="daima">}</p><p class="content">我们存储了Thread的id、name和avatarSrc，而messages字段中存储的是Message的数组。</p><p class="listTitle1 biaoti8">13.3.3 Message</p><p class="content">Message是第三个也是最后一个数据模型的interface。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/models/Message.ts</b></p><p class="daima">export interface Message {</p><p class="daima">　id?：string;</p><p class="daima">　sentAt?：Date;</p><p class="daima">　isRead?：boolean;</p><p class="daima">　thread?：Thread;</p><p class="daima">　author：User;</p><p class="daima">　text：string;</p><p class="daima">}</p><p class="content">每条消息都包含以下内容。</p><p class="content">●id：消息的id。</p><p class="content">●sentAt：消息的发送时间。</p><p class="content">●isRead：一个布尔值标识，表示消息是否已读。</p><p class="content">●author：写这条消息的User。</p><p class="content">●text：消息的文本内容。</p><p class="content">●thread：对包含这条消息的Thread的引用。</p><p class="sectionTitle biaoti3"><a id="sec004"></a>13.4 应用的state</p><p class="content">现在有了数据模型，我们再来讨论一下中心state的模型。在前一章中，我们的中心state是一个对象。它有一个counter键，值的类型是一个number。然而这个应用的state就要复杂多了。</p><p class="content">下面是应用state的第一部分。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/reducers/index.ts</b></p><p class="daima">export interface AppState {</p><p class="daima">　users：UsersState;</p><p class="daima">　threads：ThreadsState;</p><p class="daima">}</p><p class="content">AppState也是一个interface，它有两个顶级的键：users和threads。这两个键本身是通过两个接口UsersState和ThreadsState来定义的，而这两个接口是在它们各自的reducer文件中定义的。</p><p class="listTitle1 biaoti8">13.4.1 关于代码布局</p><p class="content">在Redux应用中，一种常用的模式是：顶级state中的每个reducer都对应一个顶级的键。这个应用的顶级reducer在reducers/index.ts文件中。</p><p class="content">每个reducer都有自己的文件。每个文件中都有如下内容：</p><p class="content">●用来描述state树当前分支的interface；</p><p class="content">●state树当前分支的初始值；</p><p class="content">●reducer本身；</p><p class="content">●任何用来查询state树当前分支的<b>选择器</b>——我们还没有讨论过选择器，但是很快就要讲到了。</p><p class="content">我们之所以把所有这些截然不同的东西放在一起，是因为它们都是用来处理state树的当前分支的。通过把这些都放在同一个文件中，可以很容易地同时对它们进行重构。</p><p class="content">只要愿意，你完全可以使用多级嵌套的布局。如果要分解应用中的大型模块，这是一种很好的方式。</p><p class="listTitle1 biaoti8">13.4.2 根reducer</p><p class="content">讨论到如何拆分reducer，我们来看看根reducer。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/reducers/index.ts</b></p><p class="daima">export interface AppState {</p><p class="daima">　users：UsersState;</p><p class="daima">　threads：ThreadsState;</p><p class="daima">}</p><p class="daima">const rootReducer：Reducer&lt;AppState&gt; = combineReducers&lt;AppState&gt;（{</p><p class="daima">　users：UsersReducer,</p><p class="daima">　threads：ThreadsReducer</p><p class="daima">}）;</p><p class="content">注意这里的对称性：UsersReducer作用于users键，而users键的类型是UsersState；ThreadsReducer作用于threads键，而threads键的类型是ThreadsState。</p><p class="content">combineReducers让这一切成为可能。它接收一个由键和reducer组成的映射表（map）并返回一个新的reducer，这个新的reducer可以根据这些键进行相应的操作。</p><p class="content">当然，我们还没看完AppState的结构，现在继续。</p><p class="listTitle1 biaoti8">13.4.3 UserState</p><p class="content">UsersState保存了currentUser的一个引用。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/reducers/UsersReducer.ts</b></p><p class="daima">export interface UsersState {</p><p class="daima">　currentUser：User;</p><p class="daima">};</p><p class="daima">const initialState：UsersState = {</p><p class="daima">　currentUser：null</p><p class="daima">};</p><p class="content">想象一下，state树的这条分支其实可以存储与用户有关的任何信息，比如最后上线的时间、空闲时间等。不过目前这样就足够了。</p><p class="content">下面我们会在定义reducer时使用initialState，但此刻只是把当前用户设置为null。</p><p class="listTitle1 biaoti8">13.4.4 ThreadsState</p><p class="content">来看一下ThreadsState。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/reducers/ThreadsReducer.ts</b></p><p class="daima">export interface ThreadsEntities {</p><p class="daima">　[id：string]：Thread;</p><p class="daima">}</p><p class="daima">export interface ThreadsState {</p><p class="daima">　ids：string[];</p><p class="daima">　entities：ThreadsEntities;</p><p class="daima">　currentThreadId?：string;</p><p class="daima">};</p><p class="daima">const initialState：ThreadsState = {</p><p class="daima">　ids：[],</p><p class="daima">　currentThreadId：null,</p><p class="daima">　entities：{}</p><p class="daima">};</p><p class="content">首先定义了接口ThreadsEntities。它是一个键为会话id，值为会话的映射表。这样我们就能在这个映射表中通过id找到任意一个会话了。</p><p class="content">在ThreadsState中还存储了一个名叫ids的数组。它用来存储在entities中能找到的所有会话的id列表。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="enlarge" alt="" href="./image/a-9.jpg" /></p><p class="content">常用类库normalizr<sup><a class="mz-footnote-link" href="#footnote2"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>用到了这种策略。它的理念是，一旦标准化了在Redux的state中存储实体的方式，就可以建造辅助类库并清晰地使用它了。使用了normalizr之后，我们就有了大量的选择来让工作更高效，而不必了解每个state树的格式。</p><p class="content">我决定不在本章中讲解normalizr，因为还有许多其他东西要学。不过我确实很喜欢在产品级应用中使用normalizr。</p><p class="content">另外，normalizr是完全可选的，即使不在本应用中使用也不会导致任何重大的变化。</p><p class="content">如果要学习normalizr，请查阅官方文档https：//github.com/paularmstrong/normalizr、博客https：//medium.com/@mcowpercoles/using-normalizr-js-in-a-redux-store-96ab33991369#.l8ur7ipu6和Redux作者Dan Abramov在Twitter上的转发https：//twitter.com/dan_abramov/status/663032263702106112。</p><p class="content">我们用currentThreadId保存正在浏览的会话id，目的是了解用户正在浏览的是哪个会话。</p><p class="content">把initialState都设置为“空值”。</p><p class="listTitle1 biaoti8">13.4.5 可视化AppState</p><p class="content">Redux DevTools为我们提供了一个Chart视图，它可以让我们检查应用的state。图13-4展示了启动后的所有演示数据。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19147/8/2597037596/99689/47f7dfaa/5b03d541Nd97486f4.jpg" class="enlarge" alt="" href="./image/a-95.jpg" /></p><p class="descrip"><b>图13-4　Redux聊天应用的状态图</b></p><p class="content">更棒的是可以把鼠标悬停在单个节点上来查看这条数据的各个属性，如图13-5所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17755/95/2590245146/101403/7e278967/5b03d541N8eb9f287.jpg" class="enlarge" alt="" href="./image/a-96.jpg" /></p><p class="descrip"><b>图13-5　查看当前回话</b></p><p class="sectionTitle biaoti3"><a id="sec005"></a>13.5 构建reducer（和action creator）</p><p class="content">有了中心state，就可以用reducer来改变它了！</p><p class="content">既然reducer要处理action，我们就要知道reducer中action的格式。因此在构建reducer的同时也把action creator构建出来。</p><p class="listTitle1 biaoti8">13.5.1 设置当前用户的action creator</p><p class="content">UserState中存储着当前用户，因此需要一个action来设置当前用户。我们会在actions文件夹中保存这些action文件，并且文件名要和它们对应的reducer保持一致，比如在这个例子中的文件名是UserActions。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/actions/UserActions.ts</b></p><p class="daima">export const SET_CURRENT_USER = '[User] Set Current';</p><p class="daima">export interface SetCurrentUserAction extends Action {</p><p class="daima">　user：User;</p><p class="daima">}</p><p class="daima">export const setCurrentUser：ActionCreator&lt;SetCurrentUserAction&gt; =</p><p class="daima">　（user）=&gt;（{</p><p class="daima">　　type：SET_CURRENT_USER,</p><p class="daima">　　user：user</p><p class="daima">　}）;</p><p class="content">这里定义了const SET_CURRENT_USER。我们将在reducer的switch语句中使用它。</p><p class="content">我们还定义了一个新的子接口SetCurrentUserAction，它继承了Action并添加了一个user属性。我们会用user属性表明要把哪个用户作为当前用户。</p><p class="content">函数setCurrentUser就是我们的action creator函数。它接收一个user参数并返回一个SetCurrentUserAction。我们要把这个返回值传给reducer的action。</p><p class="listTitle1 biaoti8">13.5.2 UsersReducer：设置当前用户</p><p class="content">现在我们把视线转向UsersReducer。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/reducers/UsersReducer.ts</b></p><p class="daima">export const UsersReducer =</p><p class="daima">　function（state：UsersState = initialState, action：Action）：UsersState {</p><p class="daima">　switch（action.type）{</p><p class="daima">　　case UserActions.SET_CURRENT_USER：</p><p class="daima">　　const user：User =（&lt;UserActions.SetCurrentUserAction&gt;action）.user;</p><p class="daima">　　　return {</p><p class="daima">　　　　currentUser：user</p><p class="daima">　　　};</p><p class="daima">　　default：</p><p class="daima">　　　return state;</p><p class="daima">　}</p><p class="daima">};</p><p class="content">和所有reducer一样，UsersReducer返回一个新的state。在这个例子中，它的类型是UsersState。</p><p class="content">接下来对action.type使用switch语句，然后处理UserActions.SET_CURRENT_USER分支。</p><p class="content">为了设置当前用户，我们需要从输入的action中获取user。为了做到这一点，首先要把action转换成UserActions.SetCurrentUserAction，然后读取它的.user字段。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="enlarge" alt="" href="./image/a-3.jpg" /></p><p class="content">这似乎有点奇怪。我们本来已经创建了SetCurrentUserAction，但现在switch语句中使用的却是字符串type，并不是直接使用类型。</p><p class="content">实际上，这是受TypeScript所迫。当TypeScript被编译成JavaScript后会丢失接口的元数据。我们也可以尝试使用一些反射机制（装饰器元数据或构造函数等等）来实现。</p><p class="content">在分发的时候将SetCurrentUserAction转换成Action，在这里又要转换回去，这样确实不够优雅；但对于这个应用来说，这是处理“多态分发”的一种简便做法。</p><p class="content">我们需要返回一个新的UserState。因为UserState只有一个键，所以相应的结果对象只有currentUser键并用所传入action中的user属性作为值。</p><p class="listTitle1 biaoti8">13.5.3 会话和消息概览</p><p class="content">这个应用的核心是会话中的消息。我们需要实现三个action：</p><p class="content">（1）往state中添加一个新会话；</p><p class="content">（2）往会话中添加消息；</p><p class="content">（3）选择一个会话。</p><p class="content">我们先来创建一个新会话。</p><p class="listTitle1 biaoti8">13.5.4 添加新会话的action creator</p><p class="content">下面是用来往state中添加新会话的action creator。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/actions/ThreadActions.ts</b></p><p class="daima">export const ADD_THREAD = '[Thread] Add';</p><p class="daima">export interface AddThreadAction extends Action {</p><p class="daima">　thread：Thread;</p><p class="daima">}</p><p class="daima">export const addThread：ActionCreator&lt;AddThreadAction&gt; =</p><p class="daima">　（thread）=&gt;（{</p><p class="daima">　　type：ADD_THREAD,</p><p class="daima">　　thread：thread</p><p class="daima">　}）;</p><p class="content">注意，它在结构上和我们的前一个action creator非常相似。我们定义了一个用在switch语句中的常量ADD_THREAD、一个自定义的Action和一个用来生成Action的action creator addThread。</p><p class="content">注意，这里并没有初始化Thread本身，因为这个Thread是作为参数传进来的。</p><p class="listTitle1 biaoti8">13.5.5 添加新会话的reducer</p><p class="content">现在通过处理ADD_THREAD分支来创建ThreadsReducer。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/reducers/ThreadsReducer.ts</b></p><p class="daima">export const ThreadsReducer =</p><p class="daima">　function（state：ThreadsState = initialState, action：Action）：ThreadsState {</p><p class="daima">　switch（action.type）{</p><p class="daima">　　// Adds a new Thread to the list of entities</p><p class="daima">　　case ThreadActions.ADD_THREAD：{</p><p class="daima">　　　const thread =（&lt;ThreadActions.AddThreadAction&gt;action）.thread;</p><p class="daima">　　　if（state.ids.includes（thread.id））{</p><p class="daima">　　　　return state;</p><p class="daima">　　　}</p><p class="daima">　　　return {</p><p class="daima">　　　　ids：[ ……state.ids, thread.id ],</p><p class="daima">　　　　currentThreadId：state.currentThreadId,</p><p class="daima">　　　　entities：Object.assign（{}, state.entities, {</p><p class="daima">　　　　　[thread.id]：thread</p><p class="daima">　　　　}）</p><p class="daima">　　　};</p><p class="daima">　　}</p><p class="daima">　　// Adds a new Message to a particular Thread</p><p class="content">ThreadsReducer处理的是ThreadsState。当处理ADD_THREAD这个action时，我们把action对象类型又转换回了ThreadActions.AddThreadAction并从中取出thread。</p><p class="content">接着检查在state.ids的列表中是否包含这个新的thread.id。如果已经有了，那么就不作任何改动，直接返回当前的state。</p><p class="content">但如果这个thread是新的，那就要把它添加到当前的state中。</p><p class="content">记住，创建一个新的ThreadsState时要格外小心，不要修改旧的state。这个state比我们以前接触过的要复杂得多，但在处理原则上是基本一致的。</p><p class="content">我们先把thread.id添加到ids数组中。这里使用了ES6的展开操作符（……）来表明我们想把所有现存的state.ids放入新数组之中并在数组结尾处添加thred.id。</p><p class="content">添加一个新会话时currentThreadId并没有改变，所以这里直接返回<b>原来</b>的state.currentThreadId即可。</p><p class="content">对于entities，需要记住的是它是一个对象。它的键是每个会话的id字符串，值是这个会话本身。这里使用Object.assign来创建一个新对象，新对象中包含了老的state.entities和一个新的thread对象。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="enlarge" alt="" href="./image/a-9.jpg" /></p><p class="content">每次进行修改时都要小心翼翼地复制这些对象是不是让你觉得很烦？别人也都这么想！事实上，这样做会很容易意外修改原始数据。</p><p class="content">这也就是出现Immutable.js<sup><a class="mz-footnote-link" href="#footnote3"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>的原因了。和Redux一起使用Immutable.js通常就是出于这个目的。Immutable会帮我们处理好这些原本需要小心进行的更新。</p><p class="content">我建议你查看Immutable.js，看看它对写reducer是否更合适。</p><p class="content">现在就可以把新会话添加到中心state里了！</p><p class="listTitle1 biaoti8">13.5.6 添加新消息的action creator</p><p class="content">有了会话，我们就可以开始往里面添加消息了。</p><p class="content">为添加消息定义一个新的action。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/actions/ThreadActions.ts</b></p><p class="daima">export const ADD_MESSAGE = '[Thread] Add Message';</p><p class="daima">export interface AddMessageAction extends Action {</p><p class="daima">　thread：Thread;</p><p class="daima">　message：Message;</p><p class="daima">}</p><p class="content">AddMessageAction往会话中添加一条消息。</p><p class="content">下面是添加新消息的action creator。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/actions/ThreadActions.ts</b></p><p class="daima">export const addMessage：ActionCreator&lt;AddMessageAction&gt; =</p><p class="daima">　（thread：Thread, messageArgs：Message）：AddMessageAction =&gt; {</p><p class="daima">　　const defaults = {</p><p class="daima">　　　id：uuid（）,</p><p class="daima">　　　sentAt：new Date（）,</p><p class="daima">　　　isRead：false,</p><p class="daima">　　　thread：thread</p><p class="daima">　　};</p><p class="daima">　　const message：Message = Object.assign（{}, defaults, messageArgs）;</p><p class="daima">　　return {</p><p class="daima">　　　type：ADD_MESSAGE,</p><p class="daima">　　　thread：thread,</p><p class="daima">　　　message：message</p><p class="daima">　　};</p><p class="daima">　};</p><p class="content">addMessage这个action creator接收一个thread和一个准备加工成消息的对象。注意，这里保留了一个defaults的列表，目的是把创建id、设置时间戳和设置isRead状态等操作封装起来。对于发送信息的人来说，这样就完全不用关心UUID的具体格式是什么了。</p><p class="content">如果用户已经事先用UUID类库创建好了自带id的消息，当用户发送这条消息时，我们也会将它保存起来。为了实现这种默认行为，先把messageArgs合并到defaults之中，再合并到一个新的对象中。</p><p class="content">最后，我们返回了带有thread和新的message且类型为ADD_MESSAGE的action。</p><p class="listTitle1 biaoti8">13.5.7 添加新消息的reducer</p><p class="content">现在我们要在ThreadsReducer中添加ADD_MESSAGE的处理器。要添加一条新消息，我们就要获得这个会话，然后把消息添加到这个会话中。</p><p class="content">这里还有微妙的一点要处理：如果该thread是当前会话，那就要将这条消息<b>标记为已读</b>。</p><p class="content">用户永远都会有一个会话是当前会话，也就是他们正在查看的会话。我们的意思是，如果把一条新消息添加到了当前会话中，那么它就会被自动标记为已读。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/reducers/ThreadsReducer.ts</b></p><p class="daima">　case ThreadActions.ADD_MESSAGE：{</p><p class="daima">　　const thread =（&lt;ThreadActions.AddMessageAction&gt;action）.thread;</p><p class="daima">　　const message =（&lt;ThreadActions.AddMessageAction&gt;action）.message;</p><p class="daima">　　// special case：if the message being added is in the current thread, then</p><p class="daima">　　// mark it as read</p><p class="daima">　　const isRead = message.thread.id === state.currentThreadId ?</p><p class="daima">　　　　　　　　　　true：message.isRead;</p><p class="daima">　　const newMessage = Object.assign（{}, message, { isRead：isRead }）;</p><p class="daima">　　// grab the old thraed from entities</p><p class="daima">　　const oldThread = state.entities[thread.id];</p><p class="daima">　　// create a new thread which has our newMessage</p><p class="daima">　　const newThread = Object.assign（{}, oldThread, {</p><p class="daima">　　　messages：[……oldThread.messages, newMessage]</p><p class="daima">　　}）;</p><p class="daima">　　return {</p><p class="daima">　　　ids：state.ids, // unchanged</p><p class="daima">　　　currentThreadId：state.currentThreadId, // unchanged</p><p class="daima">　　　entities：Object.assign（{}, state.entities, {</p><p class="daima">　　　　[thread.id]：newThread</p><p class="daima">　　　}）</p><p class="daima">　　};</p><p class="daima">　}</p><p class="daima">　// Select a particular thread in the UI</p><p class="content">这段代码有点长，因为我们要小心地避免修改原来的会话，但它大体上和我们以前所做的没什么不同。</p><p class="content">首先，提取出thread和message。</p><p class="content">如果这条消息属于当前会话（接下来就会看到如何设置当前会话），我们就把它标记为已读。</p><p class="content">然后，我们抓取oldThread并把newMessage追加到旧的messages数组，以创建newThread。</p><p class="content">最后，我们返回新的ThreadsState。当前的会话ids列表和currentThreadId在添加一条新消息时都没有变，所以这里直接使用原有值。唯一改变的就是我们用newThread更新了entities。</p><p class="content">现在来实现我们数据骨架的最后一部分：选择会话。</p><p class="listTitle1 biaoti8">13.5.8 选择会话的action creator</p><p class="content">用户可以同时进行多个聊天会话，但是只有一个聊天窗口（也就是用户可以阅读和发送消息的地方）。当用户点击了一个会话，我们就要在聊天窗口中展示这个会话中的消息，如图13-6所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19651/256/2572637445/64704/cb559d0/5b03d541N0e1359a7.jpg" class="enlarge" alt="" href="./image/a-97.jpg" /></p><p class="descrip"><b>图13-6　选择一个会话</b></p><p class="content">我们需要记录哪个会话是当前选中的会话。要做到这一点，需要使用ThreadsState中的currentThreadId属性。</p><p class="content">我们来创建它的action。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/actions/ThreadActions.ts</b></p><p class="daima">export const SELECT_THREAD = '[Thread] Select';</p><p class="daima">export interface SelectThreadAction extends Action {</p><p class="daima">　thread：Thread;</p><p class="daima">}</p><p class="daima">export const selectThread：ActionCreator&lt;SelectThreadAction&gt; =</p><p class="daima">　（thread）=&gt;（{</p><p class="daima">　　type：SELECT_THREAD,</p><p class="daima">　　thread：thread</p><p class="daima">　}）;</p><p class="content">这个action中并没有引入新概念，只有新的动作类型SELECT_THREAD和当前选中并作为参数传入的thread。</p><p class="listTitle1 biaoti8">13.5.9 选择会话的reducer</p><p class="content">选择一个thread需要做两件事：</p><p class="content">（1）把currentThreadId设置为选中thread的id；</p><p class="content">（2）把这个thread中的所有消息标记为已读。</p><p class="content">下面是这个reducer的代码。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/reducers/ThreadsReducer.ts</b></p><p class="daima">　　case ThreadActions.SELECT_THREAD：{</p><p class="daima">　　　const thread =（&lt;ThreadActions.SelectThreadAction&gt;action）.thread;</p><p class="daima">　　　const oldThread = state.entities[thread.id];</p><p class="daima">　　　// mark the messages as read</p><p class="daima">　　　const newMessages = oldThread.messages.map（</p><p class="daima">　　　　（message）=&gt; Object.assign（{}, message, { isRead：true }））;</p><p class="daima">　　　// give them to this new thread</p><p class="daima">　　　const newThread = Object.assign（{}, oldThread, {</p><p class="daima">　　　　messages：newMessages</p><p class="daima">　　　}）;</p><p class="daima">　　　return {</p><p class="daima">　　　　ids：state.ids,</p><p class="daima">　　　　currentThreadId：thread.id,</p><p class="daima">　　　　entities：Object.assign（{}, state.entities, {</p><p class="daima">　　　　　[thread.id]：newThread</p><p class="daima">　　　　}）</p><p class="daima">　　　};</p><p class="daima">　　}</p><p class="daima">　　default：</p><p class="daima">　　　return state;</p><p class="daima">　}</p><p class="daima">};</p><p class="content">首先获取要选择的thread然后使用thread.id从state中得到当前会话的值。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="inline1" alt="" href="./image/a-9.jpg" />　这是个防御型策略。为什么不直接使用传进来的thread呢？对于一些应用来说这也许是正确的设计决策。但在这个例子中，需要通过读取state.entities中会话的最后一个已知值来使thread免受外部修改。</p><p class="content">接下来，我们创建所有旧消息的副本并把它们全部设置为isRead：true。然后把新的已读消息列表赋给newThread。</p><p class="content">最后，我们返回新的ThreadsState。</p><p class="listTitle1 biaoti8">13.5.10 reducer总结</p><p class="content">完成了！这些就是搭建数据架构的骨架所需的一切。</p><p class="content">回顾一下，UsersReducer负责维护当前用户，而ThreadsReducer则负责管理：</p><p class="content">●会话列表</p><p class="content">●会话中的消息列表</p><p class="content">●当前选中的会话</p><p class="content">我们可以从这些数据中拿到所需的一切了（比如未读消息数）。</p><p class="content">接下来就把它们和组件连接在一起！</p><p class="sectionTitle biaoti3"><a id="sec006"></a>13.6 构建Angular聊天应用</p><p class="content">如前所述，页面会被分解成三个顶层组件，如图13-7所示。</p><p class="content">●ChatNavBar：包含未读消息数。</p><p class="content">●ChatThreads：展示一个可点击的会话列表，每个会话包含最后一条消息和会话头像。</p><p class="content">●ChatWindow：展示当前会话的消息和一个用来发送新消息的输入框。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18490/98/2642378804/88527/865a0843/5b03d541Ncee845f1.jpg" class="enlarge" alt="" href="./image/a-98.jpg" /></p><p class="descrip"><b>图13-7　Redux聊天应用的顶层组件</b></p><p class="content">我们要像上一章一样启动本应用。在应用的最上层，我们初始化Redux store并通过Angular的依赖注入系统来提供它。（如果觉得陌生，请重新阅读上一章。）</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/app.ts</b></p><p class="daima">let store：Store&lt;AppState&gt; = createStore&lt;AppState&gt;（</p><p class="daima">　reducer,</p><p class="daima">　compose（devtools）</p><p class="daima">）;</p><p class="daima">@NgModule（{</p><p class="daima">　declarations：[</p><p class="daima">　　ChatApp,</p><p class="daima">　　ChatPage,</p><p class="daima">　　ChatThreads,</p><p class="daima">　　ChatNavBar,</p><p class="daima">　　ChatWindow,</p><p class="daima">　　ChatThread,</p><p class="daima">　　ChatMessage,</p><p class="daima">　　FromNowPipe</p><p class="daima">　],</p><p class="daima">　imports：[</p><p class="daima">　　BrowserModule,</p><p class="daima">　　FormsModule</p><p class="daima">　],</p><p class="daima">　bootstrap：[ ChatApp ],</p><p class="daima">　providers：[</p><p class="daima">　　{ provide：AppStore, useFactory：（）=&gt; store }</p><p class="daima">　]</p><p class="daima">}）</p><p class="daima">class ChatAppModule {}</p><p class="daima">platformBrowserDynamic（）.bootstrapModule（ChatAppModule）</p><p class="listTitle1 biaoti8">13.6.1 顶层组件ChatApp</p><p class="content">ChatApp是顶层组件，只负责渲染ChatPage组件。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/app.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'chat-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;div&gt;</p><p class="daima">　　&lt;chat-page&gt;&lt;/chat-page&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class ChatApp {</p><p class="daima">　constructor（@Inject（AppStore）private store：Store&lt;AppState&gt;）{</p><p class="daima">　　ChatExampleData（store）;</p><p class="daima">　}</p><p class="daima">}</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="inline1" alt="" href="./image/a-9.jpg" />　这个应用中机器人的数据来自客户端而不是服务器端。ChatExampleData（）函数为应用设置了初始数据。我们不会在本书中具体解释这段代码，如果你想了解它的工作细节，可以随时查阅源代码。</p><p class="content">我们没有在这个应用中使用路由。如果要用的话，可以把与路由相关的内容放到应用的顶层组件之中。现在只创建ChatPage组件来渲染应用的主体部分。</p><p class="content">这个应用中没有其他页面，但为每个页面分配一个组件仍然是个好主意，毕竟将来万一还要添加其他页面呢。</p><p class="listTitle1 biaoti8">13.6.2 ChatPage</p><p class="content">聊天页面会渲染三个主要组件：</p><p class="content">●ChatNavBar</p><p class="content">●ChatThreads</p><p class="content">●ChatWindow</p><p class="content">下面是其代码。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/pages/ChatPage.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'chat-page',</p><p class="daima">　template：`</p><p class="daima">　&lt;div&gt;</p><p class="daima">　　&lt;chat-nav-bar&gt;&lt;/chat-nav-bar&gt;</p><p class="daima">　　&lt;div class="container"&gt;</p><p class="daima">　　　&lt;chat-threads&gt;&lt;/chat-threads&gt;</p><p class="daima">　　　&lt;chat-window&gt;&lt;/chat-window&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export default class ChatPage {</p><p class="daima">}</p><p class="content">我们在这个应用中使用的是一种叫作<b>容器型组件</b>的设计模式。这三个组件都是容器型组件。下面就来解释一下。</p><p class="listTitle1 biaoti8">13.6.3 容器型组件与展示型组件</p><p class="content">如果数据散布于所有组件中，那么这个应用就会很难理解。然而，我们的应用是动态的，组件需要运行时的数据来填充，也需要响应用户的交互。</p><p class="content">缓解这种冲突的模式之一就是区分展示型组件与容器型组件的概念。具体来说是这样的：</p><p class="content">（1）要让与外部数据源（例如API、Redux store、Cookies等）交互的组件尽可能少；</p><p class="content">（2）要有意识地将数据访问放在容器型组件之中；</p><p class="content">（3）对于纯“功能性”的展示型组件，要求它的所有属性（输入和输出）都由容器型组件来管理。</p><p class="content">这种设计的好处在于展示型组件的行为是可预测的。它们可以复用，因为它们只关心自己用到的那部分数据，从不对整体的数据架构作出任何假设。</p><p class="content">即使不考虑可复用性，其可预测性也是一个优点。对于相同的输入，它们总是会给出相同的输出（比如用相同的方式渲染）。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="inline1" alt="" href="./image/a-9.jpg" />　仔细想想，你会发现要求reducer必须是纯函数和要求展示型组件必须是“纯组件”背后的哲学是一样的。</p><p class="content">如果整个应用全都是展示型组件，那是最理想的。但现实世界中的数据是杂乱、不断变化的，所以我们可以试着把用来适应真实世界的各种复杂数据封装到容器型组件中。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="enlarge" alt="" href="./image/a-3.jpg" /></p><p class="content">如果你是高级程序员，可能会发现在MVC和容器/展示型组件之间存在着一种不太准确的比喻。也就是说，展示型组件类似于所传入数据的“视图”，而容器型组件则类似于“控制器”，它接收“数据模型”（应用其他部分的数据）并在进行适配之后传给展示型组件。</p><p class="content">但如果你还是编程界的新兵，那就先别试图理解“Angular组件本身就是视图和控制器”这种比喻了。</p><p class="content">在这个应用中，容器型组件就是那些和store交互的组件。这表示容器型组件符合下列三种特征：</p><p class="content">（1）从store中读取数据；</p><p class="content">（2）订阅store的变化；</p><p class="content">（3）向store中分发action。</p><p class="content">这里的三个主要组件都是容器型组件，而它们所包含的组件都是展示型的（也就是功能性的/纯粹的/不和store交互的）。</p><p class="content">接下来构建第一个容器型组件：导航条。</p><p class="sectionTitle biaoti3"><a id="sec007"></a>13.7 构建ChatNavBar</p><p class="content">导航条中要显示当前用户的未读消息数，如图13-8所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20284/15/213352903/9299/4b8ded5f/5b03d541N6ec91953.jpg" class="enlarge" alt="" href="./image/a-99.jpg" /></p><p class="descrip"><b>图13-8　ChatNavBar组件中的未读数</b></p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="inline1" alt="" href="./image/a-9.jpg" />　试验未读消息数量最好的办法是使用等待机器人（Waiting Bot）。如何你还没有试过，尝试发消息“3”给等待机器人，然后切换到其他聊天窗口。等待机器人会等3秒再给你回复消息，这样你就会看到未读消息数量的增长。</p><p class="content">先来看看组件代码。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/containers/ChatNavBar.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'chat-nav-bar',</p><p class="daima">　template：`</p><p class="daima">　&lt;nav class="navbar navbar-default"&gt;</p><p class="daima">　　&lt;div class="container-fluid"&gt;</p><p class="daima">　　　&lt;div class="navbar-header"&gt;</p><p class="daima">　　　　&lt;a class="navbar-brand" href="https：//ng-book.com/2"&gt;</p><p class="daima">　　　　　&lt;img src="${require（'images/logos/ng-book-2-minibook.png'）}"/&gt;</p><p class="daima">　　　　　 ng-book 2</p><p class="daima">　　　　&lt;/a&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　　&lt;p class="navbar-text navbar-right"&gt;</p><p class="daima">　　　　&lt;button class="btn btn-primary" type="button"&gt;</p><p class="daima">　　　　　Messages &lt;span class="badge"&gt;{{ unreadMessagesCount }}&lt;/span&gt;</p><p class="daima">　　　　&lt;/button&gt;</p><p class="daima">　　　&lt;/p&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/nav&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export default class ChatNavBar {</p><p class="daima">　unreadMessagesCount：number;</p><p class="daima">　constructor（@Inject（AppStore）private store：Store&lt;AppState&gt;）{</p><p class="daima">　　store.subscribe（（）=&gt; this.updateState（））;</p><p class="daima">　　this.updateState（）;</p><p class="daima">　}</p><p class="daima">　updateState（）{</p><p class="daima">　　this.unreadMessagesCount = getUnreadMessagesCount（this.store.getState（））;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">模板为我们提供了DOM结构和渲染导航条所需的CSS（这些CSS类来自CSS框架Bootstrap）。</p><p class="content">在这个模板中，我们唯一要显示的变量是unreadMessagesCount。</p><p class="content">ChatNavBar组件中的unreadMessagesCount是一个实例变量。它会被设置成所有会话的未读消息总数。</p><p class="content">注意，我们在constructor中做了三件事：</p><p class="content">（1）注入了store；</p><p class="content">（2）订阅了store中的任何变化；</p><p class="content">（3）调用了this.updateState（）。</p><p class="content">我们在subscribe后调用了this.updateState（），因为要确保组件使用最新数据进行初始化。subscribe只会在组件初始化<b>之后</b>state数据发生变化的时候调用。</p><p class="content">updateState（）是最有意思的函数——我们把unreadMessagesCount设置为getUnreadMessagesCount函数的返回值。getUnreadMessagesCount是什么？它从哪里来？</p><p class="content">getUnreadMessagesCount是一个名叫<b>选择器</b>（selector）的新概念。</p><p class="listTitle1 biaoti8">13.7.1 Redux选择器</p><p class="content">思考一下AppState，我们该如何获取未读消息总数呢？像下面这样如何：</p><p class="daima">// get the state</p><p class="daima">let state = this.store.getState（）;</p><p class="daima">// get the threads state</p><p class="daima">let threadsState = state.threads;</p><p class="daima">// get the entities from the threads</p><p class="daima">let threadsEntities = threadsState.entities;</p><p class="daima">// get all of the threads from state</p><p class="daima">let allThreads = Object.keys（threadsEntities）</p><p class="daima">　　　　　　　 .map（（threadId）=&gt; entities[threadId]）;</p><p class="daima">// iterate over all threads and ……</p><p class="daima">let unreadCount = allThreads.reduce（</p><p class="daima">　　　（unreadCount：number, thread：Thread）=&gt; {</p><p class="daima">　　　　// foreach message in that thread</p><p class="daima">　　　　thread.messages.forEach（（message：Message）=&gt; {</p><p class="daima">　　　　　if（！message.isRead）{</p><p class="daima">　　　　　　// if it's unread, increment unread count</p><p class="daima">　　　　　　++unreadCount;</p><p class="daima">　　　　　}</p><p class="daima">　　　　}）;</p><p class="daima">　　　　return unreadCount;</p><p class="daima">　　　},</p><p class="daima">　　　0）;</p><p class="content">我们应该把这段逻辑放在ChatNavBar组件中吗？如果这么做的话，会有如下两个问题。</p><p class="content">（1）这一大块代码深深地渗透到了AppState中。更好的方法是把这段逻辑移到所涉及的state之后。</p><p class="content">（2）如果应用的其他地方需要显示未读消息总数呢？如何共享这段逻辑？</p><p class="content"><b>选择器</b>背后的思想可用来解决这些问题：</p><p class="reference">选择器是函数，它接收部分state并返回一个值。</p><p class="content">我们来看看如何创建选择器。</p><p class="listTitle1 biaoti8">13.7.2 会话选择器</p><p class="content">先从简单的部分开始。假设我们要在AppState中获取ThreadsState。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/reducers/ThreadsReducer.ts</b></p><p class="daima">export const getThreadsState =（state）：ThreadsState =&gt; state.threads;</p><p class="content">相当简单，对不对？只要给定了顶层的AppState，就可以通过state.threads找到ThreadsState。</p><p class="content">如果我们要获取当前会话，可以这样做：</p><p class="daima">const getCurrentThread =（state：AppState）：Thread =&gt; {</p><p class="daima">　let currentThreadId = state.threads.currentThreadId;</p><p class="daima">　return state.threads.entities[currentThreadId];</p><p class="daima">}</p><p class="content">对于这个小例子来说，这样的选择器就可以胜任。值得考虑的是，如何随着应用的增长让选择器更具可维护性。如果能用选择器来查询其他选择器就好了。如果一个选择器能指定多个其他选择器作为自己的依赖就更好了。</p><p class="content">这些正是reselect<sup><a class="mz-footnote-link" href="#footnote4"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>类库提供的。利用reselect，我们可以创建更小、更专注的选择器，还能结合它们实现更大的功能。</p><p class="content">下面来看看如何使用reselect提供的createSelector方法获取当前会话。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/reducers/ThreadsReducer.ts</b></p><p class="daima">export const getThreadsEntities = createSelector（</p><p class="daima">　getThreadsState,</p><p class="daima">　（state：ThreadsState）=&gt; state.entities）;</p><p class="content">先来写一个getThreadsEntities选择器。getThreadsEntities使用createSelector并传入两个参数：</p><p class="content">（1）之前定义的选择器getThreadsState；</p><p class="content">（2）一个回调函数，用于接收getThreadsState选择器的返回值，并返回我们要选取的值。</p><p class="content">这里只获取了state.entities，看起来似乎有点浪费，但它为我们建立了可维护性更强的选择器。现在看看如何用createSelector创建getCurrentThread。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/reducers/ThreadsReducer.ts</b></p><p class="daima">export const getCurrentThread = createSelector（</p><p class="daima">　getThreadsEntities,</p><p class="daima">　getThreadsState,</p><p class="daima">　（entities：ThreadsEntities, state：ThreadsState）=&gt;</p><p class="daima">　　entities[state.currentThreadId]）;</p><p class="content">注意，这里引用了<b>两个</b>选择器作为依赖：getThreadsEntities和getThreadsState。这些选择器被解析后就会变成回调函数的参数。我们可以把它们组合起来返回当前选中的会话。</p><p class="listTitle1 biaoti8">13.7.3 未读消息总数选择器</p><p class="content">现在我们已经理解了选择器的工作原理，接着就来创建一个选择器以获取未读消息的数量。如果看过前面获取未读消息总数的首次尝试，你会发现每个变量都可以被替换成它们自己的选择器（getThreadsState、getThreadsEntities等）。</p><p class="content">下面是用来获取所有Thread的选择器。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/reducers/ThreadsReducer.ts</b></p><p class="daima">export const getAllThreads = createSelector（</p><p class="daima">　getThreadsEntities,</p><p class="daima">　（entities：ThreadsEntities）=&gt; Object.keys（entities）</p><p class="daima">　　　　　　　　　　　　.map（（threadId）=&gt; entities[threadId]））;</p><p class="content">拿到所有会话之后，我们就可以知道所有会话中的未读消息总数。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/reducers/ThreadsReducer.ts</b></p><p class="daima">export const getUnreadMessagesCount = createSelector（</p><p class="daima">　getAllThreads,</p><p class="daima">　（threads：Thread[]）=&gt; threads.reduce（</p><p class="daima">　　　（unreadCount：number, thread：Thread）=&gt; {</p><p class="daima">　　　　thread.messages.forEach（（message：Message）=&gt; {</p><p class="daima">　　　　　if（！message.isRead）{</p><p class="daima">　　　　　　++unreadCount;</p><p class="daima">　　　　　}</p><p class="daima">　　　　}）;</p><p class="daima">　　　　return unreadCount;</p><p class="daima">　　　},</p><p class="daima">　　　0））;</p><p class="content">有了这个选择器，我们就可以在ChatNavBar组件中（以及应用中任何需要的地方）获取到未读消息的数量。</p><p class="sectionTitle biaoti3"><a id="sec008"></a>13.8 构建ChatThreads组件</p><p class="content">接下来在ChatThreads组件中构建会话列表，如图13-9所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t22279/315/211211919/125328/3716a578/5b03d541N81cc2520.jpg" class="enlarge" alt="" href="./image/a-100.jpg" /></p><p class="descrip"><b>图13-9　按时间排序的会话列表</b></p><p class="listTitle1 biaoti8">13.8.1 ChatThreads控制器</p><p class="content">在查看ChatThreads组件的模板之前，我们先来看看组件的控制器。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/containers/ChatThreads.ts</b></p><p class="daima">export default class ChatThreads {</p><p class="daima">　threads：Thread[];</p><p class="daima">　currentThreadId：string;</p><p class="daima">　constructor（@Inject（AppStore）private store：Store&lt;AppState&gt;）{</p><p class="daima">　　store.subscribe（（）=&gt; this.updateState（））;</p><p class="daima">　　this.updateState（）;</p><p class="daima">　}</p><p class="daima">　updateState（）{</p><p class="daima">　　let state = this.store.getState（）;</p><p class="daima">　　// Store the threads list</p><p class="daima">　　this.threads = getAllThreads（state）;</p><p class="daima">　　// We want to mark the current thread as selected,</p><p class="daima">　　// so we store the currentThreadId as a value</p><p class="daima">　　this.currentThreadId = getCurrentThread（state）.id;</p><p class="daima">　}</p><p class="daima">　handleThreadClicked（thread：Thread）{</p><p class="daima">　　this.store.dispatch（ThreadActions.selectThread（thread））;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">在这个组件中存储了两个实例变量。</p><p class="content">●threads：会话列表。</p><p class="content">●currentThreadId：用户正在操作的当前会话。</p><p class="content">在constructor中保存了一个Redux store的引用并订阅更新。一旦store发生变化，就调用updateState（）。</p><p class="content">updateState（）会保持实例变量与Redux store同步。注意我们正在用的这两个选择器：</p><p class="content">●getAllThreads</p><p class="content">●getCurrentThread</p><p class="content">这样就可以保持它们各自的实例变量总是最新的。</p><p class="content">这里引入了一个新概念：事件处理器handleThreadClicked。handleThreadClicked会分发selectThread这个action。当点击一个会话时，我们就告诉store把这个新会话设为所选会话并且应用的其余部分也应该依次更新。</p><p class="listTitle1 biaoti8">13.8.2 ChatThreads的template</p><p class="content">我们来看一下ChatThreads组件的template及其配置。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/containers/ChatThreads.ts</b></p><p class="daima">*/</p><p class="daima">@Component（{</p><p class="daima">　selector：'chat-threads',</p><p class="daima">　template：`</p><p class="daima">　&lt;！—— conversations ——&gt;</p><p class="daima">　&lt;div class="row"&gt;</p><p class="daima">　　&lt;div class="conversation-wrap"&gt;</p><p class="daima">　　　&lt;chat-thread</p><p class="daima">　　　　　 *ngFor="let thread of threads"</p><p class="daima">　　　　　 [thread]="thread"</p><p class="daima">　　　　　 [selected]="thread.id === currentThreadId"</p><p class="daima">　　　　　（onThreadSelected）="handleThreadClicked（$event）"&gt;</p><p class="daima">　　　&lt;/chat-thread&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="content">我们在模板中使用ngFor来遍历threads。我们还用了一个叫作ChatThread的新组件来渲染单个会话。</p><p class="content">ChatThread是一个展示型组件。在ChatThread中，我们既不能使用store，也不能读取数据和分发action。反之，我们要通过inputs（输入参数）来传入该组件所需的一切，并通过outputs（输出参数）来处理任何交互。</p><p class="content">接着我们会介绍ChatThread的实现，但先来看看这个模板中的输入和输出。</p><p class="content">●使用单个thread变量作为输入属性[thread]；</p><p class="content">●对于输入属性[selected]，我们传入一个布尔值来表明这个会话（thread.id）是否是当前会话（currentThreadId）；</p><p class="content">●如果会话被点击，就发出输出事件（onThreadSelected）。这时就会调用handleThreadClicked（）（它会向store中分发选择会话的事件）。</p><p class="content">我们再来研究一下ChatThread组件。</p><p class="sectionTitle biaoti3"><a id="sec009"></a>13.9 单个ChatThread组件</p><p class="content">ChatThread组件用来显示会话列表中一个单独的会话。记住ChatThread是<b>展示型组件</b>，它只会操作直接给它的那些数据。</p><p class="content">因为它是一个展示型组件，所以我们将它放在app/ts/components文件夹中。</p><p class="content">下面是组件控制器的代码。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/components/ChatThread.ts</b></p><p class="daima">export default class ChatThread {</p><p class="daima">　thread：Thread;</p><p class="daima">　selected：boolean;</p><p class="daima">　onThreadSelected：EventEmitter&lt;Thread&gt;;</p><p class="daima">　constructor（）{</p><p class="daima">　　this.onThreadSelected = new EventEmitter&lt;Thread&gt;（）;</p><p class="daima">　}</p><p class="daima">　clicked（event：any）：void {</p><p class="daima">　　this.onThreadSelected.emit（this.thread）;</p><p class="daima">　　event.preventDefault（）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">这里的看点是onThreadSelected这个EventEmitter。如果你还没怎么用过EventEmitter，可以把它当作观察者模式的一种实现。我们把它作为这个组件的“输出通道”——想发送数据时就调用onThreadSelected.emit方法，把想要发送的数据传进去。</p><p class="content">在这个例子中，我们想把当前会话作为参数传给EventEmitter。当点击这个元素时，我们就会调用onThreadSelected.emit（this.thread），它会触发父级组件（ChatThreads）中的回调函数。</p><p class="listTitle1 biaoti8">ChatThread的@Component和template</p><p class="content">下面是@Component注解和template的代码。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/components/ChatThread.ts</b></p><p class="daima">@Component（{</p><p class="daima">　inputs：['thread', 'selected'],</p><p class="daima">　selector：'chat-thread',</p><p class="daima">　outputs：['onThreadSelected'],</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="media conversation"&gt;</p><p class="daima">　　&lt;div class="pull-left"&gt;</p><p class="daima">　　　&lt;img class="media-object avatar"</p><p class="daima">　　　　　 src="{{thread.avatarSrc}}"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;div class="media-body"&gt;</p><p class="daima">　　　&lt;h5 class="media-heading contact-name"&gt;{{thread.name}}</p><p class="daima">　　　　&lt;span *ngIf="selected"&gt;&amp;bull;&lt;/span&gt;</p><p class="daima">　　　&lt;/h5&gt;</p><p class="daima">　　　&lt;small class="message-preview"&gt;</p><p class="daima">　　　　{{thread.messages[thread.messages.length - 1].text}}</p><p class="daima">　　　&lt;/small&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;a（click）="clicked（$event）" class="div-link"&gt;Select&lt;/a&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="content">这里把thread和selected指定为inputs属性，把onThreadSelected指定为outputs属性。</p><p class="content">注意，视图中使用了一些直接的绑定，比如{{thread.avatarSrc}}和{{thread.name}}。在class为message-preview的标签中有如下代码：</p><p class="daima">　{{ thread.messages[thread.messages.length - 1].text }}</p><p class="content">它会获取会话中的最后一条消息并显示消息的文本，目的是在每个会话中显示最新消息的预览。</p><p class="content">我们还用了*ngIf，会对选中的会话显示&amp;bull;符号。</p><p class="content">最后，我们绑定了（click）事件来调用clicked（）处理器。注意，我们在调用clicked时传入了参数$event。这是Angular提供的一个用来描述事件的特殊变量。我们通过在clicked处理器中调用event.preventDefault（）;来使用它。这样可以确保我们不会跳转到其他页面。</p><p class="sectionTitle biaoti3"><a id="sec010"></a>13.10 构建ChatWindow组件</p><p class="content">ChatWindow是这个应用中最复杂的组件（如图13-10所示）。我们一步一步来完成它。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19204/164/2630789168/98171/c838bdf2/5b03d541N8cd9d21d.jpg" class="enlarge" alt="" href="./image/a-101.jpg" /></p><p class="descrip"><b>图13-10　聊天窗口</b></p><p class="content">ChatWindow类有三个属性：currentThread（其中包括messages）、draftMessage和currentUser。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/containers/ChatWindow.ts</b></p><p class="daima">export default class ChatWindow {</p><p class="daima">　currentThread：Thread;</p><p class="daima">　draftMessage：{ text：string };</p><p class="daima">　currentUser：User;</p><p class="content">图13-11表明了每一个属性在何处使用。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17788/327/2625159315/80554/d50dc928/5b03d541Nda050040.jpg" class="enlarge" alt="" href="./image/a-102.jpg" /></p><p class="descrip"><b>图13-11　聊天窗口的属性</b></p><p class="content">我们在constructor中注入了两样东西。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/containers/ChatWindow.ts</b></p><p class="daima">　constructor（@Inject（AppStore）private store：Store&lt;AppState&gt;,</p><p class="daima">　　　　　　　private el：ElementRef）{</p><p class="daima">　　store.subscribe（（）=&gt; this.updateState（））;</p><p class="daima">　　this.updateState（）;</p><p class="daima">　　this.draftMessage = { text：'' };</p><p class="daima">}</p><p class="content">第一个是Redux store，第二个是el。el是一个ElementRef，可以用来获取宿主DOM元素。当创建和接收新消息的时候，我们会借助它来让聊天窗口滚动到底部。</p><p class="content">我们在构造函数中订阅了store，就像在其他容器型组件中所做的那样。</p><p class="content">接着要做的是设置一个默认的draftMessage，它的text属性是一个空字符串。我们会使用draftMessage来记录用户在输入框中输入的消息。</p><p class="listTitle1 biaoti8">13.10.1 ChatWindow的updateState（）</p><p class="content">当store改变时，我们会更新该组件的实例变量。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/containers/ChatWindow.ts</b></p><p class="daima">　updateState（）{</p><p class="daima">　　let state = this.store.getState（）;</p><p class="daima">　　this.currentThread = getCurrentThread（state）;</p><p class="daima">　　this.currentUser = getCurrentUser（state）;</p><p class="daima">　　this.scrollToBottom（）;</p><p class="daima">　}</p><p class="content">我们存储了当前会话和当前用户。如果来了新消息，我们希望滚动到窗口的底部。在这里调用scrollToBottom有点粗糙，但这种简单的方法可以保证在有新消息时（或用户切换到一个新会话中时）用户不需要每次都手动滚动窗口。</p><p class="listTitle1 biaoti8">13.10.2 ChatWindow的scrollToBottom（）</p><p class="content">为了滚动到聊天窗口的底部，我们将使用保存在构造函数中的类型为ElementRef的el。要让这个元素滚动，就要设置宿主元素的scrollTop属性。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/containers/ChatWindow.ts</b></p><p class="daima">　scrollToBottom（）：void {</p><p class="daima">　　let scrollPane：any = this.el</p><p class="daima">　　　.nativeElement.querySelector（'.msg-container-base'）;</p><p class="daima">　　if（scrollPane）{</p><p class="daima">　　　setTimeout（（）=&gt; scrollPane.scrollTop = scrollPane.scrollHeight）;</p><p class="daima">　　}</p><p class="daima">　}</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21052/24/196067947/10469/3e96e1ef/5b03d540Ncb29ebe3.jpg" class="enlarge" alt="" href="./image/a-20.jpg" /></p><p class="content"><b>为什么使用setTimeout?</b></p><p class="content">如果我们得到新消息时立即调用scrollToBottom，那么滚动到底部的动作就是在新消息渲染完成之前执行的。使用setTimeout可以告诉JavaScript我们要在当前执行队列完成后再运行这个函数。该函数会在组件渲染完成<b>之后</b>执行，这正是我们想要的效果。</p><p class="listTitle1 biaoti8">13.10.3 ChatWindow的sendMessage</p><p class="content">如果我们要发送一条新消息，就要先拿到：</p><p class="content">●当前会话</p><p class="content">●当前用户</p><p class="content">●草稿消息的文本</p><p class="content">然后向store中分发一个新的addMessage action。下面是其代码。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/containers/ChatWindow.ts</b></p><p class="daima">　sendMessage（）：void {</p><p class="daima">　　this.store.dispatch（ThreadActions.addMessage（</p><p class="daima">　　　this.currentThread,</p><p class="daima">　　　{</p><p class="daima">　　　　author：this.currentUser,</p><p class="daima">　　　　isRead：true,</p><p class="daima">　　　　text：this.draftMessage.text</p><p class="daima">　　　}</p><p class="daima">　　））;</p><p class="daima">　　this.draftMessage = { text：'' };</p><p class="daima">　}</p><p class="content">sendMessage函数接收draftMessage参数并用组件的属性来设置author和thread。每条已发送的信息其实都已经被读过了（因为是我们写的），所以将其标记为已读。</p><p class="content">分发这条消息之后，创建一个新的Message对象并把它赋给this.draftMessage。这会清空输入框。创建一个新对象可以确保我们不会改变已经发送给store的消息。</p><p class="listTitle1 biaoti8">13.10.4 ChatWindow的onEnter</p><p class="content">在视图中，我们希望在下面两种场景发送消息：</p><p class="content">（1）用户点击Send按钮；</p><p class="content">（2）用户敲击回车键。</p><p class="content">我们定义一个函数来处理这两种事件。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/containers/ChatWindow.ts</b></p><p class="daima">　onEnter（event：any）：void {</p><p class="daima">　　this.sendMessage（）;</p><p class="daima">　　event.preventDefault（）;</p><p class="daima">　}</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="enlarge" alt="" href="./image/a-9.jpg" /></p><p class="content">我们创建onEnter事件处理器并把sendMessage作为一个单独的函数，这是因为onEnter要接收一个参数event并调用event.preventDefault（）。这种方式下我们还可以在响应浏览器事件之外的场景下调用sendMessage。在这个例子中，我们并没有真的在其他场景下调用sendMessage，但我发现把“真正干活的”函数从事件处理器中独立出来会更好。</p><p class="content">否则，sendMessage函数就会：（1）要求必须传入一个事件对象；（2）处理该事件对象。但是这样一来它的关注点就太多了。</p><p class="content">现在已经处理好了控制器的代码，让我们来看看template。</p><p class="listTitle1 biaoti8">13.10.5 ChatWindow的template</p><p class="content">我们先从面板（panel）的起始标签开始，并且在头部显示聊天的名称。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/containers/ChatWindow.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'chat-window',</p><p class="daima">　template：`</p><p class="daima">　　&lt;div class="chat-window-container"&gt;</p><p class="daima">　　　&lt;div class="chat-window"&gt;</p><p class="daima">　　　　&lt;div class="panel-container"&gt;</p><p class="daima">　　　　　&lt;div class="panel panel-default"&gt;</p><p class="daima">　　　　　　&lt;div class="panel-heading top-bar"&gt;</p><p class="daima">　　　　　　　&lt;div class="panel-title-container"&gt;</p><p class="daima">　　　　　　　　&lt;h3 class="panel-title"&gt;</p><p class="daima">　　　　　　　　　&lt;span class="glyphicon glyphicon-comment"&gt;&lt;/span&gt;</p><p class="daima">　　　　　　　　　Chat - {{currentThread.name}}</p><p class="daima">　　　　　　　　&lt;/h3&gt;</p><p class="daima">　　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　　&lt;div class="panel-buttons-container" &gt;</p><p class="daima">　　　　　　　　&lt;！—— you could put minimize or close buttons here ——&gt;</p><p class="daima">　　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　&lt;div class="panel-body msg-container-base"&gt;</p><p class="content">接下来显示消息列表。这里用ngFor遍历消息列表。我们稍后会讲解单个chat-message组件。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/containers/ChatWindow.ts</b></p><p class="daima">　　　　　　　&lt;chat-message</p><p class="daima">　　　　　　　　　 *ngFor="let message of currentThread.messages"</p><p class="daima">　　　　　　　　　 [message]="message"&gt;</p><p class="daima">　　　　　　　&lt;/chat-message&gt;</p><p class="daima">　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　　&lt;div class="panel-footer"&gt;</p><p class="content">最后是消息输入框和各个结束标签。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/containers/ChatWindow.ts</b></p><p class="daima">　　　　　　&lt;div class="input-group"&gt;</p><p class="daima">　　　　　　　&lt;input type="text"</p><p class="daima">　　　　　　　　　　 class="chat-input"</p><p class="daima">　　　　　　　　　　 placeholder="Write your message here……"</p><p class="daima">　　　　　　　　　　（keydown.enter）="onEnter（$event）"</p><p class="daima">　　　　　　　　　　 [（ngModel）]="draftMessage.text" /&gt;</p><p class="daima">　　　　　　　&lt;span class="input-group-btn"&gt;</p><p class="daima">　　　　　　　　&lt;button class="btn-chat"</p><p class="daima">　　　　　　　　　（click）="onEnter（$event）"</p><p class="daima">　　　　　　　　　 &gt;Send&lt;/button&gt;</p><p class="daima">　　　　　　　&lt;/span&gt;</p><p class="daima">　　　　　　&lt;/div&gt;</p><p class="daima">　　　　　&lt;/div&gt;</p><p class="daima">　　　　&lt;/div&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export default class ChatWindow {</p><p class="content">消息输入框是视图中最有意思的部分，我们来看看其中两个有趣的属性：（keydown.enter）和[（ngModel）]。</p><p class="listTitle1 biaoti8">13.10.6 处理键盘动作</p><p class="content">Angular提供了一种简明的方式来处理键盘动作：在元素上绑定事件。在这个例子中，我们绑定了keydown.enter。这表示如果用户按下回车键，就会调用表达式里的函数onEnter（$event）。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/containers/ChatWindow.ts</b></p><p class="daima">　　　　　　　　　　 class="chat-input"</p><p class="daima">　　　　　　　　　　 placeholder="Write your message here……"</p><p class="daima">　　　　　　　　　　（keydown.enter）="onEnter（$event）"</p><p class="daima">　　　　　　　　　　 [（ngModel）]="draftMessage.text" /&gt;</p><p class="daima">　　　　　　　&lt;span class="input-group-btn"&gt;</p><p class="listTitle1 biaoti8">13.10.7 使用ngModel</p><p class="content">如前所述，Angular并没有像AngularJS那样把双向绑定作为数据架构的核心。特别是当我们使用Redux的时候，它是完全的单向数据流。</p><p class="content">然而在组件及其视图之间进行双向绑定是非常有用的。只要把双向绑定的坏处限制在组件之中，保持组件属性和视图的同步是很方便的。</p><p class="content">对于这个例子，我们在输入框的值和draftMessage.text之间建立了一个双向绑定。如果在输入框中输入文字，draftMessage.text就会自动设置为输入的文字。同样，如果在代码中更新draftMessage.text，那么视图中输入框的值也会随之改变。</p><p class="listTitle1 biaoti8">13.10.8 点击Send按钮</p><p class="content">在Send按钮上将（click）属性绑定到组件中的onEnter函数。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/containers/ChatWindow.ts</b></p><p class="daima">　　　　　　　　　　（click）="onEnter（$event）"</p><p class="daima">　　　　　　　　　　 &gt;Send&lt;/button&gt;</p><p class="daima">　　　　　　　&lt;/span&gt;</p><p class="content">我们使用同一个onEnter函数来处理本事件。也就是说，点击这个按钮和按回车键都可以发送消息。</p><p class="sectionTitle biaoti3"><a id="sec011"></a>13.11 ChatMessage组件</p><p class="content">我们没有把渲染单个消息的代码都放到ChatWindow组件中，而是创建了另一个展示型组件ChatMessage。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="inline1" alt="" href="./image/a-9.jpg" />　提示：如果你发现自己正在使用ngFor，那就表示你该创建一个新组件了。</p><p class="content">每条消息都是通过ChatMessage组件渲染的，如图13-12所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21841/339/203070540/71285/dece9110/5b03d541N93c63094.jpg" class="enlarge" alt="" href="./image/a-103.jpg" /></p><p class="descrip"><b>图13-12　ChatMessage组件</b></p><p class="content">该组件相对简明，其主要逻辑是根据消息是否由当前用户所创建来渲染出略有不同的视图。如果该消息<b>不是</b>当前用户创建的，就认为消息是收到的（incoming）。</p><p class="listTitle1 biaoti8">13.11.1 设置incoming属性</p><p class="content">记住，每个ChatMessage组件都属于一条Message。因此，要在ngOnInit方法里订阅currentUser流并根据这条Message是否由当前用户创建来设置incoming。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/components/ChatMessage.ts</b></p><p class="daima">export default class ChatMessage implements OnInit {</p><p class="daima">　message：Message;</p><p class="daima">　incoming：boolean;</p><p class="daima">　ngOnInit（）：void {</p><p class="daima">　　this.incoming =！this.message.author.isClient;</p><p class="daima">　}</p><p class="daima">}</p><p class="listTitle1 biaoti8">13.11.2 ChatMessage的template</p><p class="content">在template中有两点值得注意：</p><p class="content">（1）FromNowPipe管道</p><p class="content">（2）[ngClass]属性</p><p class="content">先来看其代码。</p><p class="reference"><b>code/redux/angular2-redux-chat/app/ts/components/ChatMessage.ts</b></p><p class="daima">*/</p><p class="daima">@Component（{</p><p class="daima">　inputs：['message'],</p><p class="daima">　selector：'chat-message',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="msg-container"</p><p class="daima">　　　 [ngClass]="{'base-sent'：！incoming, 'base-receive'：incoming}"&gt;</p><p class="daima">　　&lt;div class="avatar"</p><p class="daima">　　　　 *ngIf="！incoming"&gt;</p><p class="daima">　　　&lt;img src="{{message.author.avatarSrc}}"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;div class="messages"</p><p class="daima">　　　[ngClass]="{'msg-sent'：！incoming, 'msg-receive'：incoming}"&gt;</p><p class="daima">　　　&lt;p&gt;{{message.text}}&lt;/p&gt;</p><p class="daima">　　　&lt;p class="time"&gt;{{message.sender}} ? {{message.sentAt | fromNow}}&lt;/p&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;div class="avatar"</p><p class="daima">　　　　 *ngIf="incoming"&gt;</p><p class="daima">　　　&lt;img src="{{message.author.avatarSrc}}"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="content">FromNowPipe是一个管道，把消息的发送时间转换为像“×秒前”这样对用户友好的信息。如你所见，我们要这样使用它：{{message.sentAt | fromNow}}。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　FromNowPipe使用优秀的moment.js<sup><a class="mz-footnote-link" href="#footnote5"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>类库。如果你想学习如何创建自定义管道，可以阅读FromNowPipe的源代码：code/rxjs/chat/app/ts/util/FromNowPipe.ts。</p><p class="content">我们也在视图中充分利用了ngClass。当这样写时：</p><p class="daima">　　[ngClass]="{'msg-sent'：！incoming, 'msg-receive'：incoming}"</p><p class="content">我们是在告诉Angular：如果incoming为真就使用msg-receive类（否则使用msg-sent类）。</p><p class="content">借助incoming属性，我们就能以不同的形式来显示收到和发出的消息。</p><p class="sectionTitle biaoti3"><a id="sec012"></a>13.12 总结</p><p class="content">好了，把它们全部放在一起，就是一个完整的聊天应用了（如图13-13所示）！</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t16771/341/2639145026/67304/b2690627/5b03d540N4d017fd0.jpg" class="enlarge" alt="" href="./image/a-104.jpg" /></p><p class="descrip"><b>图13-13　完成后的聊天应用</b></p><p class="content">查看文件code/redux/angular2-redux-chat/app/ts/ChatExampleData.ts，你会发现我们已经写好了少量可以跟你聊天的机器人。检出这些代码并试着写几个自己的机器人吧！</p><ol class="mz-footnote"><li id="footnote1">https：//www.cygwin.com/</li><li id="footnote2">https：//github.com/paularmstrong/normalizr</li><li id="footnote3">https：//facebook.github.io/immutable-js/</li><li id="footnote4">https：//github.com/reactjs/reselect#createselectorinputselectors——inputselectors-resultfunc</li><li id="footnote5">http：//momentjs.com/</li></ol></body></html>