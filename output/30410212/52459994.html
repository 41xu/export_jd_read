<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><link rel="stylesheet" type="text/css" href="http://storage.360buyimg.com/ebooks/9fd8bb77eb40456b746aaae41785499a_new_.css" /><title>第10章 使用可观察对象的数据架构，第1部分：服务</title></head><body><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t16597/184/2630321120/82338/43bb78d8/5b03d541N02d57691.jpg" class="fullscreen" alt="" href="./image/Figure-010.jpg" /></p><p class="sectionTitle biaoti3"><a id="sec001"></a>10.1 可观察对象和RxJS</p><p class="content">在Angular中，可以使用可观察对象作为数据架构的骨架来构建应用。使用可观察对象构造数据被称为<b>响应式编程</b>（reactive programming）。</p><p class="content">可观察对象和响应式编程究竟是什么呢？响应式编程是一种处理异步数据流的编程方法。可观察对象是用来实现响应式编程的主要数据结构。必须承认，这些术语可能不怎么明确。因此，我们会在本章通过具体的例子来帮助你更好地理解这些概念。</p><p class="listTitle1 biaoti8">10.1.1 注意：一些必备的RxJS相关知识</p><p class="content">需要指出的是，<b>本书的重点不是讲解响应式编程</b>。有一些其他不错的资源可以教会你响应式编程的基础，你应该阅读它们。我们在下面列举了几个。</p><p class="content">你可以将本章视为如何使用RxJS和Angular的入门教程，而不是RxJS和响应式编程的详细指南。</p><p class="content">本章会<b>详细解释我们接触到的RxJS概念和API</b>，但如果RxJS对你来说还是个新鲜事物，那么你可能需要通过其他相关资源来补充知识。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="enlarge" alt="" href="./image/a-3.jpg" /></p><p class="content"><b>本章使用Underscore.js</b></p><p class="content">Underscore.js<sup><a class="mz-footnote-link" href="#footnote1"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>是一个流行的类库，为Array和Object这样的JavaScript数据结构提供函数式操作符。本章将在使用RxJS的同时大量使用它。如果在代码中看见了_，比如_.map或者_.sortBy，要知道这就是在使用Underscore.js类库。要查阅Underscore.js文档，请阅读http：//underscorejs.org/。</p><p class="listTitle1 biaoti8">10.1.2 学习响应式编程和RxJS</p><p class="content">如果你只想学习RxJS，推荐阅读这篇文章。</p><p class="daima">●Andre Staltz的“你不容错过的响应式编程入门”（https：//gist.github.com/staltz/868e7e9bc2a7b8c1f754）</p><p class="content">在你了解一些RxJS背后的概念之后，下面的链接可以帮你在前进的道路上走得更远。</p><p class="content">●“哪些静态操作符可以用来创建流？”（https：//github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/which-static.md）</p><p class="content">●“哪些实例操作符可以在流上使用？”（https：//github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/which-instance.md）</p><p class="content">●RxMarbles：各种流操作的交互式图解（http：//staltz.com/rxmarbles）</p><p class="content">本章由始至终都会提供RxJS的API文档链接。RxJS文档有大量很棒的示例代码，阐明了不同的流和操作符是如何工作的。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21052/24/196067947/10469/3e96e1ef/5b03d540Ncb29ebe3.jpg" class="enlarge" alt="" href="./image/a-20.jpg" /></p><p class="content"><b>Angular必须要用RxJS吗？</b></p><p class="content">不，完全不必。可观察对象只是Angular众多数据模式中的一种。想了解其他数据模式，请参见第9章。</p><p class="content">我想给你提个醒：起初学习RxJS时会有一些烧脑。但是相信我，你终将掌握它的要领，并且这些付出都是值得的。下面是一些关于流的重要概念，会对你有所帮助。</p><p class="content">（1）<b>承诺（promise）发出单个值，而流发出多个值</b>。在应用中，流扮演着和承诺一样的角色。如果你是从回调函数转为承诺的话，会发现相对于回调函数，承诺在可读性和数据可维护性方面都有了很大的改进。同样，流也改进了承诺，可以在流上持续响应数据的变化（与此相反，承诺是一次性解决）。</p><p class="content">（2）<b>命令式代码“拉取”数据，而响应式流“推送”数据</b>。在响应式编程中，代码订阅了数据变化时接收通知，流会把数据“推送”给这些订阅者。</p><p class="content">（3）<b>RxJS是函数式的</b>。如果你热衷于像map、reduce和filter这样的函数式操作符，那么使用RxJS时会感到很轻松；因为在某种意义上讲，数据集合和强大的函数操作符同样适用于流。</p><p class="content">（4）<b>流是可组合的</b>。可以把流想象成一个贯穿数据的操作管道。你可以订阅流中的任何部分，甚至可以组合它们来创建新的流。</p><p class="sectionTitle biaoti3"><a id="sec002"></a>10.2 聊天应用概览</p><p class="content">在本章中，我们将使用RxJS构建聊天应用。界面截图如图10-1所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17161/354/2657989948/67424/faeac896/5b03d541N3f993aa1.jpg" class="enlarge" alt="" href="./image/a-70.jpg" /></p><p class="descrip"><b>图10-1　完成后的聊天应用</b></p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="enlarge" alt="" href="./image/a-3.jpg" /></p><p class="content">我们通常会尝试在书中展现每一行代码。不过这个聊天应用有大量的活动部件，所以本章不会展现所有代码。</p><p class="content">可以在文件夹code/rxjs/chat中找到本章的示例代码。在适当的时候，我们会告诉你在哪里可以找到你想要查看的内容。</p><p class="content">本应用提供了几个机器人，你可以和它们聊天。先运行这些代码看看：</p><p class="daima">　cd code/rxjs/chat</p><p class="daima">　npm install</p><p class="daima">　npm run go</p><p class="content">然后在浏览器中打开http：//localhost：8080。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="inline1" alt="" href="./image/a-9.jpg" />　如果上面的链接无法打开，请尝试这个链接：http：//localhost：8080/webpack-dev-server/index.html。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17728/48/2715397358/11728/16045511/5b03d541N9720f866.jpg" class="inline1" alt="" href="./image/a-4.jpg" />　一些Windows用户在这个目录下运行npm install时可能会遇到问题。如果遇到了，请先确保自己是在Cygwin<sup><a class="mz-footnote-link" href="#footnote2"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>中运行这些命令行。</p><p class="content">你在本应用中要注意以下几点：</p><p class="content">●你可以点击会话（thread）和一个机器人聊天；</p><p class="content">●机器人会根据各自的性格来回复你的消息；</p><p class="content">●右上角的未读消息总数会自动同步。</p><p class="content">下面来看看本应用是如何构造的。我们有：</p><p class="content">●三个顶层Angular组件</p><p class="content">●三个数据模型</p><p class="content">●三个服务</p><p class="content">让我们来逐个看看。</p><p class="listTitle1 biaoti8">10.2.1 组件</p><p class="content">将页面分解成三个顶层组件，如图10-2所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19219/248/2665784842/88527/865a0843/5b03d541Nf4103975.jpg" class="enlarge" alt="" href="./image/a-71.jpg" /></p><p class="descrip"><b>图10-2　聊天应用的顶层组件</b></p><p class="content">●ChatNavBar：包含未读消息数。</p><p class="content">●ChatThreads：展示一个可点击的会话列表，每个会话都包含最新消息和会话头像。</p><p class="content">●ChatWindow：展示当前会话的消息和一个用来发送新消息的输入框。</p><p class="listTitle1 biaoti8">10.2.2 数据模型</p><p class="content">本应用同样包含三个数据模型，如图10-3所示。</p><p class="content">●User：存储聊天参与者的相关信息。</p><p class="content">●Message：存储一条单独的信息。</p><p class="content">●Thread：存储一组消息的集合以及一些与这次会话有关的其他数据。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21865/346/221639359/27913/afd740da/5b03d540Ncfbc2d41.jpg" class="enlarge" alt="" href="./image/a-72.jpg" /></p><p class="descrip"><b>图10-3　聊天应用的数据模型</b></p><p class="listTitle1 biaoti8">10.2.3 服务</p><p class="content">在本应用中，每个数据模型都有其对应的<b>服务</b>。服务都是单例对象，有以下两个作用：</p><p class="content">（1）提供应用可以订阅的数据流；</p><p class="content">（2）提供操作符来添加或更改数据。</p><p class="content">比如，UserService：</p><p class="content">●发布一个流用来通知当前用户；</p><p class="content">●提供一个setCurrentUser函数，用于设置当前用户（即从currentUser流发出当前用户）。</p><p class="listTitle1 biaoti8">10.2.4 总结</p><p class="content">大体上来说，本应用的数据架构很简明：</p><p class="content">●<b>服务</b>负责维护流，而流负责发出数据模型（例如Message）；</p><p class="content">●<b>组件</b>订阅这些流并按照最新的值进行渲染。</p><p class="content">比如，ChatThreads组件订阅ThreadService中的流来获取最新的会话列表，而ChatWindow组件订阅ThreadService中的流来获取最新的消息列表。</p><p class="content">本章其余部分将深入探讨如何使用Angular和RxJS来实现此应用。我们首先实现数据模型，然后看看如何创建服务来管理流，最后实现组件。</p><p class="sectionTitle biaoti3"><a id="sec003"></a>10.3 实现数据模型</p><p class="content">我们先从简单的部分开始，看看数据模型。</p><p class="listTitle1 biaoti8">10.3.1 User</p><p class="content">User类很简明，有id、name和avatarSrc三个属性。</p><p class="reference"><b>code/rxjs/chat/app/ts/models.ts</b></p><p class="daima">export class User {</p><p class="daima">　id：string;</p><p class="daima">　constructor（public name：string,</p><p class="daima">　　　　　　　public avatarSrc：string）{</p><p class="daima">　　this.id = uuid（）;</p><p class="daima">　}</p><p class="daima">}</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　注意上面的代码，我们在构造函数中使用了TypeScript的简写方式。当指明public name：string时，我们是在告诉TypeScript：（1）将name作为类的一个公有属性；（2）当创建一个新的实例时，把参数的值赋给这个属性。</p><p class="listTitle1 biaoti8">10.3.2 Thread</p><p class="content">同样，Thread也是一个简单的TypeScript类。</p><p class="reference"><b>code/rxjs/chat/app/ts/models.ts</b></p><p class="daima">export class Thread {</p><p class="daima">　id：string;</p><p class="daima">　lastMessage：Message;</p><p class="daima">　name：string;</p><p class="daima">　avatarSrc：string;</p><p class="daima">　constructor（id?：string,</p><p class="daima">　　　　　　　name?：string,</p><p class="daima">　　　　　　　avatarSrc?：string）{</p><p class="daima">　　this.id = id || uuid（）;</p><p class="daima">　　this.name = name;</p><p class="daima">　　this.avatarSrc = avatarSrc;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">注意，我们在Thread类中保存了一个lastMessage的引用。这可以使我们在会话列表中显示最新消息。</p><p class="listTitle1 biaoti8">10.3.3 Message</p><p class="content">同样，Message也是个简单的TypeScript类，但是这里使用了一个形式略微不同的构造函数。</p><p class="reference"><b>code/rxjs/chat/app/ts/models.ts</b></p><p class="daima">　lastMessage：Message;</p><p class="content">构造函数中的这种模式允许我们使用构造函数中的关键字参数进行模拟。使用这种模式，可以使用任意的数据来创建一个新的Message，而且不用担心参数的顺序问题。比如，我们可以这样做：</p><p class="daima">　let msg1 = new Message（）;</p><p class="daima">　# or this</p><p class="daima">　let msg2 = new Message（{</p><p class="daima">　　text："Hello Nate Murray！"</p><p class="daima">　}）</p><p class="content">看完了数据模型，我们再来看看第一个服务：UserService。</p><p class="sectionTitle biaoti3"><a id="sec004"></a>10.4 实现UserService</p><p class="content">UserService的意义在于提供这样一个场所：应用可以在这里了解到当前用户信息，并在当前用户发生变化时通知应用的其他部件。</p><p class="content">我们要做的第一件事是创建一个TypeScript类，并为它加上@Injectable注解。<sup><a class="mz-footnote-link" href="#footnote3"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup></p><p class="reference"><b>code/rxjs/chat/app/ts/services/UserService.ts</b></p><p class="daima">export class UserService {</p><p class="daima">　// `currentUser` contains the current user</p><p class="daima">　currentUser：Subject&lt;User&gt; = new BehaviorSubject&lt;User&gt;（null）;</p><p class="daima">　public setCurrentUser（newUser：User）：void {</p><p class="daima">　　this.currentUser.next（newUser）;</p><p class="daima">　}</p><p class="daima">}</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="enlarge" alt="" href="./image/a-3.jpg" /></p><p class="content">我们说这个服务是可注入的，意思是可以把它注入到应用中的其他组件中。简要来说，依赖注入有两大优点：</p><p class="content">（1）让Angular来管理对象的生命周期；</p><p class="content">（2）测试组件时更容易。</p><p class="content">我们在第8章中深入讨论了它。如果你还没有阅读第8章，现在只需要知道可以把它注入到我们的组件中就可以了，代码如下：</p><p class="daima">　 class MyComponent {</p><p class="daima">　　 constructor（public userService：UserService）{</p><p class="daima">　　　 // do something with `userService` here</p><p class="daima">　　 }</p><p class="daima">　 }</p><p class="listTitle1 biaoti8">10.4.1 currentUser流</p><p class="content">接下来设置一个流，用来管理当前用户。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/UserService.ts</b></p><p class="daima">　currentUser：Subject&lt;User&gt; = new BehaviorSubject&lt;User&gt;（null）;</p><p class="content">这里发生了很多事，我们来逐一分解：</p><p class="content">●定义了实例变量currentUser，它是一个Subject流；</p><p class="content">●更准确地说，currentUser是一个包含User的BehaviorSubject；</p><p class="content">●然而，这个流的初始值是null（构造函数参数）。</p><p class="content">如果你没怎么用过RxJS的话，那么可能不知道Subject和BehaviorSubject是什么。你可以把Subject当作一个“读/写”流。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　从技术上来说，Subject<sup><a class="mz-footnote-link" href="#footnote4"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>同时了继承Observable<sup><a class="mz-footnote-link" href="#footnote5"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>和Observer<sup><a class="mz-footnote-link" href="#footnote6"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>。</p><p class="content">因为消息是即时发送的，所以新的订阅者会有丢失流中最新值的风险。这是流的一个副作用，而BehaviourSubject弥补了这一点。</p><p class="content">BehaviourSubject<sup><a class="mz-footnote-link" href="#footnote7"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>有一个特殊的属性，用来<b>存储最新的值</b>。这意味着任何流的订阅者都会接收最新的值。这对于我们来说好极了，因为这意味着应用的任何部分都可以订阅UserService.currentUser流并且可以立即知道当前用户是谁。</p><p class="listTitle1 biaoti8">10.4.2 设置新用户</p><p class="content">当前用户改变时（例如登录），我们需要一个途径将新用户发布到流中。</p><p class="content">有两种暴露API的方法可以做到这件事。</p><p class="content">●<b>直接将新用户添加到流中</b></p><p class="content">更新当前用户的最直接方法就是使用UserService的实例直接发布一个新的User对象到流中，如下所示。</p><p class="daima">userService.subscribe（（newUser）=&gt; {</p><p class="daima">　console.log（'New User is：', newUser.name）;</p><p class="daima">}）</p><p class="daima">// =&gt; New User is：originalUserName</p><p class="daima">let u = new User（'Nate', 'anImgSrc'）;</p><p class="daima">userService.currentUser.next（u）;</p><p class="daima">// =&gt; New User is：Nate</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　注意，这里使用了Subject的next方法来推送一个新值到流中。</p><p class="content">这种做法的好处是可以复用流中现有的API，不需要引入任何新的代码或者API。</p><p class="content">●<b>创建setCurrentUser（newUser：User）方法</b></p><p class="content">另一种更新当前用户的方法是在UserService上创建一个辅助方法，如下所示。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/UserService.ts</b></p><p class="daima">　public setCurrentUser（newUser：User）：void {</p><p class="daima">　　this.currentUser.next（newUser）;</p><p class="daima">　}</p><p class="content">你会注意到我们仍然在使用currentUser流的next方法。为何还要这样做呢？</p><p class="content">这样做的价值在于，currentUser的实现与流的实现进行了解耦。通过把next方法包裹在setCurrentUser方法里，我们有一定的空间来更改UserService的实现而不至于破坏实例。</p><p class="content">在这个例子中，我不会强烈推荐其中某一种方法，但两种方法在大型项目中的可维护性上还是有显著区别的。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　第三种选项是把这些更改暴露为它们自己的流（也就是说我们把更改当前用户的这个“动作”放进流中）。我们会在下面的MessagesService中探讨这种模式。</p><p class="listTitle1 biaoti8">10.4.3 UserService.ts</p><p class="content">把所有代码整合起来，可以得到UserService的完整代码。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/UserService.ts</b></p><p class="daima">import {Injectable} from '@angular/core';</p><p class="daima">import {Subject, BehaviorSubject} from 'rxjs';</p><p class="daima">import {User} from '../models';</p><p class="daima">/**</p><p class="daima">* UserService manages our current user</p><p class="daima">*/</p><p class="daima">@Injectable（）</p><p class="daima">export class UserService {</p><p class="daima">　// `currentUser` contains the current user</p><p class="daima">　currentUser：Subject&lt;User&gt; = new BehaviorSubject&lt;User&gt;（null）;</p><p class="daima">　public setCurrentUser（newUser：User）：void {</p><p class="daima">　　this.currentUser.next（newUser）;</p><p class="daima">　}</p><p class="daima">}</p><p class="daima">export var userServiceInjectables：Array&lt;any&gt; = [</p><p class="daima">　UserService</p><p class="daima">];</p><p class="sectionTitle biaoti3"><a id="sec005"></a>10.5 MessagesService</p><p class="content">MessagesService是这个应用的支柱。此应用中的所有消息都要流经MessagesService。</p><p class="content">相比于UserService，MessagesService包含一些更复杂的流，它由五个流组成：三个数据管理流和两个动作流。</p><p class="content">三个数据管理流分别是：</p><p class="content">●newMessages，发出每条新Message并且每条只发出一次；</p><p class="content">●messages，发出一组当前的Messages；</p><p class="content">●updates，在messages流上执行操作。</p><p class="listTitle1 biaoti8">10.5.1 newMessages流</p><p class="content">newMessages是一个Subject，用来发出每条新Message并且每条只发出一次。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/MessagesService.ts</b></p><p class="daima">export class MessagesService {</p><p class="daima">　// a stream that publishes new messages only once</p><p class="daima">　newMessages：Subject&lt;Message&gt; = new Subject&lt;Message&gt;（）;</p><p class="content">我们还可以定义一个辅助方法来添加Message到这个流中。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/MessagesService.ts</b></p><p class="daima">　addMessage（message：Message）：void {</p><p class="daima">　　this.newMessages.next（message）;</p><p class="daima">　}</p><p class="content">有这样的一个流还是很有帮助的，它可以从一个会话中获取不属于某个特殊用户的所有消息。以回声机器人（Echo Bot）为例，如图10-4所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20314/12/216272135/101032/1880aa5c/5b03d541N5958715a.jpg" class="enlarge" alt="" href="./image/a-73.jpg" /></p><p class="descrip"><b>图10-4　回声机器人</b></p><p class="content">当实现回声机器人时，我们不想进入一个重复机器人本身消息的死循环。</p><p class="content">要实现这一点，我们可以订阅newMessages流并根据下面的条件过滤所有消息：</p><p class="content">（1）是这个会话的一部分；</p><p class="content">（2）不是机器人产生的。</p><p class="content">你可以这样理解，对于一个给定的Thread，我们想要一个不包含这个User的消息流。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/MessagesService.ts</b></p><p class="daima">　messagesForThreadUser（thread：Thread, user：User）：Observable&lt;Message&gt; {</p><p class="daima">　　return this.newMessages</p><p class="daima">　　　.filter（（message：Message）=&gt; {</p><p class="daima">　　　　　　　 // belongs to this thread</p><p class="daima">　　　　return（message.thread.id === thread.id）&amp;&amp;</p><p class="daima">　　　　　　　 // and isn't authored by this user</p><p class="daima">　　　　　　　（message.author.id！== user.id）;</p><p class="daima">　　　}）;</p><p class="daima">　}</p><p class="content">messagesForThreadUser接收一个Thread对象和一个User对象并返回一个经过筛选的新Message流。筛选条件是消息属于这个Thread，而且不是由这个User写的。也就是说，这是一个在此Thread中的其他人的消息流。</p><p class="listTitle1 biaoti8">10.5.2 messages流</p><p class="content">newMessages流发出单个的Message对象，而messages流发出<b>一组最新的Message对象</b>。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/MessagesService.ts</b></p><p class="daima">　messages：Observable&lt;Message[]&gt;;</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　类型Message[]等同于Array&lt;Message&gt;。另一种等价的写法是Observable&lt;Array&lt;Message&gt;&gt;。当定义messages流的类型为Observable&lt;Message[]&gt;时，表示这个流发出的是一个数组（Message对象的数组），而不是单个的Messages。</p><p class="content">那么messages是如何填充的呢？为此我们需要讨论updates流和一种新的模式：操作流。</p><p class="listTitle1 biaoti8">10.5.3 操作流模式</p><p class="content">下面是操作流模式的基本理念：</p><p class="content">●在messages流中维护状态，它会保存一个最新的Message数组；</p><p class="content">●使用一个updates流，即应用于messages流的<b>函数流</b>。</p><p class="content">你可以这样理解：任何updates流上的函数都会更改当前的消息列表。updates流上的函数应该<b>接收一个Message对象列表</b>然后<b>返回一个Message对象列表</b>。让我们在代码中通过创建一个接口来使这个概念形式化。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/MessagesService.ts</b></p><p class="daima">interface IMessagesOperation extends Function {</p><p class="daima">　（messages：Message[]）：Message[];</p><p class="daima">}</p><p class="content">下面来定义updates流。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/MessagesService.ts</b></p><p class="daima">　// `updates` receives _operations_ to be applied to our `messages`</p><p class="daima">　// it's a way we can perform changes on *all* messages（that are currently</p><p class="daima">　// stored in `messages`）</p><p class="daima">　updates：Subject&lt;any&gt; = new Subject&lt;any&gt;（）;</p><p class="content">记住，updates流接收用来应用到消息列表的<b>操作</b>。但是如何把这些关联起来呢？实现方法如下（在MessagesService的constructor中）。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/MessagesService.ts</b></p><p class="daima">　constructor（）{</p><p class="daima">　　this.messages = this.updates</p><p class="daima">　　　// watch the updates and accumulate operations on the messages</p><p class="daima">　　　.scan（（messages：Message[],</p><p class="daima">　　　　　　 operation：IMessagesOperation）=&gt; {</p><p class="daima">　　　　　　　 return operation（messages）;</p><p class="daima">　　　　　　 },</p><p class="daima">　　　　　　 initialMessages）</p><p class="daima">　　　// make sure we can share the most recent list of messages across anyone</p><p class="content">这段代码引入了新的流函数：scan<sup><a class="mz-footnote-link" href="#footnote8"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>。如果你熟悉函数式编程的话，scan很像reduce：它为输入流中的每个元素运行函数并<b>累加出一个值</b>。scan的特别之处在于，它会<b>把每个中间过程中计算出的结果值发送出去</b>。也就是说，它不会等到流全部完成后再发送结果值；这正是我们想要的。</p><p class="content">当调用this.updates.scan时，我们会创建一个新的流。这个流订阅了updates流。scan内部执行的每一次，我们都会得到：</p><p class="content">（1）经过累加的messages流；</p><p class="content">（2）将要应用的新operation。</p><p class="content">然后返回新的Message[]。</p><p class="listTitle1 biaoti8">10.5.4 共享流</p><p class="content">关于流，你需要知道的一点是它们默认是不可共享的。也就是说，如果一个订阅者从流中读取了一个值，读完后这个值就永远消失了。在这个例子中，我们想：（1）在一些订阅者之间共享同样的流；（2）为任何未来的订阅者重播最新的值。</p><p class="content">要做到这点，我们使用操作符publishReplay和refCount。</p><p class="content">●publishReplay可以让我们在多个订阅者之间共享同一个订阅，并为未来的订阅者重播<em>n</em>个最新的值。（参见publish<sup><a class="mz-footnote-link" href="#footnote9"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>和replay<sup><a class="mz-footnote-link" href="#footnote10"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>）</p><p class="content">●refCount<sup><a class="mz-footnote-link" href="#footnote11"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>通过对可观察对象何时发出值进行管理，使publish方法的返回值用起来更加方便。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="enlarge" alt="" href="./image/a-9.jpg" /></p><p class="content"><b>等等，refCount到底是干什么的？</b></p><p class="content">refCount可能有一些不太好理解，因为它涉及一个如何管理“热”的可观察对象和“冷”的可观察对象。我们不打算深入讲解它的工作原理，读者可自行阅读相关文档。</p><p class="content">●关于refCount的RxJS文档：https：//github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/refcount.md</p><p class="content">●“Rx介绍：‘热’的可观察对象和‘冷’的可观察对象”：http：//www.introtorx.com/Content/v1.0.10621.0/14_HotAndColdObservables.html#RefCount</p><p class="content">●refCount弹珠图解：http：//reactivex.io/documentation/operators/refcount.html</p><p class="reference"><b>code/rxjs/chat/app/ts/services/MessagesService.ts</b></p><p class="daima">　　　// watch the updates and accumulate operations on the messages</p><p class="daima">　　　.scan（（messages：Message[],</p><p class="daima">　　　　　　 operation：IMessagesOperation）=&gt; {</p><p class="daima">　　　　　　　 return operation（messages）;</p><p class="daima">　　　　　　 },</p><p class="daima">　　　　　　initialMessages）</p><p class="daima">　　　// make sure we can share the most recent list of messages across anyone</p><p class="daima">　　　// who's interested in subscribing and cache the last known list of</p><p class="daima">　　　// messages</p><p class="daima">　　　.publishReplay（1）</p><p class="daima">　　　.refCount（）;</p><p class="listTitle1 biaoti8">10.5.5 把Message对象添加到messages流中</p><p class="content">现在我们可以把一个Message对象添加到messages流中，如下所示：</p><p class="daima">var myMessage = new Message（/* params here…… */）;</p><p class="daima">updates.next（（messages：Message[]）：Message[] =&gt; {</p><p class="daima">　return messages.concat（myMessage）;</p><p class="daima">}）</p><p class="content">我们添加了一个操作到updates流中。因为messages流订阅了updates流，所以它会应用这个操作，而操作会使用concat把我们的newMessage合并到累加的messages列表之中。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　如果这里需要花费你一些时间来仔细思考，也没有关系。要是你不习惯这种编程风格的话，是会感觉有些陌生。</p><p class="content">上面的方法有一个问题，那就是它使用起来有些繁琐。要是不用每次都写这种内部函数就好了。我们可以像下面这样做：</p><p class="daima">addMessage（newMessage：Message）{</p><p class="daima">　updates.next（（messages：Message[]）：Message[] =&gt; {</p><p class="daima">　　return messages.concat（newMessage）;</p><p class="daima">　}）</p><p class="daima">}</p><p class="daima">// somewhere else</p><p class="daima">var myMessage = new Message（/* params here…… */）;</p><p class="daima">MessagesService.addMessage（myMessage）;</p><p class="content">现在好一些了，但它还不是“响应式的方式”。这是因为这种创建消息的行为不能和其他流组合。（该方法也绕过了newMessage流。稍后将进行更详细的讨论。）</p><p class="content">创建新消息的响应式做法是<b>用一个流来接收Message对象并把它添加到消息列表中</b>。再次声明，如果你还没有习惯这种思维方式的话，那么这对于你来说会有些陌生。下面介绍实现它的方法。</p><p class="content">首先，我们创建一个叫作create的动作流。（<b>动作流</b>这个术语只是用来描述它在服务中的角色。这个流本身只是一个普通的Subject。）</p><p class="reference"><b>code/rxjs/chat/app/ts/services/MessagesService.ts</b></p><p class="daima">　// action streams</p><p class="daima">　create：Subject&lt;Message&gt; = new Subject&lt;Message&gt;（）;</p><p class="content">接下来，我们在构造函数中配置了create流。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/MessagesService.ts</b></p><p class="daima">　　this.create</p><p class="daima">　　　.map（function（message：Message）：IMessagesOperation {</p><p class="daima">　　　　return（messages：Message[]）=&gt; {</p><p class="daima">　　　　　return messages.concat（message）;</p><p class="daima">　　　　};</p><p class="daima">　　　}）</p><p class="content">map操作符<sup><a class="mz-footnote-link" href="#footnote12"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>和JavaScript中内置的Array.map很像，只不过它是在流上的工作。也就是说，它为流中的每一项运行函数并发出函数的返回值。</p><p class="content">在这个例子中，我们的意思是“对于我们接收并作为输入的每个Message对象来说，都返回IMessagesOperation，它会把这个消息添加到消息列表中”。换句话说，这个流会发出一个<b>函数</b>，这个函数接收Message对象的列表并把这个Message对象添加到消息列表中。</p><p class="content">现在有了create流，还有一件事要做：实际上，我们需要把create流连接到updates流。我们使用subscribe<sup><a class="mz-footnote-link" href="#footnote13"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>来完成。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/MessagesService.ts</b></p><p class="daima">　　this.create</p><p class="daima">　　　.map（function（message：Message）：IMessagesOperation {</p><p class="daima">　　　　return（messages：Message[]）=&gt; {</p><p class="daima">　　　　　return messages.concat（message）;</p><p class="daima">　　　　};</p><p class="daima">　　　}）</p><p class="daima">　　　.subscribe（this.updates）;</p><p class="content">我们在这里所做的就是<b>订阅</b>updates流来监听create流。这表示，如果create流接收了一个Message对象，那么它会发出一个IMessagesOperation；updates流会接收这个IMessagesOperation，然后把Message对象添加到messages流中。</p><p class="content">图10-5展现了当前的情况。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19957/187/632716970/25866/f022895a/5b03d541Na8b46b7f.jpg" class="enlarge" alt="" href="./image/a-74.jpg" /></p><p class="descrip"><b>图10-5　从create流开始创建新消息</b></p><p class="content">这很棒！因为它意味着我们：</p><p class="content">（1）从messages流中获取了当前消息列表；</p><p class="content">（2）获得了在当前消息列表上进行操作的一种方式（通过updates流）；</p><p class="content">（3）通过一个简单易用的流把创建操作放在了updates流上（通过create流）。</p><p class="content">不论在代码的什么地方，只要想获取最新消息列表，就必须要用messages流。但是还有一个问题，<b>我们还没有把这个流程和newMessages流关联起来</b>。</p><p class="content">如果有一种方式可以轻松地把这个流和任何newMessages流发出的Message关联起来，那就太好了。事实证明这很容易。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/MessagesService.ts</b></p><p class="daima">　　this.newMessages</p><p class="daima">　　　.subscribe（this.create）;</p><p class="content">现在的情况如图10-6所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17599/244/2581329549/31085/b2f5d495/5b03d541N88ff1c19.jpg" class="enlarge" alt="" href="./image/a-75.jpg" /></p><p class="descrip"><b>图10-6　从newMessages流开始创建新消息</b></p><p class="content">现在的流程完整了！这也是两全其美的：我们能够通过订阅newMessages来获取单条消息；而如果只想要最新的消息列表，我们可以订阅messages流。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17728/48/2715397358/11728/16045511/5b03d541N9720f866.jpg" class="enlarge" alt="" href="./image/a-4.jpg" /></p><p class="content">这里需要指出这个设计的一些影响：如果你直接订阅了newMessages流，必须要注意变化可能发生在下游。这里有三点需要考虑。</p><p class="content">第一，显然不会有任何下游的更新应用于Message。</p><p class="content">第二，在这个案例中，我们的Message对象是<b>可变的</b>。如果你订阅newMessages流并保存了Message的引用，那么这个Message的属性可能会产生变化。</p><p class="content">第三，如果想利用Message的可变性，你可能无法做到。考虑这种情况：我们可以在updates流队列上增加一个操作，此操作复制每个Message然后改变这个副本。（与我们现在的做法相比，这应该是更好的设计。）在这个例子中，你不能依赖任何从newMessages流直接发出的Message，因为它们是可以改变的。</p><p class="content">尽管如此，只要你记住这些注意事项，就应该不会有太大麻烦。</p><p class="listTitle1 biaoti8">10.5.6 完整的MessagesService</p><p class="content">完整的MessagesService代码如下。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/MessagesService.ts</b></p><p class="daima">import {Injectable} from '@angular/core';</p><p class="daima">import {Subject, Observable} from 'rxjs';</p><p class="daima">import {User, Thread, Message} from '../models';</p><p class="daima">let initialMessages：Message[] = [];</p><p class="daima">interface IMessagesOperation extends Function {</p><p class="daima">　（messages：Message[]）：Message[];</p><p class="daima">}</p><p class="daima">@Injectable（）</p><p class="daima">export class MessagesService {</p><p class="daima">　// a stream that publishes new messages only once</p><p class="daima">　newMessages：Subject&lt;Message&gt; = new Subject&lt;Message&gt;（）;</p><p class="daima">　// `messages` is a stream that emits an array of the most up to date messages</p><p class="daima">　messages：Observable&lt;Message[]&gt;;</p><p class="daima">　// `updates` receives _operations_ to be applied to our `messages`</p><p class="daima">　// it's a way we can perform changes on *all* messages（that are currently</p><p class="daima">　// stored in `messages`）</p><p class="daima">　updates：Subject&lt;any&gt; = new Subject&lt;any&gt;（）;</p><p class="daima">　// action streams</p><p class="daima">　create：Subject&lt;Message&gt; = new Subject&lt;Message&gt;（）;</p><p class="daima">　markThreadAsRead：Subject&lt;any&gt; = new Subject&lt;any&gt;（）;</p><p class="daima">　constructor（）{</p><p class="daima">　　this.messages = this.updates</p><p class="daima">　　　// watch the updates and accumulate operations on the messages</p><p class="daima">　　　.scan（（messages：Message[],</p><p class="daima">　　　　　　 operation：IMessagesOperation）=&gt; {</p><p class="daima">　　　　　　　 return operation（messages）;</p><p class="daima">　　　　　　 },</p><p class="daima">　　　　　　initialMessages）</p><p class="daima">　　　// make sure we can share the most recent list of messages across anyone</p><p class="daima">　　　// who's interested in subscribing and cache the last known list of</p><p class="daima">　　　// messages</p><p class="daima">　　　.publishReplay（1）</p><p class="daima">　　　.refCount（）;</p><p class="daima">　　　// `create` takes a Message and then puts an operation（the inner function）</p><p class="daima">　　　// on the `updates` stream to add the Message to the list of messages.</p><p class="daima">　　　//</p><p class="daima">　　　// That is, for each item that gets added to `create`（by using `next`）</p><p class="daima">　　　// this stream emits a concat operation function.</p><p class="daima">　　　//</p><p class="daima">　　　// Next we subscribe `this.updates` to listen to this stream, which means</p><p class="daima">　　　// that it will receive each operation that is created</p><p class="daima">　　　//</p><p class="daima">　　　// Note that it would be perfectly acceptable to simply modify the</p><p class="daima">　　　// "addMessage" function below to simply add the inner operation function to</p><p class="daima">　　　// the update stream directly and get rid of this extra action stream</p><p class="daima">　　　// entirely．The pros are that it is potentially clearer．The cons are that</p><p class="daima">　　　// the stream is no longer composable.</p><p class="daima">　　　this.create</p><p class="daima">　　　　.map（function（message：Message）：IMessagesOperation {</p><p class="daima">　　　　　return（messages：Message[]）=&gt; {</p><p class="daima">　　　　　　return messages.concat（message）;</p><p class="daima">　　　　　};</p><p class="daima">　　　　}）</p><p class="daima">　　　　.subscribe（this.updates）;</p><p class="daima">　　　this.newMessages</p><p class="daima">　　　　.subscribe（this.create）;</p><p class="daima">　　　// similarly, `markThreadAsRead` takes a Thread and then puts an operation</p><p class="daima">　　　// on the `updates` stream to mark the Messages as read</p><p class="daima">　　　this.markThreadAsRead</p><p class="daima">　　　　.map（（thread：Thread）=&gt; {</p><p class="daima">　　　　　return（messages：Message[]）=&gt; {</p><p class="daima">　　　　　　return messages.map（（message：Message）=&gt; {</p><p class="daima">　　　　　　　// note that we're manipulating `message` directly here．Mutability</p><p class="daima">　　　　　　　// can be confusing and there are lots of reasons why you might want</p><p class="daima">　　　　　　　// to, say, copy the Message object or some other 'immutable' here</p><p class="daima">　　　　　　　if（message.thread.id === thread.id）{</p><p class="daima">　　　　　　　　message.isRead = true;</p><p class="daima">　　　　　　　}</p><p class="daima">　　　　　　　return message;</p><p class="daima">　　　　　　}）;</p><p class="daima">　　　　　};</p><p class="daima">　　　　}）</p><p class="daima">　　　　.subscribe（this.updates）;</p><p class="daima">　　}</p><p class="daima">　　// an imperative function call to this action stream</p><p class="daima">　　addMessage（message：Message）：void {</p><p class="daima">　　　this.newMessages.next（message）;</p><p class="daima">　　}</p><p class="daima">　　messagesForThreadUser（thread：Thread, user：User）：Observable&lt;Message&gt; {</p><p class="daima">　　　return this.newMessages</p><p class="daima">　　　　.filter（（message：Message）=&gt; {</p><p class="daima">　　　　　　　　 // belongs to this thread</p><p class="daima">　　　　　return（message.thread.id === thread.id）&amp;&amp;</p><p class="daima">　　　　　　　　 // and isn't authored by this user</p><p class="daima">　　　　　　　　（message.author.id！== user.id）;</p><p class="daima">　　　　}）;</p><p class="daima">　}</p><p class="daima">}</p><p class="daima">export var messagesServiceInjectables：Array&lt;any&gt; = [</p><p class="daima">　MessagesService</p><p class="daima">];</p><p class="listTitle1 biaoti8">10.5.7 试用MessagesService</p><p class="content">如果你还没有完全理解，那么现在是个打开代码并随意尝试MessagesService的好时机，来感受一下它是如何运作的。在test/services/MessagesService.spec.ts中有一个示例，可以直接拿来使用。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="enlarge" alt="" href="./image/a-3.jpg" /></p><p class="content">要运行这个项目的测试，可以打开终端，然后输入以下代码：</p><p class="daima">cd /path/to/code/rxjs/chat // &lt;—— your path will vary</p><p class="daima">npm install</p><p class="daima">karma start</p><p class="content">首先创建一些数据模型的实例。</p><p class="reference"><b>code/rxjs/chat/test/services/MessagesService.spec.ts</b></p><p class="daima">import {MessagesService} from '../../app/ts/services/services';</p><p class="daima">import {Message, User, Thread} from '../../app/ts/models';</p><p class="daima">describe（'MessagesService',（）=&gt; {</p><p class="daima">　it（'should test',（）=&gt; {</p><p class="daima">　　let user：User = new User（'Nate', ''）;</p><p class="daima">　　let thread：Thread = new Thread（'t1', 'Nate', ''）;</p><p class="daima">　　let m1：Message = new Message（{</p><p class="daima">　　　author：user,</p><p class="daima">　　　text：'Hi！',</p><p class="daima">　　　thread：thread</p><p class="daima">　　}）;</p><p class="daima">　　let m2：Message = new Message（{</p><p class="daima">　　　author：user,</p><p class="daima">　　　text：'Bye！',</p><p class="daima">　　　thread：thread</p><p class="daima">　　}）;</p><p class="content">接下来，订阅几个流。</p><p class="reference"><b>code/rxjs/chat/test/services/MessagesService.spec.ts</b></p><p class="daima">　　let messagesService：MessagesService = new MessagesService（）;</p><p class="daima">　　// listen to each message indivdually as it comes in</p><p class="daima">　　messagesService.newMessages</p><p class="daima">　　　.subscribe（（message：Message）=&gt; {</p><p class="daima">　　　　console.log（'=&gt; newMessages：' + message.text）;</p><p class="daima">　　　}）;</p><p class="daima">　　// listen to the stream of most current messages</p><p class="daima">　　messagesService.messages</p><p class="daima">　　　.subscribe（（messages：Message[]）=&gt; {</p><p class="daima">　　　　console.log（'=&gt; messages：' + messages.length）;</p><p class="daima">　　　}）;</p><p class="daima">　　messagesService.addMessage（m1）;</p><p class="daima">　　messagesService.addMessage（m2）;</p><p class="daima">　　// =&gt; messages：1</p><p class="daima">　　// =&gt; newMessages：Hi！</p><p class="daima">　　// =&gt; messages：2</p><p class="daima">　　// =&gt; newMessages：Bye！</p><p class="daima">　}）;</p><p class="daima">}）;</p><p class="content">注意，尽管我们先订阅了newMessages并且newMessages是通过addMessage方法直接调用的，但是messages流的订阅先输出了日志。原因就是messages流订阅newMessages流早于测试代码中的订阅（当MessagesService实例化时）。（你不应该依赖于代码中单独的流的顺序，但是它为什么以这种方式运行是值得思考的。）</p><p class="content">尝试使用MessagesService并感受一下这些流是如何工作的。我们将在下节中使用它们来构建ThreadsService。</p><p class="sectionTitle biaoti3"><a id="sec006"></a>10.6 ThreadsService</p><p class="content">在ThreadsService中将定义四个流，它们分别发出：</p><p class="content">（1）当前一组Thread的映射（threads流）；</p><p class="content">（2）按时间逆序排列的Thread列表（orderedthreads流）；</p><p class="content">（3）当前已选的Thread（currentThread流）；</p><p class="content">（4）当前已选Thread的Message列表（currentThreadMessages流）。</p><p class="content">下面来讨论如何构建这里的每一个流。在这个过程中，我们还将学习更多关于RxJS的知识。</p><p class="listTitle1 biaoti8">10.6.1 当前一组Thread的映射（threads流）</p><p class="content">我们先来定义ThreadsService类和用来发出Thread的实例变量。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">import {Injectable} from '@angular/core';</p><p class="daima">import {Subject, BehaviorSubject, Observable} from 'rxjs';</p><p class="daima">import {Thread, Message} from '../models';</p><p class="daima">import {MessagesService} from './MessagesService';</p><p class="daima">import * as _ from 'underscore';</p><p class="daima">@Injectable（）</p><p class="daima">export class ThreadsService {</p><p class="daima">　// `threads` is a observable that contains the most up to date list of threads</p><p class="daima">　threads：Observable&lt;{ [key：string]：Thread }&gt;;</p><p class="content">注意，这个流会发出一个映射（即一个对象），将Thread的id作为string键，Thread本身作为值。</p><p class="content">要创建一个用来维护当前会话列表的流，我们先附加到messagesService.messages流。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">　threads：Observable&lt;{ [key：string]：Thread }&gt;;</p><p class="content">回忆一下，每次把一个新的Message对象添加到流时，messages流都会发出一个当前Message对象的数组。我们要查看每个Message对象并返回唯一的Threads列表。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">　　this.threads = messagesService.messages</p><p class="daima">　　　.map（（messages：Message[]）=&gt; {</p><p class="daima">　　　　let threads：{[key：string]：Thread} = {};</p><p class="daima">　　　　// Store the message's thread in our accumulator `threads`</p><p class="daima">　　　　messages.map（（message：Message）=&gt; {</p><p class="daima">　　　　　threads[message.thread.id] = threads[message.thread.id] ||</p><p class="daima">　　　　　　message.thread;</p><p class="content">注意，每次都会创建一个新的threads列表。这样做的原因是，我们可能会彻底删除一些消息（例如离开对话）。因为每次我们都重新计算会话列表，所以自然而然地“删除”了没有消息的会话。</p><p class="content">在会话列表中，我们想通过使用Thread中的最新Message来显示聊天预览。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t22402/306/208624445/125328/3716a578/5b03d540N529c963b.jpg" class="enlarge" alt="" href="./image/a-76.jpg" /></p><p class="descrip"><b>图10-7　带有聊天预览功能的会话列表</b></p><p class="content">要做到这一点，我们在每个Thread中都保存了最新的Message。通过比较sentAt时间就可以知道哪个Message是最新的。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">　　　　// Cache the most recent message for each thread</p><p class="daima">　　　　let messagesThread：Thread = threads[message.thread.id];</p><p class="daima">　　　　if（！messagesThread.lastMessage ||</p><p class="daima">　　　　　　messagesThread.lastMessage.sentAt &lt; message.sentAt）{</p><p class="daima">　　　　　messagesThread.lastMessage = message;</p><p class="daima">　　　　}</p><p class="daima">　　　}）;</p><p class="daima">　　　return threads;</p><p class="daima">　　}）;</p><p class="content">把所有代码整合起来，threads流看起来如下所示。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">　　this.threads = messagesService.messages</p><p class="daima">　　　.map（（messages：Message[]）=&gt; {</p><p class="daima">　　　　let threads：{[key：string]：Thread} = {};</p><p class="daima">　　　　// Store the message's thread in our accumulator `threads`</p><p class="daima">　　　　messages.map（（message：Message）=&gt; {</p><p class="daima">　　　　　threads[message.thread.id] = threads[message.thread.id] ||</p><p class="daima">　　　　　　message.thread;</p><p class="daima">　　　　// Cache the most recent message for each thread</p><p class="daima">　　　　let messagesThread：Thread = threads[message.thread.id];</p><p class="daima">　　　　if（！messagesThread.lastMessage ||</p><p class="daima">　　　　　　messagesThread.lastMessage.sentAt &lt; message.sentAt）{</p><p class="daima">　　　　　messagesThread.lastMessage = message;</p><p class="daima">　　　　}</p><p class="daima">　　　}）;</p><p class="daima">　　　return threads;</p><p class="daima">　　}）;</p><p class="content"><b>试用ThreadsService</b></p><p class="content">我们来试试ThreadsService。首先创建一些要用的数据模型。</p><p class="reference"><b>code/rxjs/chat/test/services/ThreadsService.spec.ts</b></p><p class="daima">import {MessagesService, ThreadsService} from '../../app/ts/services/services';</p><p class="daima">import {Message, User, Thread} from '../../app/ts/models';</p><p class="daima">import * as _ from 'underscore';</p><p class="daima">describe（'ThreadsService',（）=&gt; {</p><p class="daima">　it（'should collect the Threads from Messages',（）=&gt; {</p><p class="daima">　　let nate：User = new User（'Nate Murray', ''）;</p><p class="daima">　　let felipe：User = new User（'Felipe Coury', ''）;</p><p class="daima">　　let t1：Thread = new Thread（'t1', 'Thread 1', ''）;</p><p class="daima">　　let t2：Thread = new Thread（'t2', 'Thread 2', ''）;</p><p class="daima">　　let m1：Message = new Message（{</p><p class="daima">　　　author：nate,</p><p class="daima">　　　text：'Hi！',</p><p class="daima">　　　thread：t1</p><p class="daima">　　}）;</p><p class="daima">　　let m2：Message = new Message（{</p><p class="daima">　　　author：felipe,</p><p class="daima">　　　text：'Where did you get that hat?',</p><p class="daima">　　　thread：t1</p><p class="daima">　　}）;</p><p class="daima">　　let m3：Message = new Message（{</p><p class="daima">　　　author：nate,</p><p class="daima">　　　text：'Did you bring the briefcase?',</p><p class="daima">　　　thread：t2</p><p class="daima">　　}）;</p><p class="content">创建服务的一个实例。</p><p class="reference"><b>code/rxjs/chat/test/services/ThreadsService.spec.ts</b></p><p class="daima">　　let messagesService：MessagesService = new MessagesService（）;</p><p class="daima">　　let threadsService：ThreadsService = new ThreadsService（messagesService）;</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　注意，这里把messagesService作为参数传给了ThreadsService的构造函数。我们通常让依赖注入系统来处理这些，但在测试中可以自己提供依赖关系。</p><p class="content">我们订阅threads流并把通过流的内容打印出来。</p><p class="reference"><b>code/rxjs/chat/test/services/ThreadsService.spec.ts</b></p><p class="daima">　　let threadsService：ThreadsService = new ThreadsService（messagesService）;</p><p class="daima">　　threadsService.threads</p><p class="daima">　　　.subscribe（（threadIdx：{ [key：string]：Thread }）=&gt; {</p><p class="daima">　　　　let threads：Thread[] = _.values（threadIdx）;</p><p class="daima">　　　　let threadNames：string = _.map（threads,（t：Thread）=&gt; t.name）</p><p class="daima">　　　　　　　　　　　　　　　　　 .join（', '）;</p><p class="daima">　　　　console.log（`=&gt; threads（${threads.length}）：${threadNames} `）;</p><p class="daima">　　　}）;</p><p class="daima">　　messagesService.addMessage（m1）;</p><p class="daima">　　messagesService.addMessage（m2）;</p><p class="daima">　　messagesService.addMessage（m3）;</p><p class="daima">　　// =&gt; threads（1）：Thread 1</p><p class="daima">　　// =&gt; threads（1）：Thread 1</p><p class="daima">　　// =&gt; threads（2）：Thread 1, Thread 2</p><p class="daima">　}）;</p><p class="daima">}）;</p><p class="listTitle1 biaoti8">10.6.2 按时间逆序排列的Thread列表（orderedthreads流）</p><p class="content">threads流给了我们一个映射，作为会话列表的一个“索引”。但是我们想让会话视图根据最新消息的时间来排序，如图10-8所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17158/350/2642822317/125328/3716a578/5b03d540N4279cc2a.jpg" class="enlarge" alt="" href="./image/a-77.jpg" /></p><p class="descrip"><b>图10-8　按时间逆序排列的会话</b></p><p class="content">创建一个新的流，它返回一个按最新Message时间排序的Thread数组。</p><p class="content">我们首先定义orderedThreads并把它作为一个实例属性。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">　// `orderedThreads` contains a newest-first chronological list of threads</p><p class="daima">　orderedThreads：Observable&lt;Thread[]&gt;;</p><p class="content">接下来，在constructor中通过订阅threads流并按最新消息时间排序定义orderedThreads。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">　　this.orderedThreads = this.threads</p><p class="daima">　　　.map（（threadGroups：{ [key：string]：Thread }）=&gt; {</p><p class="daima">　　　　let threads：Thread[] = _.values（threadGroups）;</p><p class="daima">　　　　return _.sortBy（threads,（t：Thread）=&gt; t.lastMessage.sentAt）.reverse（）;</p><p class="daima">　　　}）;</p><p class="listTitle1 biaoti8">10.6.3 当前已选的Thread（currentThread流）</p><p class="content">我们的应用需要知道当前已选的Thread是哪个。这让我们知道：</p><p class="content">（1）哪个会话应该在消息窗口显示；</p><p class="content">（2）会话列表中的哪个会话应该被标记为当前会话（如图10-9所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19114/104/2562713856/64704/cb559d0/5b03d540N3931c8e8.jpg" class="enlarge" alt="" href="./image/a-78.jpg" /></p><p class="descrip"><b>图10-9　使用·符号表示当前会话</b></p><p class="content">创建一个BehaviorSubject并把它保存为currentThread流。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">　// `currentThread` contains the currently selected thread</p><p class="daima">　currentThread：Subject&lt;Thread&gt; =</p><p class="daima">　　new BehaviorSubject&lt;Thread&gt;（new Thread（））;</p><p class="content">注意，这里分配了一个空的Thread作为默认值。我们不再需要对currentThread进行更多配置了。</p><p class="content">●<b>设置当前会话</b></p><p class="content">要设置当前会话，currentThread流可以选择下面的其中一个方法：</p><p class="content">（1）直接通过next方法提交新会话；</p><p class="content">（2）添加一个辅助函数提交新会话。</p><p class="content">我们定义一个辅助函数setCurrentThread，可以使用它来设置下一个会话。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">　setCurrentThread（newThread：Thread）：void {</p><p class="daima">　　this.currentThread.next（newThread）;</p><p class="daima">　}</p><p class="content">●<b>标记当前会话为已读</b></p><p class="content">我们想要记录未读消息数量。如果切换到一个新Thread，要把那个Thread中的所有Message都标记为已读。我们拥有做到这些所需的工具：</p><p class="content">（1）messagesService.makeThreadAsRead接收一个Thread，然后把这个Thread中的所有Message都标记为已读；</p><p class="content">（2）currentThread流发出单个的Thread，它代表当前Thread。</p><p class="content">要做的就是把它们关联起来。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">　this.currentThread.subscribe（this.messagesService.markThreadAsRead）;</p><p class="listTitle1 biaoti8">10.6.4 当前已选Thread的Message列表（currentThreadMessages流）</p><p class="content">现在有了当前已选会话，需要确保显示这个Thread的Message列表（如图10-10所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20320/9/219748720/98171/c838bdf2/5b03d541Ncc08633d.jpg" class="enlarge" alt="" href="./image/a-79.jpg" /></p><p class="descrip"><b>图10-10　当前消息列表来自反转机器人（Reverse Bot）</b></p><p class="content">它的实现比表面上看起来要复杂一些。我们这样来实现它：</p><p class="daima">var theCurrentThread：Thread;</p><p class="daima">this.currentThread.subscribe（（thread：Thread）=&gt; {</p><p class="daima">　theCurrentThread = thread;</p><p class="daima">}）</p><p class="daima">this.currentThreadMessages.map（</p><p class="daima">　（mesages：Message[]）=&gt; {</p><p class="daima">　　return _.filter（messages,</p><p class="daima">　　　（message：Message）=&gt; {</p><p class="daima">　　　　return message.thread.id == theCurrentThread.id;</p><p class="daima">　　　}）</p><p class="daima">　}）</p><p class="content">这种方法有什么问题？如果currentThread改变了，而currentThreadMessages完全不知道，那么currentThreadMessages就是一个过时了的消息列表！</p><p class="content">如果颠倒一下呢？在一个变量中保存当前消息列表，然后订阅currentThread流的变化，会发生什么呢？还是会有同样的问题，只是这次我们知道会话变化，但是不知道有新消息进来。</p><p class="content">如何解决这个问题呢？</p><p class="content">原来，RxJS有一组操作符用来<b>合并多个流</b>。在这个例子中，我们想说的是“如果currentThread和messagesService.messages中的<b>任何</b>一个改变了，那么就要发出一些东西”。为此，我们使用combineLatest操作符<sup><a class="mz-footnote-link" href="#footnote14"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">　　this.currentThreadMessages = this.currentThread</p><p class="daima">　　　.combineLatest（messagesService.messages,</p><p class="daima">　　　　　　　　　　（currentThread：Thread, messages：Message[]）=&gt; {</p><p class="content">当合并两个流时，会有一个先到达，不能保证在两个流上都有值，所以需要检查以确保有我们所需要的；否则就会返回一个空列表。</p><p class="content">现在有了当前会话和消息列表，就可以过滤出我们想要的消息了。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">　　this.currentThreadMessages = this.currentThread</p><p class="daima">　　　.combineLatest（messagesService.messages,</p><p class="daima">　　　　　　　　　　（currentThread：Thread, messages：Message[]）=&gt; {</p><p class="daima">　　　　if（currentThread &amp;&amp; messages.length &gt; 0）{</p><p class="daima">　　　　　return _.chain（messages）</p><p class="daima">　　　　　　.filter（（message：Message）=&gt;</p><p class="daima">　　　　　　　　　　（message.thread.id === currentThread.id））</p><p class="content">还有一个细节：既然我们已经找到了当前会话的消息，把这些消息标记为已读就是很方便的。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">　　　　　return _.chain（messages）</p><p class="daima">　　　　　　.filter（（message：Message）=&gt;</p><p class="daima">　　　　　　　　　　（message.thread.id === currentThread.id））</p><p class="daima">　　　　　　.map（（message：Message）=&gt; {</p><p class="daima">　　　　　　　message.isRead = true;</p><p class="daima">　　　　　　　return message; }）</p><p class="daima">　　　　　　.value（）;</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17728/48/2715397358/11728/16045511/5b03d541N9720f866.jpg" class="inline1" alt="" href="./image/a-4.jpg" />　关于是否应该在这里把消息标记为已读是有争议的。标记为已读的最大缺点就是我们更改了对象本身，而本质上这是一个“只读”会话。也就是说，这是一个有副作用的读操作，一般不应该使用。尽管如此，本应用中的currentThreadMessages流只作用于currentThread流，而currentThread流应始终把它的消息标记为已读。不过，我通常不推荐“有副作用的读操作”模式。</p><p class="content">把所有代码整合起来，currentThreadMessages看起来是这样的。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">　　this.currentThreadMessages = this.currentThread</p><p class="daima">　　　.combineLatest（messagesService.messages,</p><p class="daima">　　　　　　　　　　（currentThread：Thread, messages：Message[]）=&gt; {</p><p class="daima">　　　　if（currentThread &amp;&amp; messages.length &gt; 0）{</p><p class="daima">　　　　　return _.chain（messages）</p><p class="daima">　　　　　　.filter（（message：Message）=&gt;</p><p class="daima">　　　　　　　　　　（message.thread.id === currentThread.id））</p><p class="daima">　　　　　　.map（（message：Message）=&gt; {</p><p class="daima">　　　　　　　message.isRead = true;</p><p class="daima">　　　　　　　return message; }）</p><p class="daima">　　　　　　.value（）;</p><p class="daima">　　　　} else {</p><p class="daima">　　　　　return [];</p><p class="daima">　　　　}</p><p class="daima">　　　}）;</p><p class="listTitle1 biaoti8">10.6.5 完整的ThreadsService</p><p class="content">ThreadService完整代码如下所示。</p><p class="reference"><b>code/rxjs/chat/app/ts/services/ThreadsService.ts</b></p><p class="daima">import {Injectable} from '@angular/core';</p><p class="daima">import {Subject, BehaviorSubject, Observable} from 'rxjs';</p><p class="daima">import {Thread, Message} from '../models';</p><p class="daima">import {MessagesService} from './MessagesService';</p><p class="daima">import * as _ from 'underscore';</p><p class="daima">@Injectable（）</p><p class="daima">export class ThreadsService {</p><p class="daima">　// `threads` is a observable that contains the most up to date list of threads</p><p class="daima">　threads：Observable&lt;{ [key：string]：Thread }&gt;;</p><p class="daima">　// `orderedThreads` contains a newest-first chronological list of threads</p><p class="daima">　orderedThreads：Observable&lt;Thread[]&gt;;</p><p class="daima">　// `currentThread` contains the currently selected thread</p><p class="daima">　currentThread：Subject&lt;Thread&gt; =</p><p class="daima">　　new BehaviorSubject&lt;Thread&gt;（new Thread（））;</p><p class="daima">　// `currentThreadMessages` contains the set of messages for the currently</p><p class="daima">　// selected thread</p><p class="daima">　currentThreadMessages：Observable&lt;Message[]&gt;;</p><p class="daima">　constructor（private messagesService：MessagesService）{</p><p class="daima">　　this.threads = messagesService.messages</p><p class="daima">　　　.map（（messages：Message[]）=&gt; {</p><p class="daima">　　　　let threads：{[key：string]：Thread} = {};</p><p class="daima">　　　　// Store the message's thread in our accumulator `threads`</p><p class="daima">　　　　messages.map（（message：Message）=&gt; {</p><p class="daima">　　　　　threads[message.thread.id] = threads[message.thread.id] ||</p><p class="daima">　　　　　　message.thread;</p><p class="daima">　　　　　// Cache the most recent message for each thread</p><p class="daima">　　　　　let messagesThread：Thread = threads[message.thread.id];</p><p class="daima">　　　　　if（！messagesThread.lastMessage ||</p><p class="daima">　　　　　　　messagesThread.lastMessage.sentAt &lt; message.sentAt）{</p><p class="daima">　　　　　　messagesThread.lastMessage = message;</p><p class="daima">　　　　　}</p><p class="daima">　　　　}）;</p><p class="daima">　　　　return threads;</p><p class="daima">　　　}）;</p><p class="daima">　　this.orderedThreads = this.threads</p><p class="daima">　　　.map（（threadGroups：{ [key：string]：Thread }）=&gt; {</p><p class="daima">　　　　let threads：Thread[] = _.values（threadGroups）;</p><p class="daima">　　　　return _.sortBy（threads,（t：Thread）=&gt; t.lastMessage.sentAt）.reverse（）;</p><p class="daima">　　　}）;</p><p class="daima">　　this.currentThreadMessages = this.currentThread</p><p class="daima">　　　.combineLatest（messagesService.messages,</p><p class="daima">　　　　　　　　　　（currentThread：Thread, messages：Message[]）=&gt; {</p><p class="daima">　　　　if（currentThread &amp;&amp; messages.length &gt; 0）{</p><p class="daima">　　　　　return _.chain（messages）</p><p class="daima">　　　　　　.filter（（message：Message）=&gt;</p><p class="daima">　　　　　　　　　　（message.thread.id === currentThread.id））</p><p class="daima">　　　　　　.map（（message：Message）=&gt; {</p><p class="daima">　　　　　　　message.isRead = true;</p><p class="daima">　　　　　　　return message; }）</p><p class="daima">　　　　　　.value（）;</p><p class="daima">　　　　} else {</p><p class="daima">　　　　　return [];</p><p class="daima">　　　　}</p><p class="daima">　　　}）;</p><p class="daima">　　this.currentThread.subscribe（this.messagesService.markThreadAsRead）;</p><p class="daima">　}</p><p class="daima">　setCurrentThread（newThread：Thread）：void {</p><p class="daima">　　this.currentThread.next（newThread）;</p><p class="daima">　}</p><p class="daima">}</p><p class="daima">export var threadsServiceInjectables：Array&lt;any&gt; = [</p><p class="daima">　ThreadsService</p><p class="daima">];</p><p class="sectionTitle biaoti3"><a id="sec007"></a>10.7 总结</p><p class="content">数据模型和服务已经完成！现在，我们拥有了连接到视图组件所需要的一切！在下章中，我们将构建三个重要的组件，用来渲染页面并和本章所创建的流进行交互。</p><ol class="mz-footnote"><li id="footnote1">http：//underscorejs.org/</li><li id="footnote2">https：//www.cygwin.com/</li><li id="footnote3">注意，@Injectable注解表示该类可以让Angular把其他服务注入进来，也就是说以该类作为目标。因此 在创建服务时，@Injectable注解并不是必需的，但官方的风格指南明确建议我们加上它。——译者注</li><li id="footnote4">https：//github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/subject.md</li><li id="footnote5">https：//github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md</li><li id="footnote6">https：//github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observer.md</li><li id="footnote7">https：//github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md</li><li id="footnote8">https：//github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/scan.md</li><li id="footnote9">https：//github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/publish.md</li><li id="footnote10">https：//github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/replay.md</li><li id="footnote11">https：//github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/refcount.md</li><li id="footnote12">https：//github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/select.md</li><li id="footnote13">https：//github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/subscribe.md</li><li id="footnote14">https：//github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/combinelatestproto.md</li></ol></body></html>