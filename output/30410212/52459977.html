<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><link rel="stylesheet" type="text/css" href="http://storage.360buyimg.com/ebooks/9fd8bb77eb40456b746aaae41785499a_new_.css" /><title>第8章 依赖注入</title></head><body><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21994/332/208361062/37590/1faae4b1/5b03d540Nf819ff2a.jpg" class="fullscreen" alt="" href="./image/Figure-08.jpg" /></p><p class="content">随着程序规模的增长，我们常常遇到应用模块需要相互通信的情况。当模块A需要模块B才能运行时，我们就说B是A的<b>依赖</b>。</p><p class="content">获取依赖的最常见方式之一就是直接导入（import）一个文件。例如，在某个假想模块中，我们可以这么做：</p><p class="daima">// in A.ts</p><p class="daima">import {B} from 'B'; // a dependency！</p><p class="daima">B.foo（）; // using B</p><p class="content">通常，只要导入其他代码就足够了；但是在某些情况下，要用到更加精巧的方式提供依赖。</p><p class="content">●如果我们想在测试时把B的实现替换为MockB，该怎么办呢？</p><p class="content">●如果我们想在整个应用中共享B类的<b>单一实例</b>（比如单例模式），该怎么办呢？</p><p class="content">●如果我们想在每次用到B类时都创建一个<b>新实例</b>（比如工厂模式），该怎么办呢？</p><p class="content">依赖注入可以解决这些问题。</p><p class="content">依赖注入（dependency injection，DI）是这样一个系统：它让程序中的某部分可以访问其他部分，而且我们可以配置它们的访问方式。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="inline1" alt="" href="./image/a-9.jpg" />　可以把注入器看作new操作符的替代品。</p><p class="content">依赖注入这个术语既被用来描述一种设计模式（可用于很多种框架），也被用来指代Angular内置的DI实现库。</p><p class="content">使用依赖注入技术的主要优点是客户代码不必知晓如何创建依赖，它们只需要与那些依赖<b>交互</b>就可以了。</p><p class="sectionTitle biaoti3"><a id="sec001"></a>8.1 注入示例：PriceService</p><p class="content">假设我们有一个Product类。每个产品都有一个基准价格。我们要靠一个服务来计算该产品的含税价，它需要如下输入：</p><p class="content">●产品的<b>基准价格</b></p><p class="content">●销售时所在的<b>州</b><sup><a class="mz-footnote-link" href="#footnote1"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup></p><p class="content">下面是不使用依赖注入时的代码：</p><p class="daima">class Product {</p><p class="daima">　constructor（basePrice：number）{</p><p class="daima">　　this.service = new PriceService（）;</p><p class="daima">　　this.basePrice = basePrice;</p><p class="daima">　}</p><p class="daima">　price（state：string）{</p><p class="daima">　　return this.service.calculate（this.basePrice, state）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">想象一下，我们要为此Product类写一个测试。假设这个PriceService类要使用数据库查询来获得产品在指定州的税率。如果这样写测试的话：</p><p class="daima">let product;</p><p class="daima">beforeEach（（）=&gt; {</p><p class="daima">　product = new Product（11）;</p><p class="daima">}）;</p><p class="daima">describe（'price',（）=&gt; {</p><p class="daima">　it（'is calculated based on the basePrice and the state',（）=&gt; {</p><p class="daima">　　expect（product.price（'FL'））.toBe（11.66）;</p><p class="daima">　}）;</p><p class="daima">}）</p><p class="content">尽管这个测试可以工作，但是暴露了一些缺陷。为了让这个测试成功运行，需要满足两个前提条件：</p><p class="content">（1）数据库必须保持运行；</p><p class="content">（2）佛罗里达州（代号FL）的税率必须始终像我们期望的一样。</p><p class="content">根本原因在于：Product类和PriceService类（而它又依赖于数据库）之间突兀的强烈依赖会让我们的测试变得更脆弱。</p><p class="content">如果稍微改写一下Product类呢？</p><p class="daima">class Product {</p><p class="daima">　constructor（service：PriceService, basePrice：number）{</p><p class="daima">　　this.service = service;</p><p class="daima">　　this.basePrice = basePrice;</p><p class="daima">　}</p><p class="daima">　price（state：string）{</p><p class="daima">　　return this.service.calculate（this.basePrice, state）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">现在，当要创建Product的实例时，客户方代码可以决定把PriceService的哪个具体实现传给这个新实例了。</p><p class="content">这样，只要创建一个mock版本的PriceService类就可以大幅简化测试了：</p><p class="daima">class MockPriceService {</p><p class="daima">　calculate（basePrice：number, state：string）{</p><p class="daima">　　if（state === 'FL'）{</p><p class="daima">　　　return basePrice * 1.06;</p><p class="daima">　　}</p><p class="daima">　　return basePrice;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">基于这个小改动，我们就可以微调测试，移除它对数据库的依赖：</p><p class="daima">let product;</p><p class="daima">beforeEach（（）=&gt; {</p><p class="daima">　const service = new MockPriceService（）;</p><p class="daima">　product = new Product（service, 11）;</p><p class="daima">}）;</p><p class="daima">describe（'price',（）=&gt; {</p><p class="daima">　it（'is calculated based on the basePrice and the state',（）=&gt; {</p><p class="daima">　　expect（product.price（'FL'））.toBe（11.66）;</p><p class="daima">　}）;</p><p class="daima">}）</p><p class="content">另一个好处是我们现在能更加确信自己正在<b>不受外界影响</b>地测试Product类。也就是说，我们能确保该类正在使用一个行为上可预测的依赖。</p><p class="sectionTitle biaoti3"><a id="sec002"></a>8.2 “别打给我们……”</p><p class="content">这种注入依赖的技术是基于一项被称为<b>控制反转</b>的设计原则。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　控制反转（inversion of control，IoC）原则的非正式称谓是“好莱坞法则”。它来自好莱坞的一句常用语“别打给我们，我们会打给你（don't call us, we'll call you）”。</p><p class="content">多年以来，它在与全应用语境相关的部件（指组件、服务、管道等Angular代码块）中用得非常普遍，也常被用来解决依赖的创建和设置问题。这一点在例子中体现得很清楚：Product类不得不了解PriceService类。</p><p class="content">问题在于，一旦部件变得过于关心它的依赖，部件本身就会变得脆弱而难以修改。如果我们修改了一个部件，这项修改就会向上扩散到所有依赖它的部件中。它会影响到程序中很多不同的区域，甚至可能超出程序的边界。换句话说，这些部件之间产生了<b>紧耦合</b>。</p><p class="content">使用依赖注入，我们就可以得到一个更加<b>松耦合</b>的架构。这时，当修改单一部件时，对程序中其他区域的影响就小多了。同时，只要这些部件之间的接口没有变，我们甚至可以在不修改其他部件中实现代码的情况下集体更换它们。</p><p class="content">Angular从AngularJS中继承来的一项伟大特性就是它们都使用这种控制反转模式。Angular使用自带的<b>依赖注入</b>机制来解析这些依赖。</p><p class="content">在传统方式下，如果部件A需要依赖部件B，那就意味着A要在内部创建一个B的实例，也就是A依赖于B（如图8-1所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17062/311/2673272986/19908/d4fc9c58/5b03d541N153aa327.jpg" class="enlarge" alt="" href="./image/a-61.jpg" /></p><p class="descrip"><b>图8-1　不用依赖注入框架时</b></p><p class="content">Angular利用依赖注入机制改变了这一点。在这种机制下，如果需要在部件A中用到部件B，我们就应该期待B<b>被传给</b>A（如图8-2所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t16768/231/2618672929/28514/1234ecd0/5b03d541Ne513190d.jpg" class="enlarge" alt="" href="./image/a-62.jpg" /></p><p class="descrip"><b>图8-2　使用依赖注入框架时</b></p><p class="content">在传统场景下，这带来了很多优点。一个优点就是：如果我们准备单独测试A，可以创建一个mock版本的B，并把它注入到A中。</p><p class="content">在本书的前面，我们已经多次用过服务和依赖注入了，比如在第7章创建音乐应用时。为了与Spotify API交互，我们创建了SpotifyService。它被注入到了很多部件中，比如下面这个来自AlbumComponent的片段。</p><p class="reference"><b>code/routes/music/app/ts/components/AlbumComponent.ts</b></p><p class="daima">export class AlbumComponent implements OnInit {</p><p class="daima">　id：string;</p><p class="daima">　album：Object;</p><p class="daima">　constructor（private route：ActivatedRoute,</p><p class="daima">　　　　　　　private spotify：SpotifyService, // &lt;—— injected</p><p class="daima">　　　　　　　private location：Location）{</p><p class="daima">　　route.params.subscribe（params =&gt; { this.id = params['id']; }）;</p><p class="daima">　}</p><p class="content">现在，我们就来学习如何创建自己的服务以及能用哪些形式注入它们吧。</p><p class="sectionTitle biaoti3"><a id="sec003"></a>8.3 依赖注入的部件</p><p class="content">要注册一个依赖，我们就得找到一些东西作为那个依赖的标识。这个标识被称为依赖的<b>令牌</b>（token）。比如，如果我们想要注册某个API的URL，就可以用字符串API_URL作为令牌。同样，如果我们要注册一个类，就可以使用这个类本身作为它的令牌，就像我们即将看到的。</p><p class="content">在Angular中，依赖注入包括如下三部分。</p><p class="content">●<b>提供者</b>（也常被称为绑定）负责把一个<b>令牌</b>（可能是字符串也可能是类）映射到一个依赖的列表。它告诉Angular该如何根据指定的令牌创建对象。</p><p class="content">●<b>注入器</b>负责持有一组绑定；当外界要求创建对象时，解析这些依赖并注入它们。</p><p class="content">●<b>依赖</b>就是将被用于注入的对象。</p><p class="content">我们可以借助图8-3来理解它们各自扮演的角色。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20983/13/205441505/24733/a569c541/5b03d540N9270d94c.jpg" class="enlarge" alt="" href="./image/a-63.jpg" /></p><p class="descrip"><b>图8-3　依赖注入</b></p><p class="content">与依赖注入打交道时，有很多不同的选项，我们来分别看看它们的用途。</p><p class="content">最常见的情况是提供一个服务或值，它将在整个应用中保持一致。在我们的应用中，99％的场景可能都属于这种情况。</p><p class="content">既然这就是我们要做的一切，那就在下一节示范怎样写一个基本的服务吧，因为它正是我们在开发大多数应用的大部分时间里所需要的。</p><p class="content">说的够多了，开始编码！</p><p class="sectionTitle biaoti3"><a id="sec004"></a>8.4 尝试注入器</p><p class="content">就像前面提到过的，Angular会在幕后帮我们设置好依赖注入。不过，在我们和注解打交道并且把依赖注入集成到部件中之前，自己先尝试使用一下注入器。</p><p class="content">先来创建一个直接返回字符串的示例服务。</p><p class="reference"><b>code/dependency_injection/injector/app/ts/app.ts</b></p><p class="daima">/*</p><p class="daima">* The injectable service</p><p class="daima">*/</p><p class="daima">class MyService {</p><p class="daima">　getValue（）：string {</p><p class="daima">　　return 'a value';</p><p class="daima">　}</p><p class="daima">}</p><p class="content">接下来，创建该应用的组件。</p><p class="reference"><b>code/dependency_injection/injector/app/ts/app.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'di-sample-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;button（click）="invokeService（）"&gt;Get Value&lt;/button&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class DiSampleApp {</p><p class="daima">　myService：MyService;</p><p class="daima">　constructor（）{</p><p class="daima">　　let injector：any = ReflectiveInjector.resolveAndCreate（[MyService]）;</p><p class="daima">　　this.myService = injector.get（MyService）;</p><p class="daima">　　console.log（'Same instance?', this.myService === injector.get（MyService））;</p><p class="daima">　}</p><p class="daima">　invokeService（）：void {</p><p class="daima">　　console.log（'MyService returned', this.myService.getValue（））;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">下面对这个过程进行分解。我们首先声明了DiSampleApp组件，它会渲染出一个按钮。当点击此按钮时就会调用invokeService方法。</p><p class="content">仔细看该组件的构造函数就会发现，我们正在使用一个来自ReflectiveInjector的静态方法，名为resolveAndCreate。该方法负责创建一个新的注入器。我们传给它的参数是一个数组，其中是这个新注入器需要<b>知道</b>的<b>可供注入物</b>。在这个例子中，它知道MyService这个可注入物就够了。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　ReflectiveInjector是Injector的一个具体实现，它使用反射（reflection）机制来找出正确的参数类型。虽然也有一些别的注入器，不过在大多数应用中，ReflectiveInjector应该是最常用的“常规”注入器了。</p><p class="content">需要注意的一点是：它会注入该类的一个<b>单例</b>对象。</p><p class="content">这可以从构造函数中的最后两行得到验证。首先要求刚创建的注入器给我们一个MyService类的实例，然后把它存入组件的myService字段。之后，在console.log函数中要求注入器再次给我们一个MyService的实例，并输出它与myService字段进行比较的结果：</p><p class="daima">console.log（'Same instance?', this.myService === injector.get（MyService））;</p><p class="content">我们可以在控制台中确认这两个实例确实是指向同一个对象的引用：</p><p class="daima">Same instance? true</p><p class="content">注意，由于使用了自己的注入器，我们并不需要在启动时把MyService加入NgModule的providers列表中。</p><p class="reference"><b>code/dependency_injection/injector/app/ts/app.ts</b></p><p class="daima">@NgModule（{</p><p class="daima">　declarations：[ DiSampleApp ],</p><p class="daima">　imports：[ BrowserModule ],</p><p class="daima">　bootstrap：[ DiSampleApp ]</p><p class="daima">}）</p><p class="daima">class DiSampleAppModule {}</p><p class="daima">platformBrowserDynamic（）.bootstrapModule（DiSampleAppModule）;</p><p class="sectionTitle biaoti3"><a id="sec005"></a>8.5 用NgModule提供依赖</p><p class="content">不过，在正常情况下，还是得告诉NgModule要注入哪些<b>提供者</b>。</p><p class="content">比如，我们想让该MyService单例对象在整个应用中都能被注入。</p><p class="content">为了能够注入，必须把<b>它们添加到NgModule的providers属性中</b>。示例代码如下：</p><p class="daima">@NgModule（{</p><p class="daima">　declarations：[</p><p class="daima">　　MyAppComponent,</p><p class="daima">　　// other components ……</p><p class="daima">　],</p><p class="daima">　providers：[ MyService ]　 // &lt;—— here</p><p class="daima">}）</p><p class="daima">class MyAppModule {}</p><p class="content">这样，MyAppComponent就能把MyService注入构造函数中了：</p><p class="daima">export class MyAppComponent {</p><p class="daima">　constructor（private myService：MyService /* &lt;—— injected */）{</p><p class="daima">　　// do something with myService here</p><p class="daima">　}</p><p class="daima">　// ……</p><p class="daima">}</p><p class="content">当我们把这个类本身放进providers中时：</p><p class="daima">　providers：[ MyService ]</p><p class="content">就是在告诉Angular：当MyService被注入时，我们希望提供MyService的一个单例实例。因为这种需求非常普遍，所以这个类实际上是一种缩写形式，其等价的完整配置方式是：</p><p class="daima">　 providers：[</p><p class="daima">　　 { provide：MyComponent, useClass：MyComponent }</p><p class="daima">　 ]</p><p class="content">除了创建类的实例之外，还有很多其他的方式可以进行注入，接下来就来逐个查看。</p><p class="sectionTitle biaoti3"><a id="sec006"></a>8.6 提供者</p><p class="content">Angular的依赖注入体系有很多精巧之处，其中之一是我们有很多种方式来配置注入过程。比如可以：</p><p class="content">●注入一个类的（单例）实例；</p><p class="content">●调用任意函数，并注入该函数的返回结果；</p><p class="content">●注入一个值；</p><p class="content">●创建一个别名。</p><p class="content">下面分别用例子进行解释。</p><p class="listTitle1 biaoti8">8.6.1 使用类</p><p class="content">注入类的单例实例大概是最常见的注入类型了。</p><p class="content">配置方法如下：</p><p class="daima">　　{ provide：MyComponent, useClass：MyComponent }</p><p class="content">需要注意的是：provide配置方法接收两个键（key）。第一个provide键是我们用作这个可注入对象标识的<b>令牌</b>，第二个useClass键用来指出注入什么以及如何注入。</p><p class="content">在这里，我们把MyComponent类映射到了MyComponent令牌。在这个例子中，类名和令牌名是匹配的。这是最常见的情况，但是必须知道：令牌和被注入物<b>并不一定同名</b>。</p><p class="content">如前所见，该例子中的注入器将会在幕后创建一个<b>单例对象</b>，并在每次注入它时返回同一个实例。</p><p class="content">当然，首次注入时它尚未实例化，需要创建一个MyComponent实例。此时，依赖注入系统就会调用该类的<b>构造函数</b>。</p><p class="content">如果服务的<b>构造函数</b>需要一些参数，会怎么样呢？假设我们有这样一个服务。</p><p class="reference"><b>code/dependency_injection/misc/app/ts/app.ts</b></p><p class="daima">class ParamService {</p><p class="daima">　constructor（private phrase：string）{</p><p class="daima">　　console.log（'ParamService is being created with phrase', phrase）;</p><p class="daima">　}</p><p class="daima">　getValue（）：string {</p><p class="daima">　　return this.phrase;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">注意，它的构造函数需要传入一个短语作为参数。如果我们使用标准注入机制，就会在浏览器中看到一个错误，如图8-4所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t16624/48/2620307849/28384/8d7ca12f/5b03d541Nd7b42731.jpg" class="enlarge" alt="" href="./image/a-64.jpg" /></p><p class="descrip"><b>图8-4　注入错误</b></p><p class="content">这是因为我们没有为注入器提供足够的信息来构造这个类。要解决这个问题，就得告诉注入器在创建该服务的实例时要使用哪个参数。</p><p class="content">如果想在创建服务时传入一个参数，就要改用工厂了。</p><p class="listTitle1 biaoti8">8.6.2 使用工厂</p><p class="content">如果要使用工厂进行注入，就需要写一个返回<b>任意对象</b>的函数。</p><p class="daima">{</p><p class="daima">　provide：MyComponent,</p><p class="daima">　useFactory：（）=&gt; {</p><p class="daima">　　if（loggedIn）{</p><p class="daima">　　　return new MyLoggedComponent（）;</p><p class="daima">　　}</p><p class="daima">　　return new MyComponent（）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">注意，在这个例子中，我们注入时用的令牌是MyComponent，但是它会检查（作用域外面的）loggedIn变量。如果loggedIn为真，则注入器会返回一个MyLoggedComponent的实例；否则返回MyComponent的实例。</p><p class="content">工厂还可以拥有自己的依赖：</p><p class="daima">{</p><p class="daima">　provide：MyComponent,</p><p class="daima">　useFactory：（user）=&gt; {</p><p class="daima">　　if（user.loggedIn（））{</p><p class="daima">　　　return new MyLoggedComponent（user）;</p><p class="daima">　　}</p><p class="daima">　　return new MyComponent（）;</p><p class="daima">　},</p><p class="daima">　deps：[ User ]</p><p class="daima">}</p><p class="content">因此，如果要使用前面的ParamService，我们就得把它用useFactory包裹起来。</p><p class="reference"><b>code/dependency_injection/misc/app/ts/app.ts</b></p><p class="daima">@NgModule（{</p><p class="daima">　declarations：[ DiSampleApp ],</p><p class="daima">　imports：[ BrowserModule ],</p><p class="daima">　bootstrap：[ DiSampleApp ],</p><p class="daima">　providers：[</p><p class="daima">　　SimpleService,</p><p class="daima">　　{</p><p class="daima">　　　provide：ParamService,</p><p class="daima">　　　useFactory：（）：ParamService =&gt; new ParamService（'YOLO'）</p><p class="daima">　　}</p><p class="daima">　]</p><p class="daima">}）</p><p class="daima">class DiSampleAppAppModule {}</p><p class="daima">platformBrowserDynamic（）.bootstrapModule（DiSampleAppAppModule）</p><p class="daima">　.catch（（err：any）=&gt; console.error（err））;</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="enlarge" alt="" href="./image/a-9.jpg" /></p><p class="content">我们可以把SimpleService直接放在providers列表中，这是因为SimpleService并不需要任何参数。它会被翻译成：</p><p class="daima">{ provide：SimpleService, useClass：SimpleService }</p><p class="content">可以说，工厂是创建可注入对象的最强方式，因为我们可以在工厂函数中“为所欲为”。</p><p class="listTitle1 biaoti8">8.6.3 使用值</p><p class="content">当我们需要一个常量，而它可能会根据应用的其他部分甚至环境进行重定义时（比如测试环境或生产环境），这种方式非常有用。</p><p class="daima">　　{ provide：'API_URL', useValue：'http：//my.api.com/v1' }</p><p class="content">在8.9节中，我们会提供一个更完善的例子。</p><p class="listTitle1 biaoti8">8.6.4 使用别名</p><p class="content">我们还可以制造一个别名来引用以前注册过的令牌，比如：</p><p class="daima">　　{ provide：NewComponent, useClass：MyComponent }</p><p class="sectionTitle biaoti3"><a id="sec007"></a>8.7 应用中的依赖注入</p><p class="content">当我们开发应用时，需要经过三步才能进行依赖注入：</p><p class="content">（1）创建该服务的类；</p><p class="content">（2）在准备接受注入的部件上声明该依赖；</p><p class="content">（3）配置要注入的依赖（比如在我们的NgModule中通过Angular注册要注入的依赖）。</p><p class="content">我们要做的第一件事是创建该服务的类，该类会暴露出我们想要用到的那些行为。它也被称为<b>可注入对象</b>，因为它就是我们的部件将通过依赖注入接收到的东西。</p><p class="content">下面示范如何创建服务。</p><p class="reference"><b>code/dependency_injection/simple/app/ts/services/ApiService.ts</b></p><p class="daima">export class ApiService {</p><p class="daima">　get（）：void {</p><p class="daima">　　console.log（'Getting resource……'）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">现在已经有了要注入的东西，接下来要声明当Angular创建部件时，我们希望接收哪些依赖。</p><p class="content">我们以前直接使用Injector类，但在写部件时，我们通常会使用Angular提供的两种快捷方式。</p><p class="content">第一种是在部件的构造函数中声明这些可注入对象。这也是最典型的用法。</p><p class="content">要做到这一点，必须先导入该服务。</p><p class="reference"><b>code/dependency_injection/simple/app/ts/app.ts</b></p><p class="daima">/*</p><p class="daima">* Services</p><p class="daima">*/</p><p class="daima">import { ApiService } from 'services/ApiService';</p><p class="content">然后在构造函数中声明它。</p><p class="reference"><b>code/dependency_injection/simple/app/ts/app.ts</b></p><p class="daima">class DiSampleApp {</p><p class="daima">　constructor（private apiService：ApiService）{</p><p class="daima">　}</p><p class="content">当我们在组件的构造函数中声明依赖时，Angular会通过<b>反射机制</b>来找出要注入的类。也就是说，Angular会发现我们正在构造函数中查找一个ApiService类型的对象，并检查依赖注入系统以找出合适的可注入对象。</p><p class="content">有时我们需要给Angular更多的提示，来告诉它我们到底要注入什么。在这种情况下，我们要使用第二种方式，即@Inject注解。</p><p class="daima">class DiSampleApp {</p><p class="daima">　private apiService：ApiService;</p><p class="daima">　constructor（@Inject（ApiService）apiService）{</p><p class="daima">　　this.apiService = apiService;</p><p class="daima">　}</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　如果我们要用这种等价形式，可以打开app.long.ts文件，把它的内容复制到app.ts中。</p><p class="content">使用依赖注入的最后一步是把部件想要的东西与可注入对象关联起来。换句话说，我们告诉Angular：当部件声明了它的依赖时，应该注入<b>什么</b>。</p><p class="daima">　　{ provide：ApiService, useClass：ApiService }</p><p class="content">在这个例子中，我们使用令牌ApiService暴露出了ApiService类的单例对象。</p><p class="content">最后，我们把这个ApiService添加到NgModule的providers属性中。</p><p class="reference"><b>code/dependency_injection/simple/app/ts/app.ts</b></p><p class="daima">@NgModule（{</p><p class="daima">　declarations：[ DiSampleApp ],</p><p class="daima">　imports：[ BrowserModule ],</p><p class="daima">　bootstrap：[ DiSampleApp ],</p><p class="daima">　providers：[ ApiService ] // &lt;—— here</p><p class="daima">}）</p><p class="daima">class DiSampleAppAppModule {}</p><p class="daima">platformBrowserDynamic（）.bootstrapModule（DiSampleAppAppModule）</p><p class="daima">　.catch（（err：any）=&gt; console.error（err））;</p><p class="sectionTitle biaoti3"><a id="sec008"></a>8.8 使用注入器</p><p class="content">我们已经和注入器打过交道了，现在要更进一步，看看什么时候需要显式地使用它们。</p><p class="content">情况之一是，当我们需要控制在什么时机创建依赖的单例对象时。</p><p class="content">为了说明什么时候会出现这种情况，我们来构建另一个应用。除了使用我们以前创建过的ApiService外，它还会用到一个新的服务。</p><p class="content">该服务将用来根据浏览器的窗口大小实例化另外两个服务。如果窗口宽度小于800像素，它就返回一个名叫SmallService的服务实例；否则返回LargeService的实例。</p><p class="content">下面是SmallService的代码。</p><p class="reference"><b>code/dependency_injection/complex/app/ts/services/SmallService.ts</b></p><p class="daima">export class SmallService {</p><p class="daima">　run（）：void {</p><p class="daima">　　console.log（'Small service……'）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">下面是LargeService的代码。</p><p class="reference"><b>code/dependency_injection/complex/app/ts/services/LargeService.ts</b></p><p class="daima">export class LargeService {</p><p class="daima">　run（）：void {</p><p class="daima">　　console.log（'Large service……'）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">然后，我们开始写ViewPortService，它负责在两者之间作出选择。</p><p class="reference"><b>code/dependency_injection/complex/app/ts/services/ViewPortService.ts</b></p><p class="daima">import {LargeService} from './LargeService';</p><p class="daima">import {SmallService} from './SmallService';</p><p class="daima">export class ViewPortService {</p><p class="daima">　determineService（）：any {</p><p class="daima">　　let w：number = Math.max（document.documentElement.clientWidth,</p><p class="daima">　　　　　　　　　　　　　　 window.innerWidth || 0）;</p><p class="daima">　　if（w &lt; 800）{</p><p class="daima">　　　return new SmallService（）;</p><p class="daima">　　}</p><p class="daima">　　return new LargeService（）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">现在，我们创建一个使用这些服务的应用。</p><p class="reference"><b>code/dependency_injection/complex/app/ts/app.ts</b></p><p class="daima">class DiSampleApp {</p><p class="daima">　constructor（private apiService：ApiService,</p><p class="daima">　　　　　　　@Inject（'ApiServiceAlias'）private aliasService：ApiService,</p><p class="daima">　　　　　　　@Inject（'SizeService'）private sizeService：any）{</p><p class="daima">　}</p><p class="content">这里我们仍然用以前的方式获得一个ApiService的实例。不过这次我们通过别名'ApiServiceAlias'获得了同一个实例。最后，我们要获得一个'SizeService'的实例，但它还没有定义过。</p><p class="content">为了理解每个服务都代表什么，我们来看看NgModule。</p><p class="reference"><b>code/dependency_injection/complex/app/ts/app.ts</b></p><p class="daima">@NgModule（{</p><p class="daima">　declarations：[ DiSampleApp ],</p><p class="daima">　imports：[ BrowserModule ],</p><p class="daima">　bootstrap：[ DiSampleApp ],</p><p class="daima">　providers：[</p><p class="daima">　　ApiService,</p><p class="daima">　　ViewPortService,</p><p class="daima">　　{ provide：'ApiServiceAlias', useExisting：ApiService },</p><p class="daima">　　{</p><p class="daima">　　　provide：'SizeService',</p><p class="daima">　　　useFactory：（viewport：any）=&gt; {</p><p class="daima">　　　　return viewport.determineService（）;</p><p class="daima">　　　},</p><p class="daima">　　　deps：[ViewPortService]</p><p class="daima">　　}</p><p class="daima">　]</p><p class="daima">}）</p><p class="daima">class DiSampleAppAppModule {}</p><p class="content">这段代码的意思是，我们首先希望该应用的注入器知道ApiService和ViewPortService这两个可注入对象。</p><p class="content">接下来的声明表示是我们希望通过另一个令牌（字符串ApiServiceAlias）来使用既有服务ApiService。</p><p class="content">然后，我们通过另一个字符串令牌SizeService定义了另一个可注入对象。该工厂通过把ViewPortService列在自己的deps数组中，表明自己需要接收该服务的一个实例。然后，它将调用该实例的determineService（）方法，并根据浏览器的宽度返回一个SmallService或LargeService的实例。</p><p class="content">当点击模板中的一个按钮时，我们会发起三次调用：一次是对ApiService，一次是对别名ApiServiceAlias，最后一次则是对SizeService。</p><p class="reference"><b>code/dependency_injection/complex/app/ts/app.ts</b></p><p class="daima">　invokeApi（）：void {</p><p class="daima">　　this.apiService.get（）;</p><p class="daima">　　this.aliasService.get（）;</p><p class="daima">　　this.sizeService.run（）;</p><p class="daima">　}</p><p class="content">现在，如果我们运行此应用并在小型浏览器窗口中点击Invoke API按钮，结果会如图8-5所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18844/7/2625363603/84973/f3cf2dfa/5b03d541N48cd12f0.jpg" class="enlarge" alt="" href="./image/a-65.jpg" /></p><p class="descrip"><b>图8-5　小型浏览器窗口</b></p><p class="content">我们会获得三条日志：一条来自ApiService，另一条来自别名服务，最后一条来自SmallService。</p><p class="content">如果我们让浏览器窗口更大一点，刷新页面并再次点击按钮，结果会如图8-6所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17503/9/2604765929/57707/2d037ea/5b03d541N910c622c.jpg" class="enlarge" alt="" href="./image/a-66.jpg" /></p><p class="descrip"><b>图8-6　大型浏览器窗口</b></p><p class="content">这样我们就会收到来自LargeService的日志。然而，如果把浏览器窗口调小一点，不刷新页面并再次点击按钮，收到的仍将是来自LargeService的日志，如图8-7所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19237/350/2651244407/100884/31842eca/5b03d540Na6f38aba.jpg" class="enlarge" alt="" href="./image/a-67.jpg" /></p><p class="descrip"><b>图8-7　小型浏览器窗口：调整大小后</b></p><p class="content">这是因为这个工厂函数只会被执行一次，也就是在应用启动时。</p><p class="content">要解决这个问题，我们可以创建自己的注入器，并通过如下方式获得正确的服务实例。</p><p class="reference"><b>code/dependency_injection/complex/app/ts/app.ts</b></p><p class="daima">　useInjectors（）：void {</p><p class="daima">　　let injector：any = ReflectiveInjector.resolveAndCreate（[</p><p class="daima">　　　ViewPortService,</p><p class="daima">　　　{</p><p class="daima">　　　　provide：'OtherSizeService',</p><p class="daima">　　　　useFactory：（viewport：any）=&gt; {</p><p class="daima">　　　　　return viewport.determineService（）;</p><p class="daima">　　　　},</p><p class="daima">　　　　deps：[ViewPortService]</p><p class="daima">　　　}</p><p class="daima">　　]）;</p><p class="daima">　　let sizeService：any = injector.get（'OtherSizeService'）;</p><p class="daima">　　sizeService.run（）;</p><p class="daima">　}</p><p class="content">这里我们创建了一个注入器，它知道ViewPortService和另一个以字符串OtherSizeService为令牌的可注入对象。这个可注入对象与我们以前用过的SizeService使用同一个工厂。</p><p class="content">最后，它使用我们创建的注入器来获得一个OtherSizeService的实例。</p><p class="content">这时，如果我们在一个大型浏览器窗口中运行该应用并点击Use Injector按钮，就会收到一条来自LargeService的日志。然而，如果我们把窗口调小，即使不刷新页面，也能正常收到来自SmallService的日志。这是因为现在注入器是随需创建的，我们每次点击按钮时都会重新执行工厂函数。这真漂亮！</p><p class="sectionTitle biaoti3"><a id="sec009"></a>8.9 替换值</p><p class="content">使用依赖注入的另一个理由是在运行期间改变被注入对象的硬编码值。当我们用一个API服务来向应用的后端API发起HTTP请求时，就会出现这种情况。在单元测试或集成测试的场景下，我们肯定不希望代码接触生产环境的数据库。这时，就可以写一个Mock的API服务，它可以天衣无缝地<b>替换掉</b>我们的具体实现。我们这就来详细解释一下。</p><p class="content">比如，如果在开发环境下运行该应用，我们可能会接触与生产环境下不同的API服务器。</p><p class="content">当我们发布一个开源或可复用的服务时，这就更加有用了。这种情况下，我们要允许调用者定义或改写API的URL。</p><p class="content">我们来写一个简单的示例应用，它会根据自己是在生产模式还是开发模式运行来为API的URL注入不同的值。先从ApiService类开始。</p><p class="reference"><b>code/dependency_injection/value/app/ts/services/ApiService.ts</b></p><p class="daima">import { Inject } from '@angular/core';</p><p class="daima">export const API_URL：string = 'API_URL';</p><p class="daima">export class ApiService {</p><p class="daima">　constructor（@Inject（API_URL）private apiUrl：string）{</p><p class="daima">　}</p><p class="daima">　get（）：void {</p><p class="daima">　　console.log（`Calling ${this.apiUrl}/endpoint……`）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">我们先声明了一个常量，它会被用作API URL依赖的<b>令牌</b>。换句话说，Angular会根据字符串'API_URL'来存储要调用哪个URL的信息。这样，当我们使用@Inject（API_URL）时，就会把正确的值注入到apiUrl变量中。</p><p class="content">注意，我们还同时导出了API_URL常量，这样客户方应用就可以从服务之外使用API_URL来注入正确的值。</p><p class="content">现在，我们已经有了服务，接下来写一个应用组件，它将使用该服务，并根据所在的运行环境为URL提供不同的值。</p><p class="reference"><b>code/dependency_injection/value/app/ts/app.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'di-value-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;button（click）="invokeApi（）"&gt;Invoke API&lt;/button&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class DiValueApp {</p><p class="daima">　constructor（private apiService：ApiService）{</p><p class="daima">　}</p><p class="daima">　invokeApi（）：void {</p><p class="daima">　　this.apiService.get（）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">这是组件的源代码。在构造函数中，我们声明了一个ApiService类型的变量apiService。这时，Angular就能推断出我们需要一个ApiService型的依赖，并在运行时注入它。如果我们要让它更明确一点，那么可以这样写：</p><p class="daima">constructor（@Inject（ApiService）private apiService：ApiService）{</p><p class="daima">}</p><p class="content">该组件有一个Invoke API按钮。当点击此按钮时，我们调用ApiService的get（）方法。此方法就会把我们正在使用的API_URL的值记录到控制台中。</p><p class="content">下一步是使用提供者来配置本应用。</p><p class="reference"><b>code/dependency_injection/value/app/ts/app.ts</b></p><p class="daima">const isProduction：boolean = false;</p><p class="daima">@NgModule（{</p><p class="daima">　declarations：[ DiValueApp ],</p><p class="daima">　imports：[ BrowserModule ],</p><p class="daima">　bootstrap：[ DiValueApp ],</p><p class="daima">　providers：[</p><p class="daima">　　{ provide：ApiService, useClass：ApiService },</p><p class="daima">　　{</p><p class="daima">　　　provide：API_URL,</p><p class="daima">　　　useValue：isProduction ?</p><p class="daima">　　　　'https：//production-api.sample.com'：</p><p class="daima">　　　　'http：//dev-api.sample.com'</p><p class="daima">　　}</p><p class="daima">　]</p><p class="daima">}）</p><p class="daima">class DiValueAppAppModule {}</p><p class="daima">platformBrowserDynamic（）.bootstrapModule（DiValueAppAppModule）</p><p class="content">我们首先声明了一个名叫isProduction的常量，并把它设置为false。我们先假装做了点什么来检测自己是否是在生产模式下运行。这里可以先把它硬编码进去，也可以使用一些小技巧来实现它，比如使用webpack和一个.env文件。</p><p class="content">最后，我们引导本应用，并设置两个提供者：一个用真正的实现类来提供ApiService，另一个则用来提供API_URL。如果在生产模式下运行，我们就使用某个值，否则用另一个。</p><p class="content">要测试它，我们可以带上isProduction = true来运行本应用。然后点击该按钮，就会看到日志中记录了生产模式下的URL，如图8-8所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20347/14/212737377/60306/568b5ca1/5b03d541N4f5b600e.jpg" class="enlarge" alt="" href="./image/a-68.jpg" /></p><p class="descrip"><b>图8-8　生产环境</b></p><p class="content">如果把它改成isProduction = false，就会看到开发模式下的URL，如图8-9所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19102/173/2643308590/61879/325b71c2/5b03d541Na9912826.jpg" class="enlarge" alt="" href="./image/a-69.jpg" /></p><p class="descrip"><b>图8-9　开发环境</b></p><p class="sectionTitle biaoti3"><a id="sec010"></a>8.10 NgModule</p><p class="content">NgModule是帮助<b>编译器</b>和依赖注入对依赖进行组织的方式。让我们看看为什么需要NgModule以及它们是如何工作的。</p><p class="content">我们要剖析的是Angular中的编译器和依赖注入这两个角色。简而言之，Angular需要解决<b>组件定义了哪些HTML标记（tag）</b>以及<b>这些依赖来自哪里</b>这两个问题。</p><p class="listTitle1 biaoti8">8.10.1 NgModule与JavaScript模块</p><p class="content">你可能会疑惑：为什么我们需要一个新的模块系统呢？只用ES6/TypeScript的模块还不够吗？</p><p class="content">这是因为虽然仍然要用import来把代码模块加载到JavaScript环境中，但NgModule体系却是Angular框架<b>内部</b>对依赖进行组织的一种方式。特别是围绕两个问题：<b>编译出了哪些标记</b>以及<b>哪些依赖应该被注入其中</b>。</p><p class="listTitle1 biaoti8">8.10.2 编译器与组件</p><p class="content">对于编译器来说，如果有一个带有自定义标记的Angular模板，你就得告诉编译器哪些标记是有效的（以及应该为它们附加上哪些功能）。</p><p class="content">比如，假设你有这样一个组件：</p><p class="daima">@Component（{</p><p class="daima">　selector：'hello-world',</p><p class="daima">　template：`&lt;div&gt;Hello world&lt;/div&gt;`</p><p class="daima">}）</p><p class="daima">class HelloWorld {</p><p class="daima">}</p><p class="content">我们希望编译器知道下列HTML代码应该使用这个hello-world组件（这个hello-world可不是随便写的无效标签）：</p><p class="daima">&lt;div&gt;</p><p class="daima">　&lt;hello-world&gt;&lt;/hello-world&gt;</p><p class="daima">&lt;/div&gt;</p><p class="content">在AngularJS中，hello-world选择器应该已经在<b>全局</b>范围注册过了。在你的应用成长到发生命名冲突之前，这样做都很方便。比如，如果两个开源项目使用了相同的选择器，问题就很难解决。</p><p class="content">如果你用过Angular RC.5之前的老版本，可能还记得那些版本需要你在@Component注解中指定一个directives选项。这种方式的优点是它不怎么需要“魔术”来移除表面的冲突。它的问题在于要为每个组件指定用到的所有指令，这样太繁琐了。</p><p class="content">改用NgModule，我们可以在“模块”一级告诉Angular组件的依赖关系。我们会在稍后讲解更多内容。</p><p class="listTitle1 biaoti8">8.10.3 依赖注入与提供者</p><p class="content">回忆一下，依赖注入是一种让依赖在整个应用中可用的组织形式。它对简单的import代码形式进行了强化，让我们得以用一种标准化的方式来共享单例、创建工厂以及在测试期间改写依赖。</p><p class="content">在Angular RC.5之前的版本中，我们不得不在bootstrap函数的providers参数中指定待注入的一切（<b>提供者</b>）。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　回想下列术语：<b>提供者</b>提供（创建、实例化等）你想要的<b>可注入对象</b>。在Angular中，当你想要访问<b>可注入对象</b>时，就把一个依赖<b>注入</b>一个函数中。Angular中的依赖注入框架就会找到它，并把它提供给你。</p><p class="content">现在，利用NgModule，每个提供者都被指定为模块的一部分。</p><p class="content">现在你应该明白了为什么需要NgModule以及要怎样使用它了吧？这里是最简单的例子：</p><p class="daima">// app.ts</p><p class="daima">@NgModule（{</p><p class="daima">　imports：[ BrowserModule ],</p><p class="daima">　declarations：[ HelloWorld ],</p><p class="daima">　bootstrap：[ HelloWorld ]</p><p class="daima">}）</p><p class="daima">class HelloWorldAppModule {}</p><p class="daima">platformBrowserDynamic（）.bootstrapModule（HelloWorldAppModule）;</p><p class="content">在这里，我们定义了一个HelloWorldAppModule类，随后将其作为我们应用程序的入口点。从RC5开始，不再使用<b>组件</b>来引导应用，而是改用bootstrapModule，就像这里的代码一样。</p><p class="content">NgModule可以导入其他模块作为自己的依赖。我们要在浏览器中运行此应用，所以还要导入BrowserModule。</p><p class="content">我们要在此应用中使用HelloWorld组件。记住这里的关键：<b>每个组件都必须在某些</b>NgModule<b>中声明过</b>。这里我们把HelloWorld放在了NgModule的declarations中。</p><p class="content">我们说HelloWorld组件<b>从属于</b>HelloWorldAppModule；任何组件都<b>只能从属于一个</b>NgModule。</p><p class="content">我们通常会把很多组件一起放进一个NgModule中，这很像Java中的package或C#中的namespace。</p><p class="content">如果你想引导该模块（也就是把该模块作为应用的入口点），那么就得提供一个bootstrap属性，用它来指定一个作为该模块入口点的组件。</p><p class="content">在这个例子中，你将会bootstrap这个HelloWorld组件，并把它作为根组件。不过，如果你创建的模块不需要用作应用程序入口点，那么bootstrap属性就是可选的。</p><p class="listTitle1 biaoti8">8.10.4 组件可见性</p><p class="content">要使用任何组件，当前的NgModule都必须先知道它。假设我们想在hello-world组件中使用user-greeting组件，就像这样：</p><p class="daima">　&lt;！—— hello-world template ——&gt;</p><p class="daima">　&lt;div&gt;</p><p class="daima">　　&lt;user-greeting&gt;&lt;/user-greeting&gt;</p><p class="daima">　　world</p><p class="daima">　&lt;/div&gt;</p><p class="content">如果任何组件想要使用其他组件，它必须首先通过NgModule体系获得访问权。有两种方式能做到这一点：</p><p class="content">（1）user-greeting组件位于同一个NgModule中（比如HelloWorldAppModule）；</p><p class="content">（2）HelloWorldAppModule导入（imports）了UserGreeting组件所在的模块。</p><p class="content">假设我们要访问第二个路由。下面是UserGreetingModule中的UserGreeting组件的实现代码：</p><p class="daima">@Component（{</p><p class="daima">　selector：'user-greeting',</p><p class="daima">　template：`&lt;span&gt;hello&lt;/span&gt;`</p><p class="daima">}）</p><p class="daima">class UserGreeting {</p><p class="daima">}</p><p class="daima">@NgModule（{</p><p class="daima">　declarations：[ UserGreeting ],</p><p class="daima">　exports：[ UserGreeting ]</p><p class="daima">}）</p><p class="daima">export class UserGreetingModule {}</p><p class="content">注意，这里我们添加了一个新的属性exports。可以先把exports当作这个NgModule中<b>公开</b>组件的列表。这里隐含的意思是，我们可以轻松地制作一个<b>私有</b>组件，只要别把它列进exports中就行了。</p><p class="content">如果你忘了把组件加到declarations和exports中（然后还要在另一个模块中通过imports引入本模块），那么<b>组件将不会生效</b>。为了让你的组件能在其他模块中通过imports的方式使用，你必须把组件同时放在这两个地方。</p><p class="content">现在，只要把它导入到HelloWorldAppModule中，我们就可以在HelloWorld组件中使用它了，就像这样：</p><p class="daima">// updated HelloWorldAppModule</p><p class="daima">@NgModule（{</p><p class="daima">　declarations：[ HelloWorld ],</p><p class="daima">　imports：[ BrowserModule, UserGreetingModule ], // &lt;—— added</p><p class="daima">　bootstrap：[ HelloWorld ],</p><p class="daima">}）</p><p class="daima">class HelloWorldAppModule {}</p><p class="listTitle1 biaoti8">8.10.5 指定提供者</p><p class="content">只要把可注入对象的提供者添加到NgModule的providers属性中，就算完成指定了。</p><p class="content">例如，假设我们有这样一个简单的服务：</p><p class="daima">export class ApiService {</p><p class="daima">　get（）：void {</p><p class="daima">　　console.log（'Getting resource……'）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">我们希望把它注入到组件中，就像这样：</p><p class="daima">class ApiDataComponent {</p><p class="daima">　constructor（private apiService：ApiService）{</p><p class="daima">　}</p><p class="daima">　getData（）：void {</p><p class="daima">　　this.apiService.get（）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">用NgModule可以很容易做到这一点：只要把ApiService传给该模块的providers属性就可以了：</p><p class="daima">@NgModule（{</p><p class="daima">　declarations：[ ApiDataComponent ],</p><p class="daima">　providers：[ ApiService ]　 // &lt;—— here</p><p class="daima">}）</p><p class="daima">class ApiAppModule {}</p><p class="content">这里直接传入ApiService实际上是一个缩写版本，使用provide的完整版本是这样的：</p><p class="daima">@NgModule（{</p><p class="daima">　declarations：[ ApiDataComponent ],</p><p class="daima">　providers：[</p><p class="daima">　　provide（ApiService, { useClass：ApiService }）</p><p class="daima">　]</p><p class="daima">}）</p><p class="daima">class ApiAppModule {}</p><p class="content">我们是在告诉Angular，当ApiService被注入时，依赖注入体系要负责创建、维护该类的单例，并把它传进去。</p><p class="content">要从其他模块中<b>使用</b>这些提供者，必须先导入（import）那个模块。</p><p class="content">由于ApiDataComponent和ApiService都位于同一个NgModule中，ApiDataComponent可以直接注入ApiService。否则，就需要把包含ApiService的模块导入到ApiAppModule中。</p><p class="sectionTitle biaoti3"><a id="sec011"></a>8.11 总结</p><p class="content">可以看出，依赖注入和NgModule的协作为管理应用中的依赖提供了一种强大的方式。要了解更多知识，请参考下列资源：</p><p class="content">●Angular DI官方文档<sup><a class="mz-footnote-link" href="#footnote2"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup></p><p class="content">●Victor Savkin对AngularJS中和Angular中依赖注入的对比<sup><a class="mz-footnote-link" href="#footnote3"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup></p><ol class="mz-footnote"><li id="footnote1">在美国，不同州的税率有所不同。——译者注</li><li id="footnote2">https：//angular.io/docs/ts/latest/guide/dependency-injection.html</li><li id="footnote3">http：//victorsavkin.com/post/126514197956/dependency-injection-in-angular-1-and-angular-2</li></ol></body></html>