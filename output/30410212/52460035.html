<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><link rel="stylesheet" type="text/css" href="http://storage.360buyimg.com/ebooks/9fd8bb77eb40456b746aaae41785499a_new_.css" /><title>第14章 高级组件</title></head><body><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17515/67/2645705574/36224/412d4ca6/5b03d540N546ed0a1.jpg" class="fullscreen" alt="" href="./image/Figure-014.jpg" /></p><p class="content">在本书中，我们已经学习了如何使用Angular的内置指令以及如何创建组件。本章将深入探讨用于开发组件的<b>高级</b>Angular特性。</p><p class="content">我们将在本章中学习以下内容：</p><p class="content">●组件样式封装</p><p class="content">●修改宿主DOM元素</p><p class="content">●使用<b>内容投影</b>修改模板</p><p class="content">●访问邻近的指令</p><p class="content">●使用生命周期钩子</p><p class="content">●变更检测</p><p class="sectionTitle biaoti3"><a id="sec001"></a>14.1 样式</p><p class="content">Angular提供了一套用来指定“组件级”样式的机制。尽管CSS的意思是<b>层叠样式表</b>（cascading style sheet），但有时候我们并不想要“层叠”效果。我们可能只想为某个特定的组件提供样式，而不要影响到页面的其他部分。</p><p class="content">Angular为组件提供了两个属性来定义CSS类。</p><p class="content">为了定义组件样式，我们使用视图属性styles来定义内联样式或者借助styleUrls属性来使用外部CSS文件，还可以在组件的装饰器中直接定义这些属性。</p><p class="content">我们来创建一个使用内联样式的组件。</p><p class="reference"><b>code/advanced_components/app/ts/styling/styling.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'inline-style',</p><p class="daima">　styles：[`</p><p class="daima">　.highlight {</p><p class="daima">　　border：2px solid red;</p><p class="daima">　　background-color：yellow;</p><p class="daima">　　text-align：center;</p><p class="daima">　　margin-bottom：20px;</p><p class="daima">　}</p><p class="daima">　`],</p><p class="daima">　template：`</p><p class="daima">　&lt;h4 class="ui horizontal divider header"&gt;</p><p class="daima">　　Inline style example</p><p class="daima">　&lt;/h4&gt;</p><p class="daima">　&lt;div class="highlight"&gt;</p><p class="daima">　　This uses component &lt;code&gt;styles&lt;/code&gt;</p><p class="daima">　　property</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class InlineStyle {</p><p class="daima">}</p><p class="content">在这个示例中，我们在styles数组参数中声明了CSS类.highlight，它定义了我们要用的样式。</p><p class="content">然后在模板中使用&lt;div class="highlight"&gt;引用这个类。</p><p class="content">最后的结果与我们预期的一样：一个红色边框、黄色背景的div（如图14-1所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18328/1/2634637412/21728/23297bf/5b03d540Nbc7afc2c.jpg" class="enlarge" alt="" href="./image/a-105.jpg" /></p><p class="descrip"><b>图14-1　使用styles属性的组件示例</b></p><p class="content">另一种声明CSS类的方法是使用styleUrls属性。它可以让我们从外部文件中定义CSS并在组件中直接引用它们。</p><p class="content">在用这种方式创建另一个组件之前，创建一个名为external.css的文件，它包含下面这些类。</p><p class="reference"><b>code/advanced_components/app/ts/styling/external.css</b></p><p class="daima">.highlight {</p><p class="daima">　border：2px dotted red;</p><p class="daima">　text-align：center;</p><p class="daima">　margin-bottom：20px;</p><p class="daima">}</p><p class="content">然后就可以在组件代码中引用它。</p><p class="reference"><b>code/advanced_components/app/ts/styling/styling.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'external-style',</p><p class="daima">　styleUrls：[externalCSSUrl],</p><p class="daima">　template：`</p><p class="daima">　&lt;h4 class="ui horizontal divider header"&gt;</p><p class="daima">　　External style example</p><p class="daima">　&lt;/h4&gt;</p><p class="daima">　&lt;div class="highlight"&gt;</p><p class="daima">　　This uses component &lt;code&gt;styleUrls&lt;/code&gt;</p><p class="daima">　　property</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class ExternalStyle {</p><p class="daima">}</p><p class="content">加载页面时，就可以看见有虚线边框的div（如图14-2所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17962/183/2560972248/29935/2780705e/5b03d540Nc11e7c7a.jpg" class="enlarge" alt="" href="./image/a-106.jpg" /></p><p class="descrip"><b>图14-2　使用styleUrls属性的组件示例</b></p><p class="listTitle1 biaoti8">14.1.1 视图（样式）封装</p><p class="content">这个例子中有意思的地方是，这两个组件都定义了名为highlight的类；尽管其属性是不同的，但它们并没有相互干扰。</p><p class="content">这是因为Angular默认<b>将组件样式封装在组件的上下文中</b>。如果检查页面并展开&lt;head&gt;标签，可以注意到Angular把我们定义的样式注入到了一个&lt;style&gt;标签之中，如图14-3所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21484/37/198750409/161478/fa7d8854/5b03d540Ndb53f380.jpg" class="enlarge" alt="" href="./image/a-107.jpg" /></p><p class="descrip"><b>图14-3　注入后的样式</b></p><p class="content">你还会注意到，到这个CSS类使用了_ngcontent-hve-2属性来限定其作用域：</p><p class="daima">.highlight[\_ngcontent-hve-2] {</p><p class="daima">　border：2px solid red;</p><p class="daima">　background-color：yellow;</p><p class="daima">　text-align：center;</p><p class="daima">　margin-bottom：20px; }</p><p class="daima">}</p><p class="content">如果查看&lt;div&gt;的渲染结果，会发现它也添加了一个_ng-content-hve-2属性，如图14-4所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20317/365/227145329/135434/9b280095/5b03d541N8ccde391.jpg" class="enlarge" alt="" href="./image/a-108.jpg" /></p><p class="descrip"><b>图14-4　注入后的样式：&lt;div&gt;的渲染结果</b></p><p class="content">引用外部样式文件时的效果也是一样的，如图14-5所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17272/204/2639508552/146726/53021e1b/5b03d541Nd934e239.jpg" class="enlarge" alt="" href="./image/a-109.jpg" /></p><p class="descrip"><b>图14-5　外部样式</b></p><p class="content">&lt;div&gt;的渲染结果如图14-6所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20695/28/215290480/132133/bc90b395/5b03d541Nb506d270.jpg" class="enlarge" alt="" href="./image/a-110.jpg" /></p><p class="descrip"><b>图14-6　外部样式：&lt;div&gt;的渲染结果</b></p><p class="content">Angular允许我们使用encapsulation属性来更改这种行为。</p><p class="content">这个属性可以取下列值之一，它们都定义在ViewEncapsulation枚举中。</p><p class="content">●Emulated（仿真）：这是默认选项，它会采用我们刚刚解释过的技术来封装样式。</p><p class="content">●Native（原生）：使用这个选项，Angular会采用Shadow DOM技术（下面会详细介绍）。</p><p class="content">●None（无）：使用这个选项，Angular不会封装任何样式，允许样式渗透给页面的其他元素。</p><p class="listTitle1 biaoti8">14.1.2 Shadow DOM封装</p><p class="content">你可能会问：Shadow DOM有什么用呢？通过使用Shadow DOM，组件会生成一棵独一无二的DOM树，而<b>这棵DOM树对于页面中的其他元素是不可见的</b>。这样，在这个元素中定义的样式对页面的其余部分来说就像不存在一样。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="inline1" alt="" href="./image/a-9.jpg" />　要深入了解Shadow DOM，请查阅Eric Bidelman撰写的指南http：//www.html5rocks.com/en/tutorials/webcomponents/shadowdom/。</p><p class="content">我们来创建另一个使用Native封装（Shadow DOM）的组件，理解它是如何工作的。</p><p class="reference"><b>code/advanced_components/app/ts/styling/styling.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：`native-encapsulation`,</p><p class="daima">　styles：[`</p><p class="daima">　.highlight {</p><p class="daima">　　text-align：center;</p><p class="daima">　　border：2px solid black;</p><p class="daima">　　border-radius：3px;</p><p class="daima">　　margin-botton：20px;</p><p class="daima">　}`],</p><p class="daima">　template：`</p><p class="daima">　&lt;h4 class="ui horizontal divider header"&gt;</p><p class="daima">　　Native encapsulation example</p><p class="daima">　&lt;/h4&gt;</p><p class="daima">　&lt;div class="highlight"&gt;</p><p class="daima">　　This component uses &lt;code&gt;ViewEncapsulation.Native&lt;/code&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`,</p><p class="daima">　encapsulation：ViewEncapsulation.Native</p><p class="daima">}）</p><p class="daima">class NativeEncapsulation {</p><p class="daima">}</p><p class="content">在这个例子中，如果查看源代码，会看到如图14-7所示的结果。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17155/126/2655776994/131007/ce751429/5b03d541N8c2a3f70.jpg" class="enlarge" alt="" href="./image/a-111.jpg" /></p><p class="descrip"><b>图14-7　Native封装</b></p><p class="content">#shadow-root元素里面的一切都被封装起来了，并且和页面的其他部分是完全隔离的。</p><p class="listTitle1 biaoti8">14.1.3 不使用封装</p><p class="content">最后，如果我们创建一个组件并指定ViewEncapsulation.None，那就不会进行任何的样式封装。</p><p class="reference"><b>code/advanced_components/app/ts/styling/styling.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：`no-encapsulation`,</p><p class="daima">　styles：[`</p><p class="daima">　.highlight {</p><p class="daima">　　border：2px dashed red;</p><p class="daima">　　text-align：center;</p><p class="daima">　　margin-bottom：20px;</p><p class="daima">　}</p><p class="daima">　`],</p><p class="daima">　template：`</p><p class="daima">　&lt;h4 class="ui horizontal divider header"&gt;</p><p class="daima">　　No encapsulation example</p><p class="daima">　&lt;/h4&gt;</p><p class="daima">　&lt;div class="highlight"&gt;</p><p class="daima">　　This component uses &lt;code&gt;ViewEncapsulation.None&lt;/code&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`,</p><p class="daima">　encapsulation：ViewEncapsulation.None</p><p class="daima">}）</p><p class="daima">class NoEncapsulation {</p><p class="daima">}</p><p class="content">检查元素时，会看到如图14-8所示的结果。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17071/60/2578197499/142853/a455be41/5b03d540N179be56d.jpg" class="enlarge" alt="" href="./image/a-112.jpg" /></p><p class="descrip"><b>图14-8　不进行封装</b></p><p class="content">可以看到HTML中没有注入任何东西。在页头中可以找到注入的&lt;style&gt;标签，它跟我们在styles参数中定义的完全一样：</p><p class="daima">.highlight {</p><p class="daima">　border：2px dashed red;</p><p class="daima">　text-align：center;</p><p class="daima">　margin-bottom：20px;</p><p class="daima">}</p><p class="content">使用ViewEncapsulation.None的缺点是，因为没有进行任何封装，所以它的样式会影响到其他组件。在图13-8中可以看到，使用ViewEncapsulation.Native的组件已经受到了这个新组件的样式的影响。但有时候这可能恰恰是你想要的。</p><p class="content">你可以注释掉StyleSampleApp模板中的&lt;no-encapsulation&gt;&lt;/no-encapsulation&gt;这行代码来看一看区别。</p><p class="sectionTitle biaoti3"><a id="sec002"></a>14.2 创建popup指令：引用并修改宿主元素</p><p class="content"><b>宿主元素</b>是指令或组件被绑定到的元素。有时组件可能需要往它的宿主元素上附加一些标记或行为。</p><p class="content">在这个示例中，我们会创建一个popup指令。它会往宿主元素上附加行为，在宿主元素被点击时显示一条信息。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="enlarge" alt="" href="./image/a-9.jpg" /></p><p class="content"><b>组件与指令：两者的区别是什么？</b></p><p class="content">组件和指令有着密不可分的关系，但它们略有不同。</p><p class="content">你或许曾听说过“组件就是有视图的指令”。其实这并不完全正确。组件自带的功能使它很容易添加视图，但指令同样也可以有视图。事实上，<b>组件是用指令来实现的</b>。</p><p class="content">一个很好的例子就是ngIf，它根据条件来渲染视图。</p><p class="content">但我们可以使用<b>指令</b>在<b>没有模板</b>的情况下给元素附加行为。</p><p class="content">你可以这样认为：组件就是指令，但组件必须有视图。指令可以有视图，也可以没有。</p><p class="content">如果你选择在指令中渲染视图（模板）的话，可以对该模板的呈现方式进行更多的控制。在本章的后面我们会讨论如何对模板进行控制。</p><p class="listTitle1 biaoti8">14.2.1 popup指令的结构</p><p class="content">现在来编写我们的首个指令。我们希望在点击一个带有popup属性的DOM元素时，该指令能显示出一个提示消息。这个消息是通过该元素的message属性来指定的。</p><p class="content">我们希望它看起来如下所示：</p><p class="daima">&lt;element popup message="Some message"&gt;&lt;/element&gt;</p><p class="content">为了让这个组件正常工作，我们还要做一些事：</p><p class="content">●接收来自宿主元素的message属性；</p><p class="content">●当宿主元素被点击时得到通知。</p><p class="content">我们这就开始编写它。</p><p class="reference"><b>code/advanced_components/app/ts/host/steps/host_01.ts</b></p><p class="daima">@Directive（{</p><p class="daima">　selector：'[popup]'</p><p class="daima">}）</p><p class="daima">class Popup {</p><p class="daima">　constructor（）{</p><p class="daima">　　console.log（'Directive bound'）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">我们使用Directive注解并将selector参数设置为[popup]。这可以让该指令绑定到任何定义了popup属性的元素。</p><p class="content">现在来创建一个应用，它包含一个有popup属性的元素。</p><p class="reference"><b>code/advanced_components/app/ts/host/steps/host_01.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'host-sample-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui message" popup&gt;</p><p class="daima">　　&lt;div class="header"&gt;</p><p class="daima">　　　Learning Directives</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;p&gt;</p><p class="daima">　　　This should use our Popup diretive</p><p class="daima">　　&lt;/p&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class HostSampleApp1 {</p><p class="daima">}</p><p class="content">运行这个应用时，我们期望Directive bound消息会被打印到控制台中，这表示我们已经成功绑定了模板中的第一个&lt;div&gt;（如图14-9所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17251/71/2611020117/90937/b488ad2f/5b03d541N191acc6e.jpg" class="enlarge" alt="" href="./image/a-113.jpg" /></p><p class="descrip"><b>图14-9　绑定到宿主元素</b></p><p class="listTitle1 biaoti8">14.2.2 使用ElementRef</p><p class="content">如果我们想对指令所绑定的宿主元素进行更多控制，可以使用内置的ElementRef类。</p><p class="content">这个类保存着指定Angular元素的相关信息，使用它的nativeElement属性可以获取原生的DOM元素。</p><p class="content">为了看到指令所绑定的元素，我们可以在构造函数中接收ElementRef并把它打印到控制台中。</p><p class="reference"><b>code/advanced_components/app/ts/host/steps/host_02.ts</b></p><p class="daima">@Directive（{</p><p class="daima">　selector：'[popup]'</p><p class="daima">}）</p><p class="daima">class Popup {</p><p class="daima">　constructor（_elementRef：ElementRef）{</p><p class="daima">　　console.log（_elementRef）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">我们还可以往页面中添加另一个元素，它也使用这个指令。这样就可以看见控制台中打印了两个不同的ElementRef。</p><p class="reference"><b>code/advanced_components/app/ts/host/steps/host_02.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'host-sample-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui message" popup&gt;</p><p class="daima">　　&lt;div class="header"&gt;</p><p class="daima">　　　Learning Directives</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;p&gt;</p><p class="daima">　　　This should use our Popup diretive</p><p class="daima">　　&lt;/p&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　&lt;i class="alarm icon" popup&gt;&lt;/i&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class HostSampleApp2 {</p><p class="daima">}</p><p class="content">现在，当运行应用时，可以看到两个不同的ElementRef：一个是div.ui.message，另一个是i.alarm.icon。这表示该指令已经成功绑定了两个不同的宿主元素，如图14-10所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21037/35/208501742/100997/cbc980e8/5b03d540Nb1b0d03b.jpg" class="enlarge" alt="" href="./image/a-114.jpg" /></p><p class="descrip"><b>图14-10　两个ElementRef</b></p><p class="listTitle1 biaoti8">14.2.3 绑定到host属性</p><p class="content">我们的下一个目标是在宿主元素被点击时做一些事。</p><p class="content">我们之前学过，在Angular中给元素绑定事件的方法是使用（event）语法。</p><p class="content">为了给宿主元素绑定事件，我们必须做一些类似的事情，不同之处是这次使用指令的host属性。<b>host属性允许指令改变其宿主元素的属性和行为</b>。</p><p class="content">我们还希望宿主元素使用它的message属性来定义点击时要弹出的消息。</p><p class="content">首先，在指令中添加inputs属性。我们导入Input，并使用@Input注解来修饰这个输入属性。</p><p class="daima">import { Component, Input } from '@angular/core';</p><p class="daima">……</p><p class="daima">class Popup {</p><p class="daima">　@Input（）message：String;</p><p class="daima">　……</p><p class="daima">}</p><p class="content">这段代码表示我们有一个名为message的属性，并且期望接收一个与之同名的输入。</p><p class="content">接着，我们通过往@Component注解上添加host属性来把它绑定到宿主元素上。</p><p class="reference"><b>code/advanced_components/app/ts/host/steps/host_03.ts</b></p><p class="daima">@Directive（{</p><p class="daima">　selector：'[popup]',</p><p class="daima">　host：{</p><p class="daima">　　'（click）'：'displayMessage（）'</p><p class="daima">　}</p><p class="daima">}）</p><p class="content">然后，当宿主元素被点击时就会调用指令的displayMessage方法，它会显示宿主元素定义的消息。</p><p class="content">现在代码如下所示。</p><p class="reference"><b>code/advanced_components/app/ts/host/steps/host_03.ts</b></p><p class="daima">class Popup {</p><p class="daima">　@Input（）message：String;</p><p class="daima">　constructor（_elementRef：ElementRef）{</p><p class="daima">　　console.log（_elementRef）;</p><p class="daima">　}</p><p class="daima">　displayMessage（）：void {</p><p class="daima">　　alert（this.message）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">最后，我们需要修改应用的模板，为每个元素添加要显示的消息。</p><p class="reference"><b>code/advanced_components/app/ts/host/steps/host_03.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'host-sample-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui message" popup</p><p class="daima">　　　 message="Clicked the message"&gt;</p><p class="daima">　　&lt;div class="header"&gt;</p><p class="daima">　　　Learning Directives</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;p&gt;</p><p class="daima">　　　This should use our Popup diretive</p><p class="daima">　　&lt;/p&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　&lt;i class="alarm icon" popup</p><p class="daima">　　 message="Clicked the alarm icon"&gt;&lt;/i&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class HostSampleApp3 {</p><p class="daima">}</p><p class="content">注意，这里使用了两次popup指令并传入了不同的message属性。这意味着当我们运行本应用时，点击信息内容或者图标将会看到不同的弹出信息，分别如图14-11和图14-12所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20281/13/198700034/41551/6c6d1471/5b03d541Nfc94a2f3.jpg" class="enlarge" alt="" href="./image/a-115.jpg" /></p><p class="descrip"><b>图14-11　弹出信息1</b></p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18457/20/2644324509/41204/da1b78a/5b03d540Ne3745e50.jpg" class="enlarge" alt="" href="./image/a-116.jpg" /></p><p class="descrip"><b>图14-12　弹出信息2</b></p><p class="listTitle1 biaoti8">14.2.4 添加按钮并使用exportAs</p><p class="content">假设现在又来了新需求：通过点击按钮来手动触发弹出信息。那么该如何在宿主元素<b>之外</b>触发弹出信息呢？</p><p class="content">为了实现这个目标，我们要让<b>指令在模板中的任何地方都能被访问到</b>。正如我们在之前章节中讨论过的，可以使用<b>模板变量</b>来引用组件。我们也可以用同样的方式来引用指令。</p><p class="content">为了可以在模板中引用指令，就要使用exportAt属性。这将允许宿主元素（或宿主元素的子元素）使用#var="exportName"语法定义一个模板变量来引用指令。</p><p class="content">让我们把exportAs属性添加到指令中。</p><p class="reference"><b>code/advanced_components/app/ts/host/steps/host_04.ts</b></p><p class="daima">@Directive（{</p><p class="daima">　selector：'[popup]',</p><p class="daima">　exportAs：'popup',</p><p class="daima">　host：{</p><p class="daima">　　'（click）'：'displayMessage（）'</p><p class="daima">　}</p><p class="daima">}）</p><p class="daima">class Popup {</p><p class="daima">　@Input（）message：String;</p><p class="daima">　constructor（_elementRef：ElementRef）{</p><p class="daima">　　console.log（_elementRef）;</p><p class="daima">　}</p><p class="daima">　displayMessage（）：void {</p><p class="daima">　　alert（this.message）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">现在我们需要修改这两个元素来导出模板变量。</p><p class="reference"><b>code/advanced_components/app/ts/host/steps/host_04.ts</b></p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui message" popup #popup1="popup"</p><p class="daima">　　　 message="Clicked the message"&gt;</p><p class="daima">　　&lt;div class="header"&gt;</p><p class="daima">　　　Learning Directives</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;p&gt;</p><p class="daima">　　　This should use our Popup diretive</p><p class="daima">　　&lt;/p&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　&lt;i class="alarm icon" popup #p2="popup"</p><p class="daima">　　 message="Clicked the alarm icon"&gt;&lt;/i&gt;</p><p class="content">可以看到，我们用模板变量#p1代表div.message，用#p2代表icon。</p><p class="content">现在再添加两个按钮，分别触发它们的弹出信息。</p><p class="reference"><b>code/advanced_components/app/ts/host/steps/host_04.ts</b></p><p class="daima">　&lt;div style="margin-top：20px;"&gt;</p><p class="daima">　　&lt;button（click）="popup1.displayMessage（）" class="ui button"&gt;</p><p class="daima">　　　Display popup for message element</p><p class="daima">　　&lt;/button&gt;</p><p class="daima">　　&lt;button（click）="p2.displayMessage（）" class="ui button"&gt;</p><p class="daima">　　　Display popup for alarm icon</p><p class="daima">　　&lt;/button&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="content">现在刷新页面并分别点击每个按钮，每条消息都会如预期那样出现。</p><p class="sectionTitle biaoti3"><a id="sec003"></a>14.3 使用内容投影创建消息面板</p><p class="content">有时，我们在创建组件的时候想要把组件内部的标记作为一个参数传给组件。这种技术就叫作<b>内容投影</b>（content projection）。它能让我们指定一些会扩散到更大模板之中的标记。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　在AngularJS中，这种技术被称为<b>透传</b>（transclusion）。</p><p class="content">我们来创建一个指令，它将渲染一个比较好看的消息，如图14-13所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21889/340/202958406/13413/3163b393/5b03d541Nd04753ce.jpg" class="enlarge" alt="" href="./image/a-117.jpg" /></p><p class="descrip"><b>图14-13　popup指令渲染的消息</b></p><p class="content">我们的最终目标是写如下标记。</p><p class="daima">&lt;div message header="My Message"&gt;</p><p class="daima">　This is the content of the message</p><p class="daima">&lt;/div&gt;</p><p class="content">它将被渲染成更复杂的HTML。</p><p class="daima">&lt;div class="ui message"&gt;</p><p class="daima">　&lt;div class="header"&gt;</p><p class="daima">　　My Message</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　&lt;p&gt;</p><p class="daima">　　This is the content of the message</p><p class="daima">　&lt;/p&gt;</p><p class="daima">&lt;/div&gt;</p><p class="content">这里面临两个挑战：我们要给宿主元素添加两个CSS类（ui和message），还要把div中的内容添加到标记中的一个指定位置。</p><p class="listTitle1 biaoti8">14.3.1 改变host属性的CSS类</p><p class="content">和之前添加事件一样，为了给宿主元素添加属性，要使用host属性；但是在这里我们定义了属性的名称和值，而不是使用（event）的写法。在这个例子中是这样的。</p><p class="daima">host：{ 'class'：'ui message' }</p><p class="content">它会修改宿主元素，把这些类添加到class属性中。</p><p class="listTitle1 biaoti8">14.3.2 使用ng-content</p><p class="content">下一个挑战是将宿主元素节点原来的子节点包含进视图中的指定部分。要做到这一点，我们使用ng-content指令。</p><p class="content">因为这个指令需要模板，所以在这里改用组件，并编写如下代码。</p><p class="reference"><b>code/advanced_components/app/ts/content-projection/content-projection.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'[message]',</p><p class="daima">　host：{</p><p class="daima">　　'class'：'ui message'</p><p class="daima">　},</p><p class="daima">　template：`</p><p class="daima">　　&lt;div class="header"&gt;</p><p class="daima">　　　{{ header }}</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;p&gt;</p><p class="daima">　　　&lt;ng-content&gt;&lt;/ng-content&gt;</p><p class="daima">　　&lt;/p&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class Message {</p><p class="daima">　@Input（）header：string;</p><p class="daima">　ngOnInit（）：void {</p><p class="daima">　　console.log（'header', this.header）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">下面是一些要点：</p><p class="content">●用@inputs注解表明我们希望接收宿主元素上设置的header属性；</p><p class="content">●用组件的host属性把宿主元素的class属性设置为ui message；</p><p class="content">●使用&lt;ng-content&gt;&lt;/ng-content&gt;将宿主元素的子节点投影到模板中的指定位置。</p><p class="content">当我们在浏览器中打开应用并检查有message属性的div时，会看到它正如我们所预期的那样工作，如图14-14所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t22285/309/200766096/118571/49f96c51/5b03d541N376025a7.jpg" class="enlarge" alt="" href="./image/a-118.jpg" /></p><p class="descrip"><b>图14-14　投影进来的内容</b></p><p class="sectionTitle biaoti3"><a id="sec004"></a>14.4 查询相邻的指令：编写标签页</p><p class="content">如果你能创建一个完全封装了自身行为的组件，那当然很棒。</p><p class="content">然而，随着组件功能的不断扩展，将组件切割成一些更小的组件再将它们组合在一起就变得有意义了。</p><p class="content">一个拥有多个标签页的标签面板是组件协同工作的好例子。标签面板或者<b>标签集合</b>是由多个<b>标签页</b>组合而成的。在这个场景中，我们有一个父组件（标签集合）和多个子组件（标签页）。单独看标签面板或标签页没有意义，但把所有逻辑都放在同一个组件中又太笨重了。因此，我们将在这个示例中讲解如何让这些单独的组件协同工作。</p><p class="content">下面来编写这些组件，最终目标是这样用。</p><p class="daima">&lt;tabset&gt;</p><p class="daima">　&lt;tab title="Tab 1"&gt;Tab 1&lt;/tab&gt;</p><p class="daima">　&lt;tab title="Tab 2"&gt;Tab 2&lt;/tab&gt;</p><p class="daima">　……</p><p class="daima">&lt;/tabset&gt;</p><p class="content">我们将使用Semantic UI的Tab组件<sup><a class="mz-footnote-link" href="#footnote1"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>来渲染标签页。</p><p class="listTitle1 biaoti8">14.4.1 Tab组件</p><p class="content">先来编写Tab组件。</p><p class="reference"><b>code/advanced_components/app/ts/tabs/tabs.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'tab',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui bottom attached tab segment"</p><p class="daima">　　　 [class.active]="active"&gt;</p><p class="daima">　　&lt;ng-content&gt;&lt;/ng-content&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class Tab {</p><p class="daima">　@Input（）title：string;</p><p class="daima">　active：boolean = false;</p><p class="daima">　name：string;</p><p class="daima">}</p><p class="content">这里没有什么新概念。我们声明了一个组件，它的选择器是tab并且接收一个输入属性title。</p><p class="content">然后渲染一个&lt;div&gt;标签，并使用前一节中学过的内容投影概念把&lt;tab&gt;指令的行内内容嵌入这个div。</p><p class="content">接下来声明三个组件属性：title、active和name。需要注意的是，我们把title属性添加到了@Input（'title'）注解中。这个注解告诉Angular自动把<b>输入属性title</b>和<b>组件属性title</b>进行绑定。</p><p class="listTitle1 biaoti8">14.4.2 Tabset组件</p><p class="content">现在让我们转向Tabset组件，用它来包裹住标签页。</p><p class="reference"><b>code/advanced_components/app/ts/tabs/tabs.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'tabset',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui top attached tabular menu"&gt;</p><p class="daima">　　&lt;a *ngFor="let tab of tabs"</p><p class="daima">　　　　class="item"</p><p class="daima">　　　　[class.active]="tab.active"</p><p class="daima">　　　　（click）="setActive（tab）"&gt;</p><p class="daima">　　　 {{ tab.title }}</p><p class="daima">　　&lt;/a&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　&lt;ng-content&gt;&lt;/ng-content&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class Tabset implements AfterContentInit {</p><p class="daima">　@ContentChildren（Tab）tabs：QueryList&lt;Tab&gt;;</p><p class="daima">　constructor（）{</p><p class="daima">　}</p><p class="daima">　ngAfterContentInit（）{</p><p class="daima">　　this.tabs.toArray（）[0].active = true;</p><p class="daima">　}</p><p class="daima">　setActive（tab：Tab）{</p><p class="daima">　　this.tabs.toArray（）.forEach（（t）=&gt; t.active = false）;</p><p class="daima">　　tab.active = true;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">我们来分别讲解它的实现，这样可以更好地学习它引入的新概念。</p><p class="content">●<b>Tabset的@Component注解</b></p><p class="content">@Component部分没有什么新概念。我们使用&lt;tabset&gt;作为选择器。</p><p class="content">模板本身使用ngFor来遍历tabs属性。如果一个tab的active标记是true，那么它就会在用来渲染tab的&lt;a&gt;元素上添加CSS类active。</p><p class="content">我们还指定了，在初始化div之后、在ng-content所在位置渲染所有标签。</p><p class="content">●<b>Tabset类</b></p><p class="content">现在让我们把注意力转向Tabset类。这里的第一个新概念就是Tabset类实现了AfterContentInit。这个<b>生命周期钩子</b>告诉Angular，一旦子组件的内容初始化，就调用类的方法（ngAfterContentInit）。</p><p class="content">●<b>Tabset的ContentChildren和QueryList</b></p><p class="content">接下来，我们声明tabs属性，用它来保存在tabset中声明的每个Tab组件。注意，这里声明的不是一个Tab的数组，而是使用QueryList类并传入泛型Tab。这是为什么呢？</p><p class="content">QueryList是Angular提供的类。当我们同时使用QueryList和ContentChildren时，Angular就会将<b>匹配查询的组件</b>填充到QueryList，然后在应用状态变更时<b>保持这些填充项的更新</b>。</p><p class="content">然而，QueryList需要ContentChildren来进行填充。我们这就来看一看。</p><p class="content">在tab实例对象上，我们添加了@ContentChildren（Tab）注解。这个注解告诉Angular要在tabs参数中注入所有Tab类型的直接子指令。然后再将其赋值给组件的tabs属性。<b>有了tabs属性，我们就可以获得并使用所有的子Tab组件了</b>。</p><p class="content">●<b>初始化Tabset</b></p><p class="content">当这个组件初始化之后，我们希望它的第一个标签页是激活的。为了做到这点，要使用ngAfterContentInit函数（AfterContentInit钩子对应的实现方法）。注意这里使用this.tabs.toArray（）将Angular的QueryList强制转换为原生的TypeScript数组。</p><p class="content">●<b>Tabset的setActive方法</b></p><p class="content">最后，我们定义了setActive方法。当点击模板中的标签页时就会调用这个方法，例如（click）="setActive（tab）"。这个函数会遍历所有标签页，将它们的active属性设置为false。然后把我们点击的标签页设置为激活页。</p><p class="listTitle1 biaoti8">14.4.3 使用Tabset</p><p class="content">下一个任务是开发一个应用组件，它将使用我们创建好的这两个组件。我们可以这样做。</p><p class="reference"><b>code/advanced_components/app/ts/tabs/tabs.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'tabs-sample-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;tabset&gt;</p><p class="daima">　　&lt;tab title="First tab"&gt;</p><p class="daima">　　　Lorem ipsum dolor sit amet, consectetur adipisicing elit.</p><p class="daima">　　　Quibusdam magni quia ut harum facilis, ullam deleniti porro</p><p class="daima">　　　dignissimos quasi at molestiae sapiente natus, neque voluptatum</p><p class="daima">　　　ad consequuntur cupiditate nemo sunt.</p><p class="daima">　　&lt;/tab&gt;</p><p class="daima">　　&lt;tab *ngFor="let tab of tabs" [title]="tab.title"&gt;</p><p class="daima">　　　{{ tab.content }}</p><p class="daima">　　&lt;/tab&gt;</p><p class="daima">　&lt;/tabset&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class TabsSampleApp {</p><p class="daima">　tabs：any;</p><p class="daima">　constructor（）{</p><p class="daima">　　this.tabs = [</p><p class="daima">　　　{ title：'About', content：'This is the About tab' },</p><p class="daima">　　　{ title：'Blog', content：'This is our blog' },</p><p class="daima">　　　{ title：'Contact us', content：'Contact us here' },</p><p class="daima">　　];</p><p class="daima">　}</p><p class="daima">}</p><p class="content">我们使用tabs-sample-app作为组件的选择器并且使用了组件Tabset和Tab。</p><p class="content">我们在模板中创建了一个tabset组件并添加了一个静态的tab组件（第一页），然后往组件控制器类中的tabs属性中又添加了几个tab组件，阐明了动态渲染tab组件的方法。完成后的应用如图14-15所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20296/7/201255164/60982/dc663796/5b03d541Nd6da3633.jpg" class="enlarge" alt="" href="./image/a-119.jpg" /></p><p class="descrip"><b>图14-15　使用Tabset的应用</b></p><p class="sectionTitle biaoti3"><a id="sec005"></a>14.5 生命周期钩子</p><p class="content">Angular提供了一些生命周期钩子。在指令生命周期的每个阶段之前或之后，它们允许你添加并执行一些代码。</p><p class="content">Angular提供的生命周期钩子如下：</p><p class="content">●OnInit</p><p class="content">●OnDestroy</p><p class="content">●DoCheck</p><p class="content">●OnChanges</p><p class="content">●AfterContentInit</p><p class="content">●AfterContentChecked</p><p class="content">●AfterViewInit</p><p class="content">●AfterViewChecked</p><p class="content">这些钩子的使用方法遵循相似的模式。</p><p class="content">为了得到这些事件的通知，你需要：</p><p class="content">（1）声明你的指令类实现接口；</p><p class="content">（2）声明钩子对应的ng方法（例如，ngOnInit）。</p><p class="content">每个方法名都以ng开头，再加上钩子的名字。比如，OnInit要声明ngOnInit方法，AfterContentInit要声明ngAfterContentInit方法，以此类推。</p><p class="content">当Angular知道组件实现了这些函数后，就会在适当的时机调用它们。</p><p class="content">下面分别看看每个钩子的用法以及使用场景。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　实际上，让这个类实现（implement）该接口并不是必需的，也可以只创建此钩子要求的方法。不过实现该接口是一项最佳实践<sup><a class="mz-footnote-link" href="#footnote2"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>，它能在强类型和编辑器等方面给你带来好处。</p><p class="listTitle1 biaoti8">14.5.1 OnInit和OnDestroy</p><p class="content">在指令的属性初始化完成之后、子指令的属性开始初始化之前，Angular会调用OnInit钩子。</p><p class="content">同样，在指令的实例销毁之前，Angular调用OnDestroy钩子。它最典型的应用场景是，当指令销毁、要做一些清理工作时。</p><p class="content">为了说明这些，我们来编写一个同时实现了OnInit和OnDestroy的组件。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_01.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'on-init',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui label"&gt;</p><p class="daima">　　&lt;i class="cubes icon"&gt;&lt;/i&gt; Init/Destroy</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class OnInitCmp implements OnInit, OnDestroy {</p><p class="daima">　ngOnInit（）：void {</p><p class="daima">　　console.log（'On init'）;</p><p class="daima">　}</p><p class="daima">　ngOnDestroy（）：void {</p><p class="daima">　　console.log（'On destroy'）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">在这个组件中，当钩子被调用时，我们只是往控制台中打印字符串On init和On destroy。</p><p class="content">要测试这些钩子，我们就要在应用组件中使用这些组件，并用ngIf来根据布尔值决定是否显示我们的组件。然后添加一个按钮让我们切换这个布尔型标志：当标记变为假时，组件会从页面中移除，OnDestroy就会被调用；当标记变为真时，OnInit钩子会被调用。</p><p class="content">应用组件看起来如下所示。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_01.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'lifecycle-sample-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;h4 class="ui horizontal divider header"&gt;</p><p class="daima">　　OnInit and OnDestroy</p><p class="daima">　&lt;/h4&gt;</p><p class="daima">　&lt;button class="ui primary button"（click）="toggle（）"&gt;</p><p class="daima">　　Toggle</p><p class="daima">　&lt;/button&gt;</p><p class="daima">　&lt;on-init *ngIf="display"&gt;&lt;/on-init&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class LifecycleSampleApp1 {</p><p class="daima">　display：boolean;</p><p class="daima">　constructor（）{</p><p class="daima">　　this.display = true;</p><p class="daima">　}</p><p class="daima">　toggle（）：void {</p><p class="daima">　　this.display =！this.display;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">首次运行该应用时，可以看到OnInit钩子在组件首次初始化后被调用了，如图14-16所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19210/165/2602049923/93967/e439be12/5b03d541Ncb9d1b21.jpg" class="enlarge" alt="" href="./image/a-120.jpg" /></p><p class="descrip"><b>图14-16　组件的初始状态</b></p><p class="content">在第一次点击Toggle按钮时，组件被销毁，OnDestroy钩子也如预期一般被调用了，如图14-17所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19237/360/2604551793/92541/2b5f3897/5b03d541Nfbac711c.jpg" class="enlarge" alt="" href="./image/a-121.jpg" /></p><p class="descrip"><b>图14-17　OnDestroy钩子：首次点击Toggle按钮</b></p><p class="content">如果再次点击Toggle按钮，结果将如图14-18所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17077/33/2622238983/87453/725c5d5a/5b03d541N77e1a97b.jpg" class="enlarge" alt="" href="./image/a-122.jpg" /></p><p class="descrip"><b>图14-18　OnDestroy钩子：再次点击Toggle按钮</b></p><p class="listTitle1 biaoti8">14.5.2 OnChanges</p><p class="content">OnChanges钩子在一个或多个组件属性更改后调用。ngOnChanges方法会接收一个参数来告诉你哪些属性发生了改变。</p><p class="content">为了更好地理解这一点，我们来编写一个评论组件。该组件有两个输入属性：name和comment。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_02.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'on-change',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui comments"&gt;</p><p class="daima">　　&lt;div class="comment"&gt;</p><p class="daima">　　　&lt;a class="avatar"&gt;</p><p class="daima">　　　　&lt;img src="app/images/avatars/matt.jpg"&gt;</p><p class="daima">　　　&lt;/a&gt;</p><p class="daima">　　　&lt;div class="content"&gt;</p><p class="daima">　　　　&lt;a class="author"&gt;{{name}}&lt;/a&gt;</p><p class="daima">　　　　&lt;div class="text"&gt;</p><p class="daima">　　　　　{{comment}}</p><p class="daima">　　　　&lt;/div&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class OnChangeCmp implements OnChanges {</p><p class="daima">　@Input（'name'）name：string;</p><p class="daima">　@Input（'comment'）comment：string;</p><p class="daima">　ngOnChanges（changes：{[propName：string]：SimpleChange}）：void {</p><p class="daima">　　console.log（'Changes', changes）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">最重要的一点是，这个组件实现了OnChanges接口，并声明了该接口的ngOnChanges方法。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_02.ts</b></p><p class="daima">　ngOnChanges（changes：{[propName：string]：SimpleChange}）：void {</p><p class="daima">　　console.log（'Changes', changes）;</p><p class="daima">　}</p><p class="content">当name属性或comment属性的值发生变化时，这个方法就会被触发。这时，我们就会收到一个对象，它把发生变化的字段映射到SimpleChange对象中。</p><p class="content">每个SimpleChange实例都有两个字段：currentValue和previousValue。如果组件的name和comment属性都发生了变化，那么该方法的changes值就应该是这样的。</p><p class="daima">{</p><p class="daima">　name：{</p><p class="daima">　　currentValue：'new name value',</p><p class="daima">　　previousValue：'old name value'</p><p class="daima">　},</p><p class="daima">　comment：{</p><p class="daima">　　currentValue：'new comment value',</p><p class="daima">　　previousValue：'old comment value'</p><p class="daima">　}</p><p class="daima">}</p><p class="content">现在对应用组件进行修改，让它使用我们的组件并添加一个小型表单。这样就可以试试与组件的name属性和comment属性的交互了。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_02.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'lifecycle-sample-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;h4 class="ui horizontal divider header"&gt;</p><p class="daima">　　OnInit and OnDestroy</p><p class="daima">　&lt;/h4&gt;</p><p class="daima">　&lt;button class="ui primary button"（click）="toggle（）"&gt;</p><p class="daima">　　Toggle</p><p class="daima">　&lt;/button&gt;</p><p class="daima">　&lt;on-init *ngIf="display"&gt;&lt;/on-init&gt;</p><p class="daima">　&lt;h4 class="ui horizontal divider header"&gt;</p><p class="daima">　　OnChange</p><p class="daima">　&lt;/h4&gt;</p><p class="daima">　&lt;div class="ui form"&gt;</p><p class="daima">　　&lt;div class="field"&gt;</p><p class="daima">　　　&lt;label&gt;Name&lt;/label&gt;</p><p class="daima">　　　&lt;input type="text" #namefld value="{{name}}"</p><p class="daima">　　　　　　（keyup）="setValues（namefld, commentfld）"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;div class="field"&gt;</p><p class="daima">　　　&lt;label&gt;Comment&lt;/label&gt;</p><p class="daima">　　　&lt;textarea（keyup）="setValues（namefld, commentfld）"</p><p class="daima">　　　　　　　　rows="2" #commentfld&gt;{{comment}}&lt;/textarea&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　&lt;on-change [name]="name" [comment]="comment"&gt;&lt;/on-change&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class LifecycleSampleApp2 {</p><p class="daima">　display：boolean;</p><p class="daima">　name：string;</p><p class="daima">　comment：string;</p><p class="daima">　constructor（）{</p><p class="daima">　　this.display = true;</p><p class="daima">　　this.name = 'Felipe Coury';</p><p class="daima">　　this.comment = 'I am learning so much！';</p><p class="daima">　}</p><p class="daima">　setValues（namefld, commentfld）：void {</p><p class="daima">　　this.name = namefld.value;</p><p class="daima">　　this.comment = commentfld.value;</p><p class="daima">　}</p><p class="daima">　toggle（）：void {</p><p class="daima">　　this.display =！this.display;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">重点是我们往模板中添加了一个新的表单，这个表单有name和comment两个字段。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_02.ts</b></p><p class="daima">　&lt;div class="ui form"&gt;</p><p class="daima">　　&lt;div class="field"&gt;</p><p class="daima">　　　&lt;label&gt;Name&lt;/label&gt;</p><p class="daima">　　　&lt;input type="text" #namefld value="{{name}}"</p><p class="daima">　　　　　　（keyup）="setValues（namefld, commentfld）"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;div class="field"&gt;</p><p class="daima">　　　&lt;label&gt;Comment&lt;/label&gt;</p><p class="daima">　　　&lt;textarea（keyup）="setValues（namefld, commentfld）"</p><p class="daima">　　　　　　　　rows="2" #commentfld&gt;{{comment}}&lt;/textarea&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="content">无论在name字段还是comment字段的keyup事件触发时，我们都通过模板变量调用setValues方法。模板变量namefld和commentfld分别代表这里的input和textarea。</p><p class="content">这个方法只是取出这些字段的值并更新对应的name和comment属性。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_02.ts</b></p><p class="daima">　setValues（namefld, commentfld）：void {</p><p class="daima">　　this.name = namefld.value;</p><p class="daima">　　this.comment = commentfld.value;</p><p class="daima">　}</p><p class="content">现在，当我们第一次打开应用时，就会看到OnChanges钩子被调用了，如图14-19所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19240/166/2619151812/90446/cd0b03f3/5b03d541Na03ead58.jpg" class="enlarge" alt="" href="./image/a-123.jpg" /></p><p class="descrip"><b>图14-19　OnChanges钩子：首次打开应用时</b></p><p class="content">这个事件在刚刚设置了初始值时发生在LifecycleSampleApp组件的构造函数中。</p><p class="content">如果在Name输入框中进行输入，就会看到钩子函数不断被重复调用。如图14-20所示，当我们在Name输入框中粘贴Nate Murray时，控制台正如我们预期的那样反映出了值的变化。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t22297/311/218210823/83977/c387d391/5b03d541N28692052.jpg" class="enlarge" alt="" href="./image/a-124.jpg" /></p><p class="descrip"><b>图14-20　OnChanges钩子：输入后</b></p><p class="listTitle1 biaoti8">14.5.3 DoCheck</p><p class="content">Angular默认的通知系统就是通过OnChanges实现的，每当Angular的变更检测机制检测到指令的属性变化时就会触发它。</p><p class="content">然而，有时候这种变更通知机制可能开销过大，尤其是在对性能要求较高的场景下。</p><p class="content">有时候，我们只想在特定的条件下进行一些操作，比如在移除或添加一个项目时，或是在某个特定的属性发生变化时。</p><p class="content">如果遇到上述场景之一，就可以使用DoCheck钩子。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17728/48/2715397358/11728/16045511/5b03d541N9720f866.jpg" class="inline1" alt="" href="./image/a-4.jpg" />　有一点非常重要，如果我们同时实现了OnChanges和DoCheck，那么OnChanges会被DoCheck覆盖，也就是说OnChanges会被忽略。</p><p class="content">●<b>变更检测</b></p><p class="content">为了找出有哪些变化，Angular提供了differ（差分器）类。<b>differ会对指令的某个属性进行计算，以确定它是否发生了改变</b>。</p><p class="content">有两种内置的differ类型：<b>迭代differ</b>和<b>键值对differ</b>。</p><p class="content">●<b>迭代differ</b></p><p class="content">当我们使用列表类的数据结构并且只想知道在列表中添加或删除了哪些条目时，应该使用迭代differ。</p><p class="content">●<b>键值对differ</b></p><p class="content">当我们使用字典类数据结构时，应该使用键值对differ；它在键一级工作。这个differ会识别出键的添加、删除或某个键对应值的改变。</p><p class="content">●<b>使用do-check-item渲染单条评论</b></p><p class="content">为了阐明这些概念，我们来构建一个渲染一系列评论的组件，如图14-21所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20317/11/209222728/56573/4a4774fe/5b03d541Nde043047.jpg" class="enlarge" alt="" href="./image/a-125.jpg" /></p><p class="descrip"><b>图14-21　DoCheck钩子示例</b></p><p class="content">首先，我们编写一个渲染单条评论的组件。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_03.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'do-check-item',</p><p class="daima">　outputs：['onRemove'],</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui feed"&gt;</p><p class="daima">　　&lt;div class="event"&gt;</p><p class="daima">　　　&lt;div class="label" *ngIf="comment.author"&gt;</p><p class="daima">　　　　&lt;img src="/app/images/avatars/{{comment.author.toLowerCase（）}}.jpg"&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　　&lt;div class="content"&gt;</p><p class="daima">　　　　&lt;div class="summary"&gt;</p><p class="daima">　　　　　&lt;a class="user"&gt;</p><p class="daima">　　　　　　{{comment.author}}</p><p class="daima">　　　　　&lt;/a&gt; posted a comment</p><p class="daima">　　　　　&lt;div class="date"&gt;</p><p class="daima">　　　　　　1 Hour Ago</p><p class="daima">　　　　　&lt;/div&gt;</p><p class="daima">　　　　&lt;/div&gt;</p><p class="daima">　　　　&lt;div class="extra text"&gt;</p><p class="daima">　　　　　{{comment.comment}}</p><p class="daima">　　　　&lt;/div&gt;</p><p class="daima">　　　　&lt;div class="meta"&gt;</p><p class="daima">　　　　　&lt;a class="trash"（click）="remove（）"&gt;</p><p class="daima">　　　　　　&lt;i class="trash icon"&gt;&lt;/i&gt; Remove</p><p class="daima">　　　　　&lt;/a&gt;</p><p class="daima">　　　　　&lt;a class="trash"（click）="clear（）"&gt;</p><p class="daima">　　　　　　&lt;i class="eraser icon"&gt;&lt;/i&gt; Clear</p><p class="daima">　　　　　&lt;/a&gt;</p><p class="daima">　　　　　&lt;a class="like"（click）="like（）"&gt;</p><p class="daima">　　　　　　&lt;i class="like icon"&gt;&lt;/i&gt; {{comment.likes}} Likes</p><p class="daima">　　　　　&lt;/a&gt;</p><p class="daima">　　　　&lt;/div&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="content">我们声明了组件的元数据。组件会接收输入属性comment并渲染它，还会在点击删除按钮时发出一个事件。</p><p class="content">继续看组件类的实现。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_03.ts</b></p><p class="daima">class DoCheckItem implements DoCheck {</p><p class="daima">　@Input（'comment'）comment：any;</p><p class="daima">　onRemove：EventEmitter&lt;any&gt;;</p><p class="daima">　differ：any;</p><p class="content">在这个类声明中，我们实现了DoCheck接口，并且声明了输入属性comment、输出事件onRemove和一个differ属性。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_03.ts</b></p><p class="daima">　constructor（differs：KeyValueDiffers）{</p><p class="daima">　　this.differ = differs.find（[]）.create（null）;</p><p class="daima">　　this.onRemove = new EventEmitter（）;</p><p class="daima">　}</p><p class="content">在这个构造函数中，我们用differs变量接收了一个KeyValueDiffers的实例，然后通过differs.find（[]）.create（null）语法创建了一个键值对differ的实例。我们还初始化了事件发射器onRemove。</p><p class="content">接下来，我们来实现接口要求的ngDoCheck方法。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_03.ts</b></p><p class="daima">　ngDoCheck（）：void {</p><p class="daima">　　var changes = this.differ.diff（this.comment）;</p><p class="daima">　　if（changes）{</p><p class="daima">　　　changes.forEachAddedItem（r =&gt; this.logChange（'added', r））;</p><p class="daima">　　　changes.forEachRemovedItem（r =&gt; this.logChange（'removed', r））;</p><p class="daima">　　　changes.forEachChangedItem（r =&gt; this.logChange（'changed', r））;</p><p class="daima">　　}</p><p class="daima">　}</p><p class="content">这里用键值对differ检测了变更，只要调用diff方法并提供想要检查的属性就可以了。在这个例子中，我们想知道comment属性是否发生了变化。</p><p class="content">当没有检测到任何变化时，返回值就是null。如果有变化，我们可以调用differ上的三个不同的迭代方法：</p><p class="content">●forEachAddedItem，用于枚举所有新增的键；</p><p class="content">●forEachRemovedItem，用于枚举所有删除的键；</p><p class="content">●forEachChangedItem，用于枚举所有变化的键。</p><p class="content">每个方法都会调用我们提供的接收record参数的回调函数。对于键值对differ，这个record参数是KVChangeRecord类的实例（如图14-22所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19141/216/2607289505/28218/c3a46568/5b03d541Nfeb900f5.jpg" class="enlarge" alt="" href="./image/a-126.jpg" /></p><p class="descrip"><b>图14-22　KVChangeRecord实例的一个例子</b></p><p class="content">用来了解变化的最重要的几个字段是key、previousValue和currentValue。</p><p class="content">接下来，我们写一个方法，把发生的这些变化以通俗易懂的句子输出到控制台中。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_03.ts</b></p><p class="daima">　logChange（action, r）{</p><p class="daima">　　if（action === 'changed'）{</p><p class="daima">　　　console.log（r.key, action, 'from', r.previousValue, 'to', r.currentValue）;</p><p class="daima">　　}</p><p class="daima">　　if（action === 'added'）{</p><p class="daima">　　　console.log（action, r.key, 'with', r.currentValue）;</p><p class="daima">　　}</p><p class="daima">　　if（action === 'removed'）{</p><p class="daima">　　　console.log（action, r.key, '（was ' + r.previousValue + '）'）;</p><p class="daima">　　}</p><p class="daima">　}</p><p class="content">最后，我们来写几个方法，帮助我们改变组件中的值以便触发DoCheck钩子。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_03.ts</b></p><p class="daima">　remove（）：void {</p><p class="daima">　　this.onRemove.emit（this.comment）;</p><p class="daima">　}</p><p class="daima">　clear（）：void {</p><p class="daima">　　delete this.comment.comment;</p><p class="daima">　}</p><p class="daima">　like（）：void {</p><p class="daima">　　this.comment.likes += 1;</p><p class="daima">　}</p><p class="content">remove（）方法会发出事件，表示用户请求删除这条评论。clear（）方法会把评论文字从评论对象中删除。like（）方法会增加这条评论的“赞”数。</p><p class="content">●<b>使用do-check渲染评论列表</b></p><p class="content">写好了表示单条评论的组件之后，我们再来写第二个组件，它负责渲染评论列表。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_03.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'do-check',</p><p class="daima">　template：`</p><p class="daima">　&lt;do-check-item [comment]="comment"</p><p class="daima">　　*ngFor="let comment of comments"（onRemove）="removeComment（$event）"&gt;</p><p class="daima">　&lt;/do-check-item&gt;</p><p class="daima">　&lt;button class="ui primary button"（click）="addComment（）"&gt;</p><p class="daima">　　Add</p><p class="daima">　&lt;/button&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="content">组件的元数据十分简单：使用上面创建的组件，然后用ngFor来遍历组件列表并渲染它们。我们还加了一个按钮让用户添加新评论。</p><p class="content">接下来实现评论列表类DoCheckCmp。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_03.ts</b></p><p class="daima">class DoCheckCmp implements DoCheck {</p><p class="daima">　comments：any[];</p><p class="daima">　iterable：boolean;</p><p class="daima">　authors：string[];</p><p class="daima">　texts：string[];</p><p class="daima">　differ：any;</p><p class="content">我们声明了要用的变量：comments、iterable、authors和texts。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_03.ts</b></p><p class="daima">　constructor（differs：IterableDiffers）{</p><p class="daima">　　this.differ = differs.find（[]）.create（null）;</p><p class="daima">　　this.comments = [];</p><p class="daima">　　this.authors = ['Elliot', 'Helen', 'Jenny', 'Joe', 'Justen', 'Matt'];</p><p class="daima">　　this.texts = [</p><p class="daima">　　　"Ours is a life of constant reruns．We're always circling back to where we\</p><p class="daima">'d we started, then starting all over again．Even if we don't run extra laps tha\</p><p class="daima">t day, we surely will come back for more of the same another day soon.",</p><p class="daima">　　　'Really cool！',</p><p class="daima">　　　'Thanks！'</p><p class="daima">　　];</p><p class="daima">　　this.addComment（）;</p><p class="daima">　}</p><p class="content">对于这个组件，我们使用了迭代differ。可以看到这里用来创建differ的类是IterableDiffers，但创建differ的方式还是和以前一样。</p><p class="content">在构造函数中，我们还初始化了作者列表和评论文字列表，会在添加新评论的时候用到它们。</p><p class="content">最后，我们调用addComment（）方法。这样，评论列表在应用刚刚初始化时不会是空白的。</p><p class="content">接下来的三个方法是用来添加一条新评论的。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_03.ts</b></p><p class="daima">　getRandomInt（max：number）：number {</p><p class="daima">　　return Math.floor（Math.random（）*（max + 1））;</p><p class="daima">　}</p><p class="daima">　getRandomItem（array：string[]）：string {</p><p class="daima">　　let pos：number = this.getRandomInt（array.length - 1）;</p><p class="daima">　　return array[pos];</p><p class="daima">　}</p><p class="daima">　addComment（）：void {</p><p class="daima">　　this.comments.push（{</p><p class="daima">　　　author：this.getRandomItem（this.authors）,</p><p class="daima">　　　comment：this.getRandomItem（this.texts）,</p><p class="daima">　　　likes：this.getRandomInt（20）</p><p class="daima">　　}）;</p><p class="daima">　}</p><p class="daima">　removeComment（comment）{</p><p class="daima">　　let pos = this.comments.indexOf（comment）;</p><p class="daima">　　this.comments.splice（pos, 1）;</p><p class="daima">　}</p><p class="content">我们声明了两个方法，它们分别返回一个随机数和一个数组中的随机项。</p><p class="content">最后，addComment（）方法会使用随机作者、随机文本和随机点赞数来添加一条新评论。</p><p class="content">接下来是removeComment（）方法，它用来从列表中删除一条评论。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_03.ts</b></p><p class="daima">　removeComment（comment）{</p><p class="daima">　　let pos = this.comments.indexOf（comment）;</p><p class="daima">　　this.comments.splice（pos, 1）;</p><p class="daima">　}</p><p class="content">最后声明变更检测方法ngDoCheck（）。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_03.ts</b></p><p class="daima">　ngDoCheck（）：void {</p><p class="daima">　　var changes = this.differ.diff（this.comments）;</p><p class="daima">　　if（changes）{</p><p class="daima">　　　changes.forEachAddedItem（r =&gt; console.log（'Added', r.item））;</p><p class="daima">　　　changes.forEachRemovedItem（r =&gt; console.log（'Removed', r.item））;</p><p class="daima">　　}</p><p class="daima">　}</p><p class="content">尽管在行为上与键值对differ一样，但是迭代differ只提供了添加和删除条目的方法。</p><p class="content">当运行应用时，我们得到了一个只有一条评论的列表（如图14-23所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17752/172/2639355989/91898/dd1fd026/5b03d540N86775473.jpg" class="enlarge" alt="" href="./image/a-127.jpg" /></p><p class="descrip"><b>图14-23　初始状态</b></p><p class="content">我们还看到一些信息被打印到了控制台中，就像下面这样。</p><p class="daima">added author with Matt</p><p class="daima">……</p><p class="daima">added likes with 14</p><p class="content">我们来看看，点击Add按钮来添加一条新评论时会发生什么（如图14-24所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t16783/25/2623233752/80258/585ed8ed/5b03d541N1eddfa6b.jpg" class="enlarge" alt="" href="./image/a-128.jpg" /></p><p class="descrip"><b>图14-24　添加的评论</b></p><p class="content">可以看到迭代differ识别出了添加到列表中的新评论对象{author："Hellen", comment："Thanks！", likes：17}。</p><p class="content">评论对象中单独的属性变化也打印出来了，也就是键值对differ检测到的。</p><p class="daima">added author with Helen</p><p class="daima">added comment with Thanks！</p><p class="daima">added likes with 17</p><p class="content">现在点击这条新评论的Likes图标（如图14-25所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17581/175/2652504370/69383/f13820cb/5b03d541Nf50d55a5.jpg" class="enlarge" alt="" href="./image/a-129.jpg" /></p><p class="descrip"><b>图14-25　点赞数变化</b></p><p class="content">现在只有like属性的变化会被检测到。</p><p class="content">如果点击Clear图标，它会从评论对象中删除comment键（如图14-26所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t22189/312/198539518/68809/6785d4c2/5b03d540N50177f86.jpg" class="enlarge" alt="" href="./image/a-130.jpg" /></p><p class="descrip"><b>图14-26　清空评论内容</b></p><p class="content">打印出的日志证实这个键确实被删除了。</p><p class="content">最后，我们通过点击Remove图标删除最后一条评论（如图14-27所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18583/24/2653830435/69871/e00fbc64/5b03d541N164bf706.jpg" class="enlarge" alt="" href="./image/a-131.jpg" /></p><p class="descrip"><b>图14-27　删除评论</b></p><p class="content">如预期一样，我们得到了一条对象被删除的日志。</p><p class="listTitle1 biaoti8">14.5.4 AfterContentInit、AfterViewInit、AfterContentChecked和AfterViewChecked</p><p class="content">AfterContentInit钩子的调用发生在OnInit之后。一旦组件或指令的内容初始化完成，就会立即调用它。</p><p class="content">AfterContentChecked也类似，不过它是在指令检查结束后调用的。这里的“检查”是指变更检测系统进行的检查。</p><p class="content">另外两个钩子AfterViewInit和AfterViewChecked会紧跟着上述内容钩子，在视图完全初始化之后触发。但是这两个钩子只适用于组件，不能用于指令。</p><p class="content">同时，AfterXXXInit之类的钩子在整个指令生命周期里都只会被调用一次，而AfterXXXChecked之类的钩子在每次变更检测周期后都会被调用。</p><p class="content">为了更好地理解这些，我们来编写另一个组件，它会对每个生命周期钩子都打印日志到控制台。它还有一个counter属性，可以通过点击按钮来增加计数。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_04.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'afters',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui label"&gt;</p><p class="daima">　　&lt;i class="list icon"&gt;&lt;/i&gt; Counter：{{ counter }}</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　&lt;button class="ui primary button"（click）="inc（）"&gt;</p><p class="daima">　　Increment</p><p class="daima">　&lt;/button&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class AftersCmp implements OnInit, OnDestroy, DoCheck,</p><p class="daima">　　　　　　　　　　　　　 OnChanges, AfterContentInit,</p><p class="daima">　　　　　　　　　　　　　 AfterContentChecked, AfterViewInit,</p><p class="daima">　　　　　　　　　　　　　 AfterViewChecked {</p><p class="daima">　counter：number;</p><p class="daima">　constructor（）{</p><p class="daima">　　console.log（'AfterCmd ———————— [constructor]'）;</p><p class="daima">　　this.counter = 1;</p><p class="daima">　}</p><p class="daima">　inc（）{</p><p class="daima">　　console.log（'AfterCmd ———————— [counter]'）;</p><p class="daima">　　this.counter += 1;</p><p class="daima">　}</p><p class="daima">　ngOnInit（）{</p><p class="daima">　　console.log（'AfterCmd - OnInit'）;</p><p class="daima">　}</p><p class="daima">　ngOnDestroy（）{</p><p class="daima">　　console.log（'AfterCmp - OnDestroy'）;</p><p class="daima">　}</p><p class="daima">　ngDoCheck（）{</p><p class="daima">　　console.log（'AfterCmp - DoCheck'）;</p><p class="daima">　}</p><p class="daima">　ngOnChanges（）{</p><p class="daima">　　console.log（'AfterCmp - OnChanges'）;</p><p class="daima">　}</p><p class="daima">　ngAfterContentInit（）{</p><p class="daima">　　console.log（'AfterCmp - AfterContentInit'）;</p><p class="daima">　}</p><p class="daima">　ngAfterContentChecked（）{</p><p class="daima">　　console.log（'AfterCmp - AfterContentChecked'）;</p><p class="daima">　}</p><p class="daima">　ngAfterViewInit（）{</p><p class="daima">　　console.log（'AfterCmp - AfterViewInit'）;</p><p class="daima">　}</p><p class="daima">　ngAfterViewChecked（）{</p><p class="daima">　　console.log（'AfterCmp - AfterViewChecked'）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">现在把它和Toggle按钮添加到应用组件中，就像之前在OnDestroy钩子中的用法一样。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_04.ts</b></p><p class="daima">　&lt;afters *ngIf="displayAfters"&gt;&lt;/afters&gt;</p><p class="daima">　&lt;button class="ui primary button"（click）="toggleAfters（）"&gt;</p><p class="daima">　　Toggle</p><p class="daima">　&lt;/button&gt;</p><p class="content">应用组件的最终实现看起来应该是这样的。</p><p class="reference"><b>code/advanced_components/app/ts/lifecycle-hooks/lifecycle_04.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'lifecycle-sample-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;h4 class="ui horizontal divider header"&gt;</p><p class="daima">　　OnInit and OnDestroy</p><p class="daima">　&lt;/h4&gt;</p><p class="daima">　&lt;button class="ui primary button"（click）="toggle（）"&gt;</p><p class="daima">　　Toggle</p><p class="daima">　&lt;/button&gt;</p><p class="daima">　&lt;on-init *ngIf="display"&gt;&lt;/on-init&gt;</p><p class="daima">　&lt;h4 class="ui horizontal divider header"&gt;</p><p class="daima">　　OnChange</p><p class="daima">　&lt;/h4&gt;</p><p class="daima">　&lt;div class="ui form"&gt;</p><p class="daima">　　&lt;div class="field"&gt;</p><p class="daima">　　　&lt;label&gt;Name&lt;/label&gt;</p><p class="daima">　　　&lt;input type="text" #namefld value="{{name}}"</p><p class="daima">　　　　　　（keyup）="setValues（namefld, commentfld）"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;div class="field"&gt;</p><p class="daima">　　　&lt;label&gt;Comment&lt;/label&gt;</p><p class="daima">　　　&lt;textarea（keyup）="setValues（namefld, commentfld）"</p><p class="daima">　　　　　　　　rows="2" #commentfld&gt;{{comment}}&lt;/textarea&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　&lt;on-change [name]="name" [comment]="comment"&gt;&lt;/on-change&gt;</p><p class="daima">　&lt;h4 class="ui horizontal divider header"&gt;</p><p class="daima">　　DoCheck</p><p class="daima">　&lt;/h4&gt;</p><p class="daima">　&lt;do-check&gt;&lt;/do-check&gt;</p><p class="daima">　&lt;h4 class="ui horizontal divider header"&gt;</p><p class="daima">　　AfterContentInit, AfterViewInit, AfterContentChecked and AfterViewChecked</p><p class="daima">　&lt;/h4&gt;</p><p class="daima">　&lt;afters *ngIf="displayAfters"&gt;&lt;/afters&gt;</p><p class="daima">　&lt;button class="ui primary button"（click）="toggleAfters（）"&gt;</p><p class="daima">　　Toggle</p><p class="daima">　&lt;/button&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class LifecycleSampleApp4 {</p><p class="daima">　display：boolean;</p><p class="daima">　displayAfters：boolean;</p><p class="daima">　name：string;</p><p class="daima">　comment：string;</p><p class="daima">　constructor（）{</p><p class="daima">　　// OnInit and OnDestroy</p><p class="daima">　　this.display = true;</p><p class="daima">　　// OnChange</p><p class="daima">　　this.name = 'Felipe Coury';</p><p class="daima">　　this.comment = 'I am learning so much！';</p><p class="daima">　　// AfterXXX</p><p class="daima">　　this.displayAfters = true;</p><p class="daima">　}</p><p class="daima">　setValues（namefld, commentfld）{</p><p class="daima">　　this.name = namefld.value;</p><p class="daima">　　this.comment = commentfld.value;</p><p class="daima">　}</p><p class="daima">　toggle（）：void {</p><p class="daima">　　this.display =！this.display;</p><p class="daima">　}</p><p class="daima">　toggleAfters（）：void {</p><p class="daima">　　this.displayAfters =！this.displayAfters;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">当应用启动后，我们可以看到每个钩子都打印了日志（如图14-28所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17191/358/2685787532/103769/3180ceb7/5b03d540N886b1d88.jpg" class="enlarge" alt="" href="./image/a-132.jpg" /></p><p class="descrip"><b>图14-28　应用启动</b></p><p class="content">现在我们清空控制台并点击Increment按钮（如图14-29所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21034/34/207154236/80363/e9a9ff4b/5b03d540Nf604661b.jpg" class="enlarge" alt="" href="./image/a-133.jpg" /></p><p class="descrip"><b>图14-29　计数增加</b></p><p class="content">可以看到，这次只触发了DoCheck、AfterContentChecked和AfterViewChecked这三个钩子。</p><p class="content">如果点击Toggle按钮，将如图14-30所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20272/10/228331269/68449/180184de/5b03d541Ne709345e.jpg" class="enlarge" alt="" href="./image/a-134.jpg" /></p><p class="descrip"><b>图14-30　首次切换</b></p><p class="content">接着再点击一次Toggle按钮，将如图14-31所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t16879/108/2604586252/92035/7134a89f/5b03d541N106a063f.jpg" class="enlarge" alt="" href="./image/a-135.jpg" /></p><p class="descrip"><b>图14-31　再次切换</b></p><p class="content">所有钩子都被触发了。</p><p class="sectionTitle biaoti3"><a id="sec006"></a>14.6 高级模板</p><p class="content">template元素是种特殊的元素，用来创建可以动态操控的视图。</p><p class="content">为了使template元素用起来更简单，Angular提供了一些语法糖来创建template元素，因此通常不需要手动创建。</p><p class="content">举例来说，如果我们写：</p><p class="daima">&lt;do-check-item</p><p class="daima">　*ngFor="let comment of comments"</p><p class="daima">　[comment]="comment"</p><p class="daima">　（onRemove）="removeComment（$event）"&gt;</p><p class="daima">&lt;/do-check-item&gt;</p><p class="content">它就会转换成：</p><p class="daima">&lt;do-check-item</p><p class="daima">　template="ngFor let comment of comments; #i=index"</p><p class="daima">　[comment]="comment"</p><p class="daima">　（onRemove）="removeComment（$event）"&gt;</p><p class="daima">&lt;/do-check-item&gt;</p><p class="content">接着转换成：</p><p class="daima">&lt;template</p><p class="daima">　ngFor</p><p class="daima">　[ngForOf]="comments"</p><p class="daima">　let-comment="$implicit"</p><p class="daima">　let-index="i"&gt;</p><p class="daima">　&lt;do-check-item</p><p class="daima">　　[comment]="comment"</p><p class="daima">　　（onRemove）="removeComment（$event）"&gt;</p><p class="daima">　&lt;/do-check-item&gt;</p><p class="daima">&lt;/template&gt;</p><p class="content">理解其背后的概念很重要，这样我们才能构建自己的指令。</p><p class="listTitle1 biaoti8">14.6.1 重写ngIf：ngBookIf</p><p class="content">我们来创建一个指令，它和ngIf所做的事情完全一样。我们称之为ngBookIf。</p><p class="content">●<b>ngBookIf的@Directive</b></p><p class="content">我们先为这个类声明@Directive注解：</p><p class="daima">@Directive（{</p><p class="daima">　selector：'[ngBookIf]',</p><p class="daima">}）</p><p class="content">正如前面所说，我们要使用[ngBookIf]作为选择器。这是因为当使用*ngBookIf="condition"时，它会被转换成：</p><p class="daima">&lt;template ngBookIf [ngBookIf]="condition"&gt;</p><p class="content">由于ngBookIf同时是一个属性，我们还需要指出想把ngBookIf作为输入属性进行接收。</p><p class="content">这个指令要做的是：当条件为真时，添加指令模板的内容；否则删除。</p><p class="content">当条件为真时，我们就会使用<b>视图容器</b>（view container）。视图容器是用来给指令附加一个或多个视图的。</p><p class="content">视图容器可以用来：</p><p class="content">●创建一个新视图，嵌入我们的指令模板；</p><p class="content">●清空视图容器内容。</p><p class="content">在使用它之前，需要注入ViewContainerRef和TemplateRef。它们会注入指令的视图容器和模板。</p><p class="content">代码如下所示。</p><p class="reference"><b>code/advanced_components/app/ts/templates/if.ts</b></p><p class="daima">class NgBookIf {</p><p class="daima">　constructor（private viewContainer：ViewContainerRef,</p><p class="daima">　　　　　　　private template：TemplateRef&lt;any&gt;）{}</p><p class="content">有了视图容器和模板的引用，我们就可以写TypeScript的属性设置器（setter）了，并且用Input（）注解表明它是输入属性。</p><p class="reference"><b>code/advanced_components/app/ts/templates/if.ts</b></p><p class="daima">　@Input（）set ngBookIf（condition）{</p><p class="daima">　　if（condition）{</p><p class="daima">　　　this.viewContainer.createEmbeddedView（this.template）;</p><p class="daima">　　}</p><p class="daima">　　else {</p><p class="daima">　　　this.viewContainer.clear（）;</p><p class="daima">　　}</p><p class="daima">　}</p><p class="content">每当设置类的ngBookIf属性时，这个方法都会被调用。也就是说，只要ngBookIf="condition"中的condition发生变化，就会调用这个方法。</p><p class="content">现在，如果条件为真，就使用视图容器的createEmbeddedView方法来添加指令的模板；否则使用clear方法来删除视图容器中的所有内容。</p><p class="content">●<b>使用ngBookIf</b></p><p class="content">要想使用这个指令，可以编写下面的组件。</p><p class="reference"><b>code/advanced_components/app/ts/templates/if.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'template-sample-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;button class="ui primary button"（click）="toggle（）"&gt;</p><p class="daima">　　Toggle</p><p class="daima">　&lt;/button&gt;</p><p class="daima">　&lt;div *ngBookIf="display"&gt;</p><p class="daima">　　The message is displayed</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class IfTemplateSampleApp {</p><p class="daima">　display：boolean;</p><p class="daima">　constructor（）{</p><p class="daima">　　this.display = true;</p><p class="daima">　}</p><p class="daima">　toggle（）{</p><p class="daima">　　this.display =！this.display;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">运行应用时，可以看到指令如预期的一样工作：当我们点击Toggle按钮时，会在页面中切换显示消息This message is displayed。</p><p class="listTitle1 biaoti8">14.6.2 重写ngFor：ngBookRepeat</p><p class="content">现在再来编写一个简易版的ngFor指令，用来为指定的集合反复渲染模板。</p><p class="content">●<b>ngBookRepeat模板解构</b></p><p class="content">我们将通过*ngBookRepeat="let var of collection"语法来使用该指令。</p><p class="content">就像在前一个指令中所做的那样，我们需要声明选择器[ngBookRepeat]。不过，这里的输入参数并不是只有ngBookRepeat。</p><p class="content">如果回头看一下Angular是如何转换*something="let var in collection"标记的，就会发现该元素展开后的最终形态等价于：</p><p class="daima">&lt;template something [somethingOf]="collection" let-var="$implicit"&gt;</p><p class="daima">　&lt;！—— …… ——&gt;</p><p class="daima">&lt;/template&gt;</p><p class="content">如前所见，传入的输入属性不是something，而是somethingOf。它的值就是我们的指令要接收并迭代的集合。</p><p class="content">对于生成的模板，我们将使用局部视图变量#var，它会从局部变量$implicit接收值。当Angular对语法糖进行展开时，会将一个局部变量放到模板中。这个局部变量的名称就是$implicit。</p><p class="content">●<b>ngBookRepeat的@Directive</b></p><p class="content">该开始编写这个指令了。首先来写指令的注解。</p><p class="reference"><b>code/advanced_components/app/ts/templates/for.ts</b></p><p class="daima">@Directive（{</p><p class="daima">　selector：'[ngBookRepeat]'</p><p class="daima">}）</p><p class="content">●<b>ngBookRepeat类</b></p><p class="content">然后编写组件类。</p><p class="reference"><b>code/advanced_components/app/ts/templates/for.ts</b></p><p class="daima">class NgBookRepeat implements DoCheck {</p><p class="daima">　private items：any;</p><p class="daima">　private differ：IterableDiffer;</p><p class="daima">　private views：Map&lt;any, ViewRef&gt; = new Map&lt;any, ViewRef&gt;（）;</p><p class="daima"></p><p class="daima"></p><p class="daima">　constructor（private viewContainer：ViewContainerRef,</p><p class="daima">　　　　　　　private template：TemplateRef&lt;any&gt;,</p><p class="daima">　　　　　　　private changeDetector：ChangeDetectorRef,</p><p class="daima">　　　　　　　private differs：IterableDiffers）{}</p><p class="content">我们为类声明了一些属性：</p><p class="content">●items保存我们要迭代的集合；</p><p class="content">●differ是一个IterableDiffer对象（已经在14.5节学过），用于变更检测；</p><p class="content">●views是一个Map，它将把集合中给出的条目和包含它的视图链接起来。</p><p class="content">构造函数会接收viewContainer、template和一个IterableDiffers实例（全部参数都在本章的前面讨论过）。</p><p class="content">接下来要做的就是注入变更检测器。我们会在下一节中深入讲解变更检测器，现在可以先把它理解为Angular创建的类，用来在指令属性发生变化时触发检测动作。</p><p class="content">下一步是编写设置ngBookRepeatOf属性时要触发的代码。</p><p class="reference"><b>code/advanced_components/app/ts/templates/for.ts</b></p><p class="daima">　@Input（）set ngBookRepeatOf（items）{</p><p class="daima">　　this.items = items;</p><p class="daima">　　if（this.items &amp;&amp;！this.differ）{</p><p class="daima">　　　this.differ = this.differs.find（items）.create（this.changeDetector）;</p><p class="daima">　　}</p><p class="daima">　}</p><p class="content">当设置该属性时，我们将此集合保存在指令的item属性中。如果集合是有效的并且还没有differ的话，就创建一个differ。</p><p class="content">要做到这一点，我们创建一个IterableDiffer类的实例。它可以复用指令的变更检测器（已经在构造函数中注入过了）。</p><p class="content">接下来就要编写对集合的变化作出响应的代码了。为此，我们要实现下面的ngDoCheck方法来实现DoCheck生命周期钩子。</p><p class="reference"><b>code/advanced_components/app/ts/templates/for.ts</b></p><p class="daima">　ngDoCheck（）：void {</p><p class="daima">　　if（this.differ）{</p><p class="daima">　　　let changes = this.differ.diff（this.items）;</p><p class="daima">　　　if（changes）{</p><p class="daima">　　　　changes.forEachAddedItem（（change）=&gt; {</p><p class="daima">　　　　　let view = this.viewContainer.createEmbeddedView（this.template,</p><p class="daima">　　　　　　{'$implicit'：change.item}）;</p><p class="daima">　　　　　this.views.set（change.item, view）;</p><p class="daima">　　　　}）;</p><p class="daima">　　　　changes.forEachRemovedItem（（change）=&gt; {</p><p class="daima">　　　　　let view = this.views.get（change.item）;</p><p class="daima">　　　　　let idx = this.viewContainer.indexOf（view）;</p><p class="daima">　　　　　this.viewContainer.remove（idx）;</p><p class="daima">　　　　　this.views.delete（change.item）;</p><p class="daima">　　　　}）;</p><p class="daima">　　　}</p><p class="daima">　　}</p><p class="daima">　}</p><p class="content">我们来分解一下这段代码。在这个方法中，我们做的第一件事就是确保differ已经实例化了。如果没有，那我们就不做任何事。</p><p class="content">接下来，询问differ哪些东西发生了变化。如果有变化，就用changes.forEachAddedItem方法来遍历所有新增项。对于每个添加进来的元素，该回调方法将接收一个CollectionChangeRecord对象。</p><p class="content">对于每个元素，都使用视图容器的createEmbeddedView方法来创建一个新的嵌入视图：</p><p class="daima">let view = this.viewContainer.createEmbeddedView（this.template, {'$implicit'：change.item}）;</p><p class="content">createEmbeddedView方法的第二个参数是<b>视图的上下文</b>。在这个例子中，我们把局部变量$implicit设置为change.item。这样就可以访问视图里在*ngBookRepeat="let var of collection"中声明的var变量了。也就是说，let var中的var就是$implicit变量。使用$implicit是因为当我们写这个组件时还不知道用户会给它起什么名字。</p><p class="content">最后，我们要把集合中的条目和视图关联起来。背后的原因是，如果从集合中删除了一个条目，也需要删除相应的视图。这就是接下来我们要做的。</p><p class="content">对于从集合中删除的每一个条目，我们都要根据集合条目到视图的映射找到视图，并查询该视图在视图容器中的索引。这是因为视图容器的remove方法需要一个索引。最后，还要从集合条目到视图的映射中删除这个视图。</p><p class="content">●<b>试用这个指令</b></p><p class="content">要测试这个指令，可以编写如下组件。</p><p class="reference"><b>code/advanced_components/app/ts/templates/for.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'template-sample-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;ul&gt;</p><p class="daima">　　&lt;li *ngBookRepeat="let p of people"&gt;</p><p class="daima">　　　{{ p.name }} is {{ p.age }}</p><p class="daima">　　　&lt;a href（click）="remove（p）"&gt;Remove&lt;/a&gt;</p><p class="daima">　　&lt;/li&gt;</p><p class="daima">　&lt;/ul&gt;</p><p class="daima">　&lt;div class="ui form"&gt;</p><p class="daima">　　&lt;div class="fields"&gt;</p><p class="daima">　　　&lt;div class="field"&gt;</p><p class="daima">　　　　&lt;label&gt;Name&lt;/label&gt;</p><p class="daima">　　　　&lt;input type="text" #name placeholder="Name"&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　　&lt;div class="field"&gt;</p><p class="daima">　　　　&lt;label&gt;Age&lt;/label&gt;</p><p class="daima">　　　　&lt;input type="text" #age placeholder="Age"&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　&lt;div class="ui submit button"</p><p class="daima">　　　（click）="add（name, age）"&gt;</p><p class="daima">　　Add</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class ForTemplateSampleApp {</p><p class="daima">　people：any[];</p><p class="daima">　constructor（）{</p><p class="daima">　　this.people = [</p><p class="daima">　　　{name：'Joe', age：10},</p><p class="daima">　　　{name：'Patrick', age：21},</p><p class="daima">　　　{name：'Melissa', age：12},</p><p class="daima">　　　{name：'Kate', age：19}</p><p class="daima">　　];</p><p class="daima">　}</p><p class="daima">　remove（p）{</p><p class="daima">　　let idx：number = this.people.indexOf（p）;</p><p class="daima">　　this.people.splice（idx, 1）;</p><p class="daima">　　return false;</p><p class="daima">　}</p><p class="daima">　add（name, age）{</p><p class="daima">　　this.people.push（{name：name.value, age：age.value}）;</p><p class="daima">　　name.value = '';</p><p class="daima">　　age.value = '';</p><p class="daima">　}</p><p class="daima">}</p><p class="content">我们使用指令来遍历人员列表。</p><p class="reference"><b>code/advanced_components/app/ts/templates/for.ts</b></p><p class="daima">　&lt;ul&gt;</p><p class="daima">　　&lt;li *ngBookRepeat="let p of people"&gt;</p><p class="daima">　　　{{ p.name }} is {{ p.age }}</p><p class="daima">　　　&lt;a href（click）="remove（p）"&gt;Remove&lt;/a&gt;</p><p class="daima">　　&lt;/li&gt;</p><p class="daima">　&lt;/ul&gt;</p><p class="content">当点击Remove按钮时，我们将该条目从集合中删除并触发变更检测。</p><p class="content">我们还提供了一个表单，可以用它向集合中添加条目。</p><p class="reference"><b>code/advanced_components/app/ts/templates/for.ts</b></p><p class="daima">　&lt;div class="ui form"&gt;</p><p class="daima">　　&lt;div class="fields"&gt;</p><p class="daima">　　　&lt;div class="field"&gt;</p><p class="daima">　　　　&lt;label&gt;Name&lt;/label&gt;</p><p class="daima">　　　　&lt;input type="text" #name placeholder="Name"&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　　&lt;div class="field"&gt;</p><p class="daima">　　　　&lt;label&gt;Age&lt;/label&gt;</p><p class="daima">　　　　&lt;input type="text" #age placeholder="Age"&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　&lt;div class="ui submit button"</p><p class="daima">　　　（click）="add（name, age）"&gt;</p><p class="daima">　　Add</p><p class="daima">　&lt;/div&gt;</p><p class="sectionTitle biaoti3"><a id="sec007"></a>14.7 变更检测</p><p class="content">在用户与我们的应用交互时，数据（state）会发生改变，我们的应用需要据此作出响应。</p><p class="content">任何现代JavaScript框架都需要解决的一大问题就是：怎样才能知道发生了变化并据此重新渲染组件？</p><p class="content">为了让视图可以响应组件状态的变化，Angular使用了<b>变更检测</b>。</p><p class="content">什么可以触发组件状态的改变？最明显的就是用户交互。比如，如果我们有这样一个组件：</p><p class="daima">@Component（{</p><p class="daima">　selector：'my-component',</p><p class="daima">　template：`</p><p class="daima">　Name：{{name}}</p><p class="daima">　&lt;button（click）="changeName（）"&gt;Change！&lt;/button&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class MyComponent {</p><p class="daima">　name：string;</p><p class="daima">　constructor（）{</p><p class="daima">　　this.name = 'Felipe';</p><p class="daima">　}</p><p class="daima">　changeName（）{</p><p class="daima">　　this.name = 'Nate';</p><p class="daima">　}</p><p class="daima">}</p><p class="content">可以看到，当用户<b>点击</b>Change！按钮时，组件的name属性会发生改变。</p><p class="content">另一个变化的来源可能是HTTP请求：</p><p class="daima">@Component（{</p><p class="daima">　selector：'my-component',</p><p class="daima">　template：`</p><p class="daima">　Name：{{name}}</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class MyComponent {</p><p class="daima">　name：string;</p><p class="daima">　constructor（private http：Http）{</p><p class="daima">　　this.http.get（'/names/1'）</p><p class="daima">　　　.map（res =&gt; res.json（））</p><p class="daima">　　　.subscribe（data =&gt; this.name = data.name）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">最后，我们还可以用计时器来触发变化：</p><p class="daima">@Component（{</p><p class="daima">　selector：'my-component',</p><p class="daima">　template：`</p><p class="daima">　Name：{{name}}</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class MyComponent {</p><p class="daima">　name：string;</p><p class="daima">　constructor（）{</p><p class="daima">　　setTimeout（（）=&gt; this.name = 'Felipe', 2000）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">但是Angular要如何察觉到这些变化呢？</p><p class="content">首先要知道的是，每个组件都有自己的变更检测器。</p><p class="content">就像我们之前看到的，一个典型的应用有很多组件，组件之间会进行交互，从而创建一个如图14-32所示的依赖关系树。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19510/106/2667835266/44098/8e90966e/5b03d540Nc64eee04.jpg" class="enlarge" alt="" href="./image/a-136.jpg" /></p><p class="descrip"><b>图14-32　组件树</b></p><p class="content">对于树中的每个组件，都会创建一个变更检测器。因此，我们的变更检测器同样是一棵树（如图14-33所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t22291/311/207166878/76542/d4460449/5b03d541Nb3f63a78.jpg" class="enlarge" alt="" href="./image/a-137.jpg" /></p><p class="descrip"><b>图14-33　变更检测器树</b></p><p class="content">当一个组件发生变更时，无论它在树的什么位置，都会触发树中的所有变更检测器。这是因为Angular会从顶部节点开始，一直扫描到树的叶子节点（如图14-34所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19501/245/2680263243/50501/346fe670/5b03d540N1d51a0ff.jpg" class="enlarge" alt="" href="./image/a-138.jpg" /></p><p class="descrip"><b>图14-34　默认的变更检测方式</b></p><p class="content">在上面的图中，深灰色的组件发生了变化。但是，正如我们所见，它触发了整棵组件树中的检查。被检查的组件用浅灰色表示（注意，引起变化的组件本身也被检查了）。</p><p class="content">直觉上，你可能会认为这种方式的开销非常大；然而实际上，由于经过大量的优化（这使得Angular代码可以被JavaScript引擎进一步优化），它的速度快得惊人。</p><p class="listTitle1 biaoti8">14.7.1 自定义变更检测</p><p class="content">有时，默认的变更检测机制可能有些大材小用。比如，你可能使用了不可改变对象或者应用的数据架构是依赖可观察对象的。在这些场景下，Angular提供了可以自定义变更检测系统的机制，可以使检测变得非常快。</p><p class="content">修改变更检测器行为的第一种方式是告诉组件：只有当它的输入属性值发生改变时才需要去检查。</p><p class="content">简单来说，输入属性值就是组件从外部接收的属性。比如，在这段代码中：</p><p class="daima">class Person {</p><p class="daima">　constructor（public name：string, public age：string）{}</p><p class="daima">}</p><p class="daima">@Component（{</p><p class="daima">　selector：'mycomp',</p><p class="daima">　template：`</p><p class="daima">　　&lt;div&gt;</p><p class="daima">　　　&lt;span class="name"&gt;{person.name}&lt;/span&gt;</p><p class="daima">　　　is {person.age} years old.</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">class MyComp {</p><p class="daima">　@Input（）person：Person;</p><p class="daima">}</p><p class="content">我们有一个输入属性person。现在，如果只想在输入属性发生变化时才让组件改变，只要修改变更检测策略，把changeDetection设置成ChangeDetectionStrategy.OnPush就可以了。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　顺便一提，changeDetection的默认值是ChangeDetectionStrategy.Default。</p><p class="content">我们写两个组件来做个小实验。第一个组件使用默认的变更检测行为，而另外一个组件使用OnPush策略。</p><p class="reference"><b>code/advanced_components/app/ts/change-detection/onpush.ts</b></p><p class="daima">import {</p><p class="daima">　Component,</p><p class="daima">　Input,</p><p class="daima">　ChangeDetectionStrategy,</p><p class="daima">} from '@angular/core';</p><p class="daima">class Profile {</p><p class="daima">　constructor（private first：string, private last：string）{}</p><p class="daima">　lastChanged（）{</p><p class="daima">　　return new Date（）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">我们先导入一些东西，然后声明Person类。Person类会作为这两个组件的输入属性。注意，我们还在Profile类中创建了一个lastChange（）方法。这个方法非常有用，可以决定何时触发变更检测。当把一个给定的组件标记为需要检查时，这个方法就会被调用，然后呈现在模板中。因此，该方法可以准确地表明组件的最后检查时间。</p><p class="content">接下来，我们声明了DefaultCmp组件，它将使用默认变更检测策略。</p><p class="reference"><b>code/advanced_components/app/ts/change-detection/onpush.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'default',</p><p class="daima">　template：`</p><p class="daima">　&lt;h4 class="ui horizontal divider header"&gt;</p><p class="daima">　　Default Strategy</p><p class="daima">　&lt;/h4&gt;</p><p class="daima">　&lt;form class="ui form"&gt;</p><p class="daima">　　&lt;div class="field"&gt;</p><p class="daima">　　　&lt;label&gt;First Name&lt;/label&gt;</p><p class="daima">　　　&lt;input</p><p class="daima">　　　　type="text"</p><p class="daima">　　　　[（ngModel）]="profile.first"</p><p class="daima">　　　　name="first"</p><p class="daima">　　　　placeholder="First Name"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　　&lt;div class="field"&gt;</p><p class="daima">　　　 &lt;label&gt;Last Name&lt;/label&gt;</p><p class="daima">　　　 &lt;input</p><p class="daima">　　　　 type="text"</p><p class="daima">　　　　 [（ngModel）]="profile.last"</p><p class="daima">　　　　 name="last"</p><p class="daima">　　　　 placeholder="Last Name"&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/form&gt;</p><p class="daima">　&lt;div&gt;</p><p class="daima">　　{{profile.lastChanged（）| date：'medium'}}</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class DefaultCmp {</p><p class="daima">　@Input（）profile：Profile;</p><p class="daima">}</p><p class="content">第二个组件使用OnPush策略。</p><p class="reference"><b>code/advanced_components/app/ts/change-detection/onpush.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'on-push',</p><p class="daima">　changeDetection：ChangeDetectionStrategy.OnPush,</p><p class="daima">　template：`</p><p class="daima">　&lt;h4 class="ui horizontal divider header"&gt;</p><p class="daima">　　OnPush Strategy</p><p class="daima">　&lt;/h4&gt;</p><p class="daima">　　&lt;form class="ui form"&gt;</p><p class="daima">　　　&lt;div class="field"&gt;</p><p class="daima">　　　　&lt;label&gt;First Name&lt;/label&gt;</p><p class="daima">　　　　&lt;input</p><p class="daima">　　　　　type="text"</p><p class="daima">　　　　　[（ngModel）]="profile.first"</p><p class="daima">　　　　　name="first"</p><p class="daima">　　　　　placeholder="First Name"&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　　&lt;div class="field"&gt;</p><p class="daima">　　　　&lt;label&gt;Last Name&lt;/label&gt;</p><p class="daima">　　　　&lt;input</p><p class="daima">　　　　　type="text"</p><p class="daima">　　　　　[（ngModel）]="profile.last"</p><p class="daima">　　　　　name="last"</p><p class="daima">　　　　　placeholder="Last Name"&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　&lt;/form&gt;</p><p class="daima">　　&lt;div&gt;</p><p class="daima">　　　{{profile.lastChanged（）| date：'medium'}}</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class OnPushCmp {</p><p class="daima">　@Input（）profile：Profile;</p><p class="daima">}</p><p class="content">正如我们所见，两个组件使用相同的模板。唯一不同的就是注解中的变更检测策略。</p><p class="content">最后，我们添加一个组件来并排渲染两个组件。</p><p class="reference"><b>code/advanced_components/app/ts/change-detection/onpush.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'change-detection-sample-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui page grid"&gt;</p><p class="daima">　　&lt;div class="two column row"&gt;</p><p class="daima">　　　&lt;div class="column area"&gt;</p><p class="daima">　　　　&lt;default [profile]="profile1"&gt;&lt;/default&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　　&lt;div class="column area"&gt;</p><p class="daima">　　　　&lt;on-push [profile]="profile2"&gt;&lt;/on-push&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class OnPushChangeDetectionSampleApp {</p><p class="daima">　profile1：Profile = new Profile（'Felipe', 'Coury'）;</p><p class="daima">　profile2：Profile = new Profile（'Nate', 'Murray'）;</p><p class="daima">}</p><p class="content">运行这个应用时，我们会看到两个组件如图14-35这样被渲染出来。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t21832/255/218266153/57738/41d65b24/5b03d541Neb64238b.jpg" class="enlarge" alt="" href="./image/a-139.jpg" /></p><p class="descrip"><b>图14-35　默认策略与OnPush策略</b></p><p class="content">当我们更改左边的组件（使用默认策略）时，可以注意到右边组件的时间戳并没有发生改变，如图14-36所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17506/335/2635624750/65645/2a3c645/5b03d541Nab30ecf7.jpg" class="enlarge" alt="" href="./image/a-140.jpg" /></p><p class="descrip"><b>图14-36　默认的组件变化时，OnPush的组件不会检查</b></p><p class="content">要理解为何如此，我们来检查下这个新的组件树（如图14-37所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20302/13/224123014/31216/1d1386af/5b03d541N04d652a6.jpg" class="enlarge" alt="" href="./image/a-141.jpg" /></p><p class="descrip"><b>图14-37　新组件树</b></p><p class="content">Angular对于变化的检查是自上而下的，所以首先查询的是ChangeDetectionSampleApp，然后是DefaultCmp，最后是OnPushCmp。当它推测出OnPushCmp发生变化时，就会自上而下地更新组件树中的所有组件，这会导致重新渲染DefaultCmp。</p><p class="content">当我们改变右边组件的值时，如图14-38所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20662/183/192660789/66543/3bdb3e1c/5b03d541N2fa6bbd1.jpg" class="enlarge" alt="" href="./image/a-142.jpg" /></p><p class="descrip"><b>图14-38　OnPush的组件变化时，默认的组件也会检查</b></p><p class="content">变更检测引擎生效后，只检查了DefaultCmp组件而没有检查OnPushCmp。这是因为当我们为组件设置了OnPush策略时，只有它自己的输入发生变化时才执行检测。改变组件树中的其他组件时并不会触发这个组件变更检测器。</p><p class="listTitle1 biaoti8">14.7.2 Zones</p><p class="content">在底层，Angular使用了一个名叫Zones的类库，它可以自动检测变化并触发变更检测机制。在一些最常见的情景下，Zones会自动告诉Angular发生了某些变化：</p><p class="content">●当DOM事件发生时（比如click、change等）；</p><p class="content">●当HTTP请求完成时；</p><p class="content">●当定时器被触发时（setTimeout或setInterval）。</p><p class="content">然而，还有一些场景是Zones无法自动识别出变化的。在这些场景下，OnPush策略就会变得非常有用。</p><p class="content">下面是一些Zones无法掌控的例子：</p><p class="content">●使用异步方式运行第三方类库；</p><p class="content">●不可变的数据；</p><p class="content">●可观察对象。</p><p class="content">在这些情况下，非常适合通过OnPush以及一点小技巧去手动提示Angular有东西发生了变化。</p><p class="listTitle1 biaoti8">14.7.3 可观察对象和OnPush</p><p class="content">我们来编写一个组件，它接收一个<b>可观察对象</b>作为参数。每当从这个可观察对象中接收到值时，我们就会增加组件的计数器属性。</p><p class="content">如果使用常规的变更检测策略，那么只要我们增加计数，Angular就会触发变更检测。然而，这个组件将使用OnPush策略，只有当计数是5的倍数或者可观察对象完成时，我们才让变更检测器生效，而不是每次增加计数时都触发变更检测器。</p><p class="content">要做到这一点，我们来写个组件。</p><p class="reference"><b>code/advanced_components/app/ts/change-detection/observables.ts</b></p><p class="daima">import {</p><p class="daima">　Component,</p><p class="daima">　Input,</p><p class="daima">　ChangeDetectorRef,</p><p class="daima">　ChangeDetectionStrategy</p><p class="daima">} from '@angular/core';</p><p class="daima">import { Observable } from 'rxjs/Rx';</p><p class="daima">@Component（{</p><p class="daima">　selector：'observable',</p><p class="daima">　changeDetection：ChangeDetectionStrategy.OnPush,</p><p class="daima">　template：`</p><p class="daima">　&lt;div&gt;</p><p class="daima">　　&lt;div&gt;Total items：{{counter}}&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class ObservableCmp {</p><p class="daima">　@Input（）items：Observable&lt;number&gt;;</p><p class="daima">　counter = 0;</p><p class="daima">　constructor（private changeDetector：ChangeDetectorRef）{</p><p class="daima">　}</p><p class="daima">　ngOnInit（）{</p><p class="daima">　　this.items.subscribe（（v）=&gt; {</p><p class="daima">　　　console.log（'got value', v）;</p><p class="daima">　　　this.counter++;</p><p class="daima">　　　if（this.counter ％ 5 == 0）{</p><p class="daima">　　　　this.changeDetector.markForCheck（）;</p><p class="daima">　　　}</p><p class="daima">　　},</p><p class="daima">　　null,</p><p class="daima">　　（）=&gt; {</p><p class="daima">　　　this.changeDetector.markForCheck（）;</p><p class="daima">　　}）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">我们将代码分解来看，以确保理解正确。首先，我们声明该组件接收items作为输入属性并使用OnPush作为变更检测策略。</p><p class="reference"><b>code/advanced_components/app/ts/change-detection/observables.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'observable',</p><p class="daima">　changeDetection：ChangeDetectionStrategy.OnPush,</p><p class="daima">　template：`</p><p class="daima">　&lt;div&gt;</p><p class="daima">　　&lt;div&gt;Total items：{{counter}}&lt;/div&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="content">接下来，我们把输入属性存储在组件类的items属性中，然后设置另一个属性counter为0。</p><p class="reference"><b>code/advanced_components/app/ts/change-detection/observables.ts</b></p><p class="daima">export class ObservableCmp {</p><p class="daima">　@Input（）items：Observable&lt;number&gt;;</p><p class="daima">　counter = 0;</p><p class="content">然后，我们使用构造函数来取得组件的变更检测器。</p><p class="reference"><b>code/advanced_components/app/ts/change-detection/observables.ts</b></p><p class="daima">　constructor（private changeDetector：ChangeDetectorRef）{</p><p class="daima">　}</p><p class="content">然后，当组件初始化时，在ngOnInit钩子中如下所示。</p><p class="reference"><b>code/advanced_components/app/ts/change-detection/observables.ts</b></p><p class="daima">　ngOnInit（）{</p><p class="daima">　　this.items.subscribe（（v）=&gt; {</p><p class="daima">　　　console.log（'got value', v）;</p><p class="daima">　　　this.counter++;</p><p class="daima">　　　if（this.counter ％ 5 == 0）{</p><p class="daima">　　　　this.changeDetector.markForCheck（）;</p><p class="daima">　　　}</p><p class="daima">　　},</p><p class="daima">　　null,</p><p class="daima">　　（）=&gt; {</p><p class="daima">　　　this.changeDetector.markForCheck（）;</p><p class="daima">　　}）;</p><p class="daima">　}</p><p class="content">我们订阅了可观察对象。subscribe方法接收三个回调函数：onNext、onError和onCompleted。</p><p class="content">onNext回调函数会打印出我们得到的值，然后增加计数。最后，如果当前计数器的值是5的倍数，我们就调用变更检测器的markForCheck方法。只要我们想告诉Angular已经发生了变化，就可以使用这个方法，从而使变更检测器生效。</p><p class="content">对于onError回调函数，我们传入了null。这表示我们不想处理这个场景。</p><p class="content">最后，对于onComplete回调函数，我们同样触发了变更检测器，所以最终的计数器可以被显示出来。</p><p class="content">现在来看应用组件的代码。它会创建订阅者。</p><p class="reference"><b>code/advanced_components/app/ts/change-detection/observables.ts</b></p><p class="daima">@Component（{</p><p class="daima">　selector：'change-detection-sample-app',</p><p class="daima">　template：`</p><p class="daima">　&lt;observable [items]="itemObservable"&gt;&lt;/observable&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class ObservableChangeDetectionSampleApp {</p><p class="daima">　itemObservable：Observable&lt;number&gt;;</p><p class="daima">　constructor（）{</p><p class="daima">　　this.itemObservable = Observable.timer（100, 100）.take（101）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">下面这行代码很重要：</p><p class="daima">this.itemObservable = Observable.timer（100, 100）.take（101）;</p><p class="content">这一行创建了一个可观察对象，我们会通过items输入属性将这个可观察对象传递进组件。timer方法有两个参数：第一个是等待的毫秒数，第二个是间隔的毫秒数。因此，这个可观察对象会创建一系列的值。</p><p class="content">因为我们不需要一直创建下去，所以使用了take函数，只获取前101个值。</p><p class="content">当我们运行这段代码时，会发现每取到5个值才会更新一次计数器，并且生成了一个最终值101（如图14-39所示）。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18067/187/2624601909/67520/e9e6be59/5b03d541N7608c191.jpg" class="enlarge" alt="" href="./image/a-143.jpg" /></p><p class="descrip"><b>图14-39　手动触发变更检测</b></p><p class="sectionTitle biaoti3"><a id="sec008"></a>14.8 总结</p><p class="content">Angular为我们提供了许多可以用来编写高级组件的工具。使用本章的这些技术，你几乎能写出任何想要的组件功能。</p><p class="content">然而，在高级组件中还有一个重要的概念，那就是依赖注入。</p><p class="content">使用依赖注入，我们可以让组件和系统中的很多其他部分挂接起来。第8章详细讨论了什么是依赖注入，如何在应用中使用它，以及注入服务的常用模式。</p><ol class="mz-footnote"><li id="footnote1">http：//semantic-ui.com/modules/tab.html#/examples</li><li id="footnote2">https：//angular.io/docs/ts/latest/guide/lifecycle-hooks.html</li></ol></body></html>