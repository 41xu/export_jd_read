<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><link rel="stylesheet" type="text/css" href="http://storage.360buyimg.com/ebooks/9fd8bb77eb40456b746aaae41785499a_new_.css" /><title>第5章 Angular中的表单</title></head><body><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17287/319/2626049641/45910/18d9def1/5b03d541Nae5bee61.jpg" class="fullscreen" alt="" href="./image/Figure-05.jpg" /></p><p class="sectionTitle biaoti3"><a id="sec001"></a>5.1 表单——既重要，又复杂</p><p class="content">在Web应用中，表单或许是最重要的部分。虽然我们常从点击链接或移动鼠标中得到事件通知，但大多数“富数据”都是通过<b>表单</b>从用户那里获得的。</p><p class="content">从表面上看，表单似乎很简单：创建一个input标签，用户填入数据，然后再点击提交。这有什么难的？</p><p class="content">但事实证明，表单最终可能是非常复杂的。原因如下：</p><p class="content">●表单输入意味着需要在页面和服务器端同时修改这份数据；</p><p class="content">●修改的内容通常要在页面的其他地方反映出来；</p><p class="content">●用户的输入可能存在很多问题，所以需要验证输入的内容；</p><p class="content">●用户界面需要清晰地显示出可能出现的预期结果和错误信息；</p><p class="content">●字段之间的依赖可能存在复杂的业务逻辑；</p><p class="content">●我们希望不依赖DOM选择器就能轻松测试表单。</p><p class="content">值得庆幸的是，Angular已经给出了上述所有问题的解决方案。</p><p class="content">●<b>表单控件</b>（FormControl）封装了表单中的输入，并提供了一些可供操纵的对象。</p><p class="content">●<b>验证器</b>（validator）让我们能以自己喜欢的任何方式验证表单输入。</p><p class="content">●<b>观察者</b>（observer）让我们能够监听表单的变化，并作出相应的回应。</p><p class="content">在本章中，我们将一步一步构建表单应用。先构建一些简单的表单，然后构建逻辑更复杂的表单。</p><p class="sectionTitle biaoti3"><a id="sec002"></a>5.2 FormControl和FormGroup</p><p class="content">FormControl和FormGroup是Angular中两个最基础的表单对象。</p><p class="listTitle1 biaoti8">5.2.1 FormControl</p><p class="content">FormControl代表单一的输入字段，它是Angular表单中的最小单元。</p><p class="content">FormControl封装了这些字段的值和状态，比如是否有效、是否脏（被修改过）或是否有错误等。</p><p class="content">比如，下列代码演示了如何在TypeScript中使用FormControl：</p><p class="daima">// create a new FormControl with the value "Nate"</p><p class="daima">let nameControl = new FormControl（"Nate"）;</p><p class="daima">let name = nameControl.value; // -&gt; Nate</p><p class="daima">// now we can query this control for certain values：</p><p class="daima">nameControl.errors // -&gt; StringMap&lt;string, any&gt; of errors</p><p class="daima">nameControl.dirty　// -&gt; false</p><p class="daima">nameControl.valid　// -&gt; true</p><p class="daima">// etc.</p><p class="content">为了构建表单，我们会创建几组FormControl对象，然后为它们附加元数据和逻辑。</p><p class="content">在Angular中，我们经常将一个类（本例中为FormControl）以属性形式（本例中为formControl）附加在DOM上。比如下面这个表单：</p><p class="daima">&lt;！—— part of some bigger form ——&gt;</p><p class="daima">&lt;input type="text" [formControl]="name" /&gt;</p><p class="content">这会在此form的上下文中创建一个新的FormControl对象。稍后我们会进一步讨论它的工作原理。</p><p class="listTitle1 biaoti8">5.2.2 FormGroup</p><p class="content">大多数表单都拥有不止一个字段，因此我们需要某种方式来管理多个FormControl。假设我们要检查表单的有效性。如果要遍历这个FormControl数组并检查每一个FormControl是否有效，必然相当繁琐；而FormGroup则可以为一组FormControl提供总包接口（wrapper interface），来解决这种问题。</p><p class="content">下面是FormGroup的创建方式：</p><p class="daima">let personInfo = new FormGroup（{</p><p class="daima">　　firstName：new FormControl（"Nate"）,</p><p class="daima">　　lastName：new FormControl（"Murray"）,</p><p class="daima">　　zip：new FormControl（"90210"）</p><p class="daima">}）</p><p class="content">FormGroup和FormControl都继承自同一个祖先AbstractControl<sup><a class="mz-footnote-link" href="#footnote1"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>。这意味检查personInfo的状态或值就像检查单个FormControl那么容易：</p><p class="daima">personInfo.value; // -&gt; {</p><p class="daima">//　 firstName："Nate",</p><p class="daima">//　 lastName："Murray",</p><p class="daima">//　 zip："90210"</p><p class="daima">// }</p><p class="daima">// now we can query this control group for certain values, which have sensible</p><p class="daima">// values depending on the children FormControl's values：</p><p class="daima">personInfo.errors // -&gt; StringMap&lt;string, any&gt; of errors</p><p class="daima">personInfo.dirty　// -&gt; false</p><p class="daima">personInfo.valid　// -&gt; true</p><p class="daima">// etc.</p><p class="content">注意，当我们试图从FormGroup中获取value时，会收到一个“键值对”结构的<b>对象</b>。它能让我们从表单中一次性获取全部的值而无需逐一遍历FormControl，使用起来相当顺手。</p><p class="sectionTitle biaoti3"><a id="sec003"></a>5.3 我们的第一个表单</p><p class="content">创建表单的方式很多，而且好几种重要的方式我们还没有讨论到。先来看一个完整的例子，稍后再一一解释。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　本节的所有示例代码都可以在forms/目录下找到。</p><p class="content">我们要构建的第一个表单，效果如图5-1所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19930/45/634948397/18412/67bbec43/5b03d541N16823681.jpg" class="enlarge" alt="" href="./image/a-41.jpg" /></p><p class="descrip"><b>图5-1　带SKU的表单演示：简易版</b></p><p class="content">假设我们要构建一个电子商务网站来展示并销售一些产品。在此应用中需要存储产品的SKU，因此先来创建一个只有SKU输入框的简易表单。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　SKU是库存单位（stockkeeping unit）的缩写。它是用来跟踪产品库存的唯一编号。当我们提到SKU时，指的是人类可读的产品编码。</p><p class="content">这个表单超级简单：只有一个sku（带label）输入框和一个提交按钮。</p><p class="content">我们先把表单变为组件。你应该还记得，定义组件需要包含以下三个部分：</p><p class="content">●配置@Component（）注解；</p><p class="content">●创建模板；</p><p class="content">●在组件定义类中实现自定义功能。</p><p class="content">下面来依次实现它们。</p><p class="listTitle1 biaoti8">5.3.1 加载FormsModule</p><p class="content">为了使用这个新的表单库，先要确保我们的NgModule中导入了这个表单库。</p><p class="content">Angular中有两种使用表单的方式，我们在本章中都会展开讨论：使用FormsModule以及使用ReactiveFormsModule。既然都要用到，那么这个模块就同时导入它们。因此需要在引用启动程序app.ts中这样写：</p><p class="daima">import {</p><p class="daima">　FormsModule,</p><p class="daima">　ReactiveFormsModule</p><p class="daima">} from '@angular/forms';</p><p class="daima">// farther down……</p><p class="daima">@NgModule（{</p><p class="daima">　declarations：[</p><p class="daima">　　FormsDemoApp,</p><p class="daima">　　DemoFormSku,</p><p class="daima">　　// …… our declarations here</p><p class="daima">　],</p><p class="daima">　imports：[</p><p class="daima">　　BrowserModule,</p><p class="daima">　　FormsModule,　　　　 // &lt;—— add this</p><p class="daima">　　ReactiveFormsModule　// &lt;—— and this</p><p class="daima">　],</p><p class="daima">　bootstrap：[ FormsDemoApp ]</p><p class="daima">}）</p><p class="daima">class FormsDemoAppModule {}</p><p class="content">这确保了我们能在视图中使用Angular表单指令。先简要介绍一下，FormsModule为我们提供了一些<b>模板驱动</b>的指令，例如：</p><p class="content">●ngModel</p><p class="content">●NgForm</p><p class="content">ReactiveFormsModule则提供了下列指令：</p><p class="content">●formControl</p><p class="content">●ngFormGroup</p><p class="content">此外，还有很多指令。我们还没有讨论过如何使用这些指令以及它们是做什么的，但很快就要讲到了。现在只需要知道把FormsModule和ReactiveFormsModule导入到我们的NgModule中就行了。这表示我们能在视图中使用上述所有指令，并能在组件中<b>注入相应的服务</b>。</p><p class="listTitle1 biaoti8">5.3.2 简易SKU表单：@Component注解</p><p class="content">现在我们就可以开始创建组件了。</p><p class="reference"><b>code/forms/app/forms/demo_form_sku.ts</b></p><p class="daima">import { Component } from '@angular/core';</p><p class="daima">@Component（{</p><p class="daima">　selector：'demo-form-sku',</p><p class="content">这里定义了一个demo-form-sku的选择器（selector）。还记得吧？selector会告诉Angular，组件将绑定到哪些元素上。这里我们可以通过demo-form-sku标签来使用这个组件：</p><p class="daima">&lt;demo-form-sku&gt;&lt;/demo-form-sku&gt;</p><p class="listTitle1 biaoti8">5.3.3 简易SKU表单：template</p><p class="content">我们来看看template。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_sku.ts</b></p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui raised segment"&gt;</p><p class="daima">　　&lt;h2 class="ui header"&gt;Demo Form：Sku&lt;/h2&gt;</p><p class="daima">　　&lt;form #f="ngForm"</p><p class="daima">　　　　　（ngSubmit）="onSubmit（f.value）"</p><p class="daima">　　　　　class="ui form"&gt;</p><p class="daima">　　　&lt;div class="field"&gt;</p><p class="daima">　　　　&lt;label for="skuInput"&gt;SKU&lt;/label&gt;</p><p class="daima">　　　　&lt;input type="text"</p><p class="daima">　　　　　　　 id="skuInput"</p><p class="daima">　　　　　　　 placeholder="SKU"</p><p class="daima">　　　　　　　 name="sku" ngModel&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　　&lt;button type="submit" class="ui button"&gt;Submit&lt;/button&gt;</p><p class="daima">　　&lt;/form&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="content">●<b>form和NgForm</b></p><p class="content">现在事情开始变得有趣了：我们导入了FormsModule，因此可以在视图中使用NgForm了。记住，当这些指令在视图中可用时，它就会被附加到任何能匹配其selector的节点上。</p><p class="content">NgForm做了一件便利但隐晦的工作：它的选择器包含form 标签（而不用显式添加ngForm属性）。这意味着当我们导入FormsModule时候，NgForm就会被自动附加到视图中所有的&lt;form&gt;标签上。这确实非常有用，但由于它发生在幕后，也许会让很多人感到困惑。</p><p class="content">NgForm给我们提供了两个重要的功能：</p><p class="content">（1）一个名叫ngForm的FormGroup对象；</p><p class="content">（2）一个输出事件（ngSubmit）。</p><p class="content">你可以看到我们在视图的&lt;form&gt;标签中同时用到了它们两个。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_sku.ts</b></p><p class="daima">　　&lt;form #f="ngForm"</p><p class="daima">　　　　　（ngSubmit）="onSubmit（f.value）"</p><p class="content">首先，我们使用了#f="ngForm"。#v=thing语法的意思是，我们希望在当前视图中创建一个局部变量。</p><p class="content">这里我们为视图中的ngForm创建了一个别名，并绑定到变量#f。这个ngForm来自哪里呢？它是由NgForm指令导出的。</p><p class="content">ngForm是什么类型的对象呢？它是FormGroup类型的。这意味着我们可以在视图中把变量f当作FormGroup使用，而这也正是我们在输出事件（ngSubmit）中的使用方法。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="enlarge" alt="" href="./image/a-3.jpg" /></p><p class="content">细心的读者可能会注意到，上面提到NgForm会自动附加到&lt;form&gt;标签上（因为NgForm指令的选择器中默认包含了form），这意味着我们不必添加ngForm属性就能使用NgForm指令。但是这里我们也将ngForm添加到了属性的值上。这是笔误吗？</p><p class="content">不，这不是笔误。如果ngForm是属性的键，那就是在告诉Angular：我们要根据这个属性使用NgForm指令。但在这里，我们要对一个<b>引用</b>赋值，而把ngForm用作<b>属性值</b>。这表示把ngForm这个表达式的执行结果赋值给局部模板变量f。</p><p class="content">既然ngForm在这个节点上，你应该可以推断出我们正在导出的这个f变量是FormGroup类型的，接下来就可以在视图中的任何地方引用它了。</p><p class="content">我们在表单中绑定ngSubmit事件的语法是：（ngSubmit）="onSubmit（f.value）"。</p><p class="content">●（ngSubmit）：来自NgForm指令。</p><p class="content">●onSubmit（）：将会在我们的组件类中进行定义（稍后）。</p><p class="content">●f.value：f就是我们前面提到的FormGroup，而.value会以键值对的形式返回FormGroup中所有控件的值。</p><p class="content">总结起来，这行代码的意思是：“当我提交表单时，将会以该表单的值作为参数，调用组件实例上的onSubmit方法。”</p><p class="content">●<b>input和NgModel</b></p><p class="content">在讨论NgModel之前，关于input标签还有几点需要说明。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_sku.ts</b></p><p class="daima">　　&lt;form #f="ngForm"</p><p class="daima">　　　　　（ngSubmit）="onSubmit（f.value）"</p><p class="daima">　　　　　class="ui form"&gt;</p><p class="daima">　　　&lt;div class="field"&gt;</p><p class="daima">　　　　&lt;label for="skuInput"&gt;SKU&lt;/label&gt;</p><p class="daima">　　　　&lt;input type="text"</p><p class="daima">　　　　　　　 id="skuInput"</p><p class="daima">　　　　　　　 placeholder="SKU"</p><p class="daima">　　　　　　　 name="sku" ngModel&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="content">●class="ui form"和class="field"是两个可选的类。它们来自CSS框架Semantic UI<sup><a class="mz-footnote-link" href="#footnote2"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>。它们并不属于Angular的范畴，在这里加上它们只是为了让本例子好看一些。</p><p class="content">●label标签的for属性和input标签的id属性是一致的，这依据的是W3C标准<sup><a class="mz-footnote-link" href="#footnote3"><img alt="" src="https://img30.360buyimg.com/ebookadmin/jfs/t21616/337/214486965/1481/90828627/5b03d540N24da8434.png" href="./image/icon_note.png" /></a></sup>。</p><p class="content">●我们设置SKU控件的placeholder属性，将其作为input值为空时给用户的提示。</p><p class="content">NgModel指令指定的selector是ngModel。这意味着我们可以通过添加这个属性把它附加到input标签上：ngModel="whatever"。在这里我们指定了一个不带属性值的ngModel。</p><p class="content">有两种不同的方法能在模板中指定ngModel，这里是第一种。当使用不带属性值的ngModel时，我们是要指定：</p><p class="content">（1）单向数据绑定；</p><p class="content">（2）希望在表单中创建一个名为sku的FormControl（这个sku来自input标签上的name属性）。</p><p class="content">NgModel会<b>创建一个新的</b>FormControl对象，把它<b>自动添加到</b>父FormGroup上（这里也就是form表单对象），并把这个FormControl对象绑定到一个DOM上。也就是说，它会在视图中的input标签和FormControl对象之间建立关联。这种关联是通过name属性建立的，在本例中是"sku"。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="enlarge" alt="" href="./image/a-3.jpg" /></p><p class="content">NgModel与ngModel有什么不同呢? 通常，我们使用Pascal命名法（如NgModel）时，指的是<b>类</b>和供代码中引用的对象。首字母小写的驼峰命名法（如ngModel）来自指令的选择器 selector，并且只会被用在DOM/模板中。</p><p class="content">需要指出的是，NgModel和FormControl并不是同一个。NgModel是用在视图中的指令，而FormControl则用来表示表单中的数据和验证规则。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="inline1" alt="" href="./image/a-9.jpg" />有时，我们希望用ngModel来实现AngularJS那样的<b>双向绑定</b>。在本章的最后，我们会看到如何进行实现。</p><p class="listTitle1 biaoti8">5.3.4 简易SKU表单：组件定义类</p><p class="content">现在来看看组件类的定义。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_sku.ts</b></p><p class="daima">export class DemoFormSku {</p><p class="daima">　onSubmit（form：any）：void {</p><p class="daima">　　console.log（'you submitted value：', form）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">在这里，我们的类定义了一个名为onSubmit的方法，该方法会在表单提交时调用。目前我们只用console.log打印出传进去的值。</p><p class="listTitle1 biaoti8">5.3.5 试试看</p><p class="content">全部代码如下所示。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_sku.ts</b></p><p class="daima">import { Component } from '@angular/core';</p><p class="daima">@Component（{</p><p class="daima">　selector：'demo-form-sku',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui raised segment"&gt;</p><p class="daima">　　&lt;h2 class="ui header"&gt;Demo Form：Sku&lt;/h2&gt;</p><p class="daima">　　&lt;form #f="ngForm"</p><p class="daima">　　　　　（ngSubmit）="onSubmit（f.value）"</p><p class="daima">　　　　　class="ui form"&gt;</p><p class="daima">　　　&lt;div class="field"&gt;</p><p class="daima">　　　　&lt;label for="skuInput"&gt;SKU&lt;/label&gt;</p><p class="daima">　　　　&lt;input type="text"</p><p class="daima">　　　　　　　 id="skuInput"</p><p class="daima">　　　　　　　 placeholder="SKU"</p><p class="daima">　　　　　　　 name="sku" ngModel&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　　&lt;button type="submit" class="ui button"&gt;Submit&lt;/button&gt;</p><p class="daima">　　&lt;/form&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class DemoFormSku {</p><p class="daima">　onSubmit（form：any）：void {</p><p class="daima">　　console.log（'you submitted value：', form）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">如果打开浏览器运行代码，结果如图5-2所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17497/104/2603482834/56284/1fe31d9/5b03d540N1e27c976.jpg" class="enlarge" alt="" href="./image/a-42.jpg" /></p><p class="descrip"><b>图5-2　带SKU的表单演示：简易版，已提交</b></p><p class="sectionTitle biaoti3"><a id="sec004"></a>5.4 使用FormBuilder</p><p class="content">使用ngForm和ngControl隐式构建FormControl和FormGroup确实很方便，但无法为我们提供更多定制化选项。使用FormBuilder构建表单则是一种更为灵活和通用的方式。</p><p class="content">FormBuilder是一个名副其实的表单构建助手。你应该还记得，表单是由FormControl和FormGroup构成的，而FormBuilder则可以帮助我们创建它们（你可以把它看作一个“工厂”对象）。</p><p class="content">让我们在先前的例子中添加一个FormBuilder，看看：</p><p class="content">●如何在组件定义类中使用FormGroup；</p><p class="content">●如何在视图表单中使用自定义的FormGroup。</p><p class="sectionTitle biaoti3"><a id="sec005"></a>5.5 响应式表单FormBuilder</p><p class="content">我们将使用formGroup和formControl指令来构建这个组件，这意味着我们需要导入相应的类。导入的代码如下所示。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_sku_with_builder.ts</b></p><p class="daima">import { Component } from '@angular/core';</p><p class="daima">import {</p><p class="daima">　FormBuilder,</p><p class="daima">　FormGroup</p><p class="daima">} from '@angular/forms';</p><p class="daima">@Component（{</p><p class="daima">　selector：'demo-form-sku-builder',</p><p class="listTitle1 biaoti8">5.5.1 使用FormBuilder</p><p class="content">通过在组件类上声明带参数的constructor，我们注入了一个FormBuilder。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_sku_with_builder.ts</b></p><p class="daima">export class DemoFormSkuBuilder {</p><p class="daima">　myForm：FormGroup;</p><p class="daima">　constructor（fb：FormBuilder）{</p><p class="daima">　　this.myForm = fb.group（{</p><p class="daima">　　　'sku'：['ABC123']</p><p class="daima">　　}）;</p><p class="daima">　}</p><p class="daima">　onSubmit（value：string）：void {</p><p class="daima">　　console.log（'you submitted value：', value）;</p><p class="daima">　}</p><p class="daima">}</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17728/48/2715397358/11728/16045511/5b03d541N9720f866.jpg" class="enlarge" alt="" href="./image/a-4.jpg" /></p><p class="content"><b>注入意味着什么?</b> 我们还未曾深入讨论过依赖注入（dependency injection，DI）以及DI是如何关联到继承树的，因此你可能看不太懂最后这句话。我们在第8章中讨论了很多关于依赖注入的知识，如果你希望深入学习，请移步那里。</p><p class="content">大体来说，依赖注入就是用来告诉Angular，为了让组件正常运行需要给它哪些依赖。</p><p class="content">在这期间，Angular将会注入一个从FormBuilder类创建的对象实例，并把它赋值给fb变量（来自构造函数）。</p><p class="content">我们将会使用FormBuilder中的两个主要函数：</p><p class="content">●control，用于创建一个新的FormControl；</p><p class="content">●group，用于创建一个新的FormGroup。</p><p class="content">注意，我们在类中创建了一个名叫myForm的<b>实例变量</b>。（简单起见，确实也可以把它称作form，但这里是为了区分FormGroup和之前的form表单。）</p><p class="content">myForm是FormGroup类型。我们通过调用fb.group（）来创建FormGroup。.group方法的参数是代表组内各个FormControl的键值对。</p><p class="content">在这里，我们设置了一个名为sku的控件，其值为["ABC123"]——意思是控件的默认值为"ABC123"。（你可能注意到了这里用的是数组。这是因为我们稍后还会添加更多配置项。）</p><p class="content">现在我们就能在视图中使用myForm了。（也就是说，我们需要将它<b>绑定</b>到表单元素上。）</p><p class="listTitle1 biaoti8">5.5.2 在视图中使用myForm</p><p class="content">我们希望修改&lt;form&gt;标签，让它使用myForm变量。回忆一下，在上一节中我们提到过，当导入FormsModule时，ngForm就会自动起作用。还提到过ngForm会自动创建它自己的FormGroup。但在这里我们<b>不希望</b>使用外部的FormGroup，而是使用FormBuilder创建的这个myForm实例变量。那该怎么做呢？</p><p class="content">Angular提供了另一个指令，能让我们使用<b>现有的</b>FormGroup。它叫作formGroup，可以这样使用。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_sku_with_builder.ts</b></p><p class="daima">　　&lt;h2 class="ui header"&gt;Demo Form：Sku with Builder&lt;/h2&gt;</p><p class="daima">　　&lt;form [formGroup]="myForm"</p><p class="content">这里我们告诉Angular，想用myForm作为这个表单的FormGroup。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t18559/108/2587195628/17417/8ceb743d/5b03d540N559a889f.jpg" class="enlarge" alt="" href="./image/a-9.jpg" /></p><p class="content">我们说过，当使用FormsModule时，NgForm会自动应用于&lt;form&gt;元素上。但其实有一个例外：NgForm不会应用到带formGroup属性的&lt;form&gt;节点上。</p><p class="content">你也许不明白原因，这是因为NgForm的selector是：</p><p class="daima">form：not（[ngNoForm]）：not（[formGroup]）,ngForm,[ngForm]</p><p class="content">这意味着你还<b>可以</b>使用ngNoForm属性产生一个不带NgForm的&lt;form&gt;表单。</p><p class="content">我们还需要把onSubmit中的f替换为myForm，因为现在的myForm变量中保存着表单的配置和值。</p><p class="content">想让程序运行起来，还要做最后一件事：将我们的FormControl绑定到input标签上。记住，<b>ngControl会创建一个新的FormControl对象</b>，并附加到父FormGroup中。但在这个例子中，我们已经用FormBuilder创建了自己的FormControl。</p><p class="content">要将<b>现有的</b>FormControl绑定到input上，可以用formControl。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_sku_with_builder.ts</b></p><p class="daima">　　　　　&lt;label for="skuInput"&gt;SKU&lt;/label&gt;</p><p class="daima">　　　　　&lt;input type="text"</p><p class="daima">　　　　　　　　 id="skuInput"</p><p class="daima">　　　　　　　　 placeholder="SKU"</p><p class="daima">　　　　　　　　 [formControl]="myForm.controls['sku']"&gt;</p><p class="content">在这里，我们将input标签上的formControl指令指向了myForm.controls上现有的FormControl控件sku。</p><p class="listTitle1 biaoti8">5.5.3 试试看</p><p class="content">将上面的所有代码整合在一起。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_sku_with_builder.ts</b></p><p class="daima">import { Component } from '@angular/core';</p><p class="daima">import {</p><p class="daima">　FormBuilder,</p><p class="daima">　FormGroup</p><p class="daima">} from '@angular/forms';</p><p class="daima">@Component（{</p><p class="daima">　selector：'demo-form-sku-builder',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui raised segment"&gt;</p><p class="daima">　　&lt;h2 class="ui header"&gt;Demo Form：Sku with Builder&lt;/h2&gt;</p><p class="daima">　　&lt;form [formGroup]="myForm"</p><p class="daima">　　　　　（ngSubmit）="onSubmit（myForm.value）"</p><p class="daima">　　　　　class="ui form"&gt;</p><p class="daima">　　　&lt;div class="field"&gt;</p><p class="daima">　　　　&lt;label for="skuInput"&gt;SKU&lt;/label&gt;</p><p class="daima">　　　　&lt;input type="text"</p><p class="daima">　　　　　　　 id="skuInput"</p><p class="daima">　　　　　　　 placeholder="SKU"</p><p class="daima">　　　　　　　 [formControl]="myForm.controls['sku']"&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　&lt;button type="submit" class="ui button"&gt;Submit&lt;/button&gt;</p><p class="daima">　　&lt;/form&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class DemoFormSkuBuilder {</p><p class="daima">　myForm：FormGroup;</p><p class="daima">　constructor（fb：FormBuilder）{</p><p class="daima">　　this.myForm = fb.group（{</p><p class="daima">　　　'sku'：['ABC123']</p><p class="daima">　　}）;</p><p class="daima">　}</p><p class="daima">　onSubmit（value：string）：void {</p><p class="daima">　　console.log（'you submitted value：', value）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">你需要记住以下两点。</p><p class="content">如果想隐式创建新的FormGroup和FormControl，使用：</p><p class="content">●ngForm</p><p class="content">●ngModel</p><p class="content">如果要绑定一个现有的FormGroup和FormControl，使用：</p><p class="content">●formGroup</p><p class="content">●formControl</p><p class="sectionTitle biaoti3"><a id="sec006"></a>5.6 添加验证</p><p class="content">用户输入的数据格式并不总是正确的。如果有人输入了错误的数据格式，我们希望给他反馈，并阻止他提交表单。因此，我们要用到<b>验证器</b>。</p><p class="content">验证器由Validators模块提供。Validators.required是最简单的验证，表明指定的字段是必填项，否则就认为这个FormControl是无效的。</p><p class="content">想使用验证器，我们得做两件事：</p><p class="content">（1）为FormControl对象指定一个验证器；</p><p class="content">（2）在视图中检查验证器的状态，并据此采取行动。</p><p class="content">要为FormControl对象分配一个验证器，我们可以直接把它作为第二个参数传给FormControl的构造函数。</p><p class="daima">let control = new FormControl（'sku', Validators.required）;</p><p class="content">也可以像这个例子中一样通过如下语法使用FormBuilder。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_with_validations_explicit.ts</b></p><p class="daima">　constructor（fb：FormBuilder）{</p><p class="daima">　　this.myForm = fb.group（{</p><p class="daima">　　　'sku'：['', Validators.required]</p><p class="daima">　　}）;</p><p class="daima">　　this.sku = this.myForm.controls['sku'];</p><p class="daima">　}</p><p class="content">现在要在视图中使用验证了。在视图中访问验证的值有以下两种方法。</p><p class="content">（1）我们可以显式地把sku这个FormControl赋值给类的实例变量。这有点啰嗦，但便于我们在视图中访问这个FormControl。</p><p class="content">（2）我们也可以在myForm中查找sku这个FormControl。这样能简化组件类中的工作，但在视图中会稍微麻烦些。</p><p class="content">为了说明两者之间的差异，我们来看两个例子。</p><p class="listTitle1 biaoti8">5.6.1 显式地把sku设置为实例变量</p><p class="content">图5-3展示了这个带验证功能的表单应该是什么样子的。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t19165/84/2659407812/63396/a5a9ae8d/5b03d541N596f3374.jpg" class="enlarge" alt="" href="./image/a-43.jpg" /></p><p class="descrip"><b>图5-3　带验证器的演示表单</b></p><p class="content">在视图中，处理单个FormControls的最灵活的方式是将每个FormControl都定义在组件类上。把sku定义在类上的代码如下所示。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_with_validations_explicit.ts</b></p><p class="daima">export class DemoFormWithValidationsExplicit {</p><p class="daima">　myForm：FormGroup;</p><p class="daima">　sku：AbstractControl;</p><p class="daima">　constructor（fb：FormBuilder）{</p><p class="daima">　　this.myForm = fb.group（{</p><p class="daima">　　　'sku'：['', Validators.required]</p><p class="daima">　　}）;</p><p class="daima">　　this.sku = this.myForm.controls['sku'];</p><p class="daima">　}</p><p class="daima">　onSubmit（value：string）：void {</p><p class="daima">　　console.log（'you submitted value：', value）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">注意：</p><p class="content">（1）我们在类的顶部设置sku：AbstractControl；</p><p class="content">（2）我们把用FormBuilder创建的myForm赋值给this.sku变量。</p><p class="content">非常好，这意味着我们可以在组件视图中到处引用sku了。不过这样做有一个缺点：我们不得不为<b>表单中的每个字段</b>定义一个实例变量。对大型表单而言，这会显得相当啰嗦。</p><p class="content">现在我们的sku可以得到验证了。我们要以四种不同的方式把它用在视图中：</p><p class="content">（1）检查整个表单的有效性并显示一条错误信息；</p><p class="content">（2）检查单个字段的有效性并显示一条错误信息；</p><p class="content">（3）检查单个字段的有效性，当字段无效时将字段显示为红色；</p><p class="content">（4）检查单个字段在特定规则下的有效性并显示一条错误信息。</p><p class="content">●<b>表单信息</b></p><p class="content">我们可以通过myForm.valid来检查整个表单的有效性。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_with_validations_explicit.ts</b></p><p class="daima">　　　　&lt;div *ngIf="！sku.valid"</p><p class="daima">　　　　　class="ui error message"&gt;SKU is invalid&lt;/div&gt;</p><p class="content">记住，myForm是一个FormGroup；只有当里面所有的FormControl都有效时，这个FormGroup才有效。</p><p class="content">●<b>字段信息</b></p><p class="content">当字段的FormControl无效时，我们也可以为该字段显示一条错误信息。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_with_validations_explicit.ts</b></p><p class="daima">　　　　&lt;div *ngIf="！sku.valid"</p><p class="daima">　　　　　class="ui error message"&gt;SKU is invalid&lt;/div&gt;</p><p class="daima">　　　　&lt;div *ngIf="sku.hasError（'required'）"</p><p class="daima">　　　　　class="ui error message"&gt;SKU is required&lt;/div&gt;</p><p class="content">●<b>字段着色</b></p><p class="content">这里用的是Semantic UI CSS框架的CSS类.error。当给&lt;div class= "field"&gt;节点加上CSS类error时，这个输入框就会带有红色的边框。</p><p class="content">我们可以使用这种“属性语法”来有条件地设置这个CSS类。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_with_validations_explicit.ts</b></p><p class="daima">　　&lt;div class="field"</p><p class="daima">　　　　[class.error]="！sku.valid &amp;&amp; sku.touched"&gt;</p><p class="content">注意，这里我们为.error类设置了两个条件：检查！sku.valid和sku.touched。这是因为我们希望只有当用户修改过表单后（touched）才显示错误状态。</p><p class="content">试着在input标签中输入一些数据，然后删除这个字段的内容。</p><p class="content">●<b>特定验证</b></p><p class="content">可能有很多原因导致一个表单字段无效。对于失败的验证，我们通常希望根据不同的原因显示不同的消息。</p><p class="content">我们可以用hasError方法来检查特定的验证失败。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_with_validations_explicit.ts</b></p><p class="daima">　　　　&lt;div *ngIf="sku.hasError（'required'）"</p><p class="daima">　　　　　class="ui error message"&gt;SKU is required&lt;/div&gt;</p><p class="content">注意，FormControl和FormGroup都定义了hasError方法。这意味着我们可以给它传入第二个参数path来在FormGroup中查询特定的字段。比如可以这样写：</p><p class="daima">　　　　&lt;div *ngIf="myForm.hasError（'required', 'sku'）"</p><p class="daima">　　　　　class="error"&gt;SKU is required&lt;/div&gt;</p><p class="content">●<b>整合</b></p><p class="content">下面是我们把FormControl用作实例变量来实现验证功能的完整代码。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_with_validations_explicit.ts</b></p><p class="daima">/* tslint：disable：no-string-literal */</p><p class="daima">import { Component } from '@angular/core';</p><p class="daima">import {</p><p class="daima">　FormBuilder,</p><p class="daima">　FormGroup,</p><p class="daima">　Validators,</p><p class="daima">　AbstractControl</p><p class="daima">} from '@angular/forms';</p><p class="daima">@Component（{</p><p class="daima">　selector：'demo-form-with-validations-explicit',</p><p class="daima">　template：`</p><p class="daima">　&lt;div class="ui raised segment"&gt;</p><p class="daima">　　&lt;h2 class="ui header"&gt;Demo Form：with validations（explicit）&lt;/h2&gt;</p><p class="daima">　　&lt;form [formGroup]="myForm"</p><p class="daima">　　　　　（ngSubmit）="onSubmit（myForm.value）"</p><p class="daima">　　　　　class="ui form"&gt;</p><p class="daima">　　　&lt;div class="field"</p><p class="daima">　　　　　[class.error]="！sku.valid &amp;&amp; sku.touched"&gt;</p><p class="daima">　　　　&lt;label for="skuInput"&gt;SKU&lt;/label&gt;</p><p class="daima">　　　　&lt;input type="text"</p><p class="daima">　　　　　　　 id="skuInput"</p><p class="daima">　　　　　　　 placeholder="SKU"</p><p class="daima">　　　　　　　 [formControl]="sku"&gt;</p><p class="daima">　　　　　&lt;div *ngIf="！sku.valid"</p><p class="daima">　　　　　　class="ui error message"&gt;SKU is invalid&lt;/div&gt;</p><p class="daima">　　　　　&lt;div *ngIf="sku.hasError（'required'）"</p><p class="daima">　　　　　　class="ui error message"&gt;SKU is required&lt;/div&gt;</p><p class="daima">　　　&lt;/div&gt;</p><p class="daima">　　　&lt;div *ngIf="！myForm.valid"</p><p class="daima">　　　　class="ui error message"&gt;Form is invalid&lt;/div&gt;</p><p class="daima">　　　　&lt;button type="submit" class="ui button"&gt;Submit&lt;/button&gt;</p><p class="daima">　　&lt;/form&gt;</p><p class="daima">　&lt;/div&gt;</p><p class="daima">　`</p><p class="daima">}）</p><p class="daima">export class DemoFormWithValidationsExplicit {</p><p class="daima">　myForm：FormGroup;</p><p class="daima">　sku：AbstractControl;</p><p class="daima">　constructor（fb：FormBuilder）{</p><p class="daima">　　this.myForm = fb.group（{</p><p class="daima">　　　'sku'：['', Validators.required]</p><p class="daima">　　}）;</p><p class="daima">　　this.sku = this.myForm.controls['sku'];</p><p class="daima">　}</p><p class="daima">　onSubmit（value：string）：void {</p><p class="daima">　　console.log（'you submitted value：', value）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">●<b>移除sku实例变量</b></p><p class="content">在上面的例子中，我们将sku：AbstractControl设置为一个实例变量。通常，我们不希望为每一个AbstractControl控件都创建一个实例变量。在没有实例变量的情况下，我们该如何在视图中引用FormControl呢？</p><p class="content">我们可以改用myForm.controls属性。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_with_validations_shorthand.ts</b></p><p class="daima">　　　 &lt;input type="text"</p><p class="daima">　　　　　　　id="skuInput"</p><p class="daima">　　　　　　　placeholder="SKU"</p><p class="daima">　　　　　　　[formControl]="myForm.controls['sku']"&gt;</p><p class="daima">　　　 &lt;div *ngIf="！myForm.controls['sku'].valid"</p><p class="daima">　　　　 class="ui error message"&gt;SKU is invalid&lt;/div&gt;</p><p class="daima">　　　 &lt;div *ngIf="myForm.controls['sku'].hasError（'required'）"</p><p class="daima">　　　　 class="ui error message"&gt;SKU is required&lt;/div&gt;</p><p class="content">通过这种方式，我们就不用被迫在组件类中显式定义实例变量来访问sku控件了。</p><p class="listTitle1 biaoti8">5.6.2 自定义验证器</p><p class="content">我们经常要写一些自定义验证器，下面来看看如何实现。</p><p class="content">要明白如何实现自己的验证器，不妨看看Angular源代码中是如何实现Validators.required的：</p><p class="daima">export class Validators {</p><p class="daima">　static required（c：FormControl）：StringMap&lt;string, boolean&gt; {</p><p class="daima">　　return isBlank（c.value）|| c.value == "" ? {"required"：true}：null;</p><p class="daima">　}</p><p class="content">一个验证器：</p><p class="content">●接收一个FormControl作为输入；</p><p class="content">●当验证失败时，会返回一个StringMap&lt;string, boolean&gt;对象，它的键是“错误代码”，值是true。</p><p class="content">●<b>编写验证器</b></p><p class="content">假设我们的sku有特殊的验证需求，比如sku必须以123作为开始。我们写的验证器是这样的：</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_with_custom_validations.ts</b></p><p class="daima">function skuValidator（control：FormControl）：{ [s：string]：boolean } {</p><p class="daima">　if（！control.value.match（/^123/））{</p><p class="daima">　　return <sub>validSku：true</sub>;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">当输入值（控件的值control.value）不是以123作为开始时，验证器会返回错误代码invalidSku。</p><p class="content">●<b>给FormControl分配验证器</b></p><p class="content">现在要为FormControl添加验证，但是有一个小问题：sku已经有一个验证器了，怎样才能在同一个字段上添加多个验证器呢？</p><p class="content">我们可以用Validators.compose来实现。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_with_custom_validations.ts</b></p><p class="daima">　constructor（fb：FormBuilder）{</p><p class="daima">　　this.myForm = fb.group（{</p><p class="daima">　　　'sku'：['', Validators.compose（[</p><p class="daima">　　　　Validators.required, skuValidator]）]</p><p class="daima">　　}）;</p><p class="content">Validators.compose把两个验证器包装在一起，我们可以将其赋值给FormControl。只有当两个验证都合法时，FormControl才是合法的。</p><p class="content">现在就能在视图中使用这个新的验证器了。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_with_custom_validations.ts</b></p><p class="daima">　　　　&lt;div *ngIf="sku.hasError（'invalidSku'）"</p><p class="daima">　　　　　class="ui error message"&gt;SKU must begin with &lt;span&gt;123&lt;/span&gt;&lt;/div&gt;</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　注意，我们在本节中为每个FormControl都显式添加了实例变量。这意味着，在本节的视图中sku引用的是一个FormControl。</p><p class="content">运行示例代码，你会注意到有一点很奇妙：当你在字段中输入一些内容时，满足了required验证，但违反了invalidSku验证。棒极了，这意味着我们可以对字段进行部分验证并显示相应的信息。</p><p class="sectionTitle biaoti3"><a id="sec007"></a>5.7 监听变化</p><p class="content">到目前为止，我们只在提交表单时才调用onSubmit方法来获取表单的值。但我们也要经常监听控件的变化。</p><p class="content">FormGroup和FormControl都带有EventEmitter（事件发射器），我们可以通过它来观察变化。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t20827/10/215994487/12231/293f6125/5b03d541Ndff69dec.jpg" class="inline1" alt="" href="./image/a-3.jpg" />　EventEmitter 是一个<b>可观察</b>对象，符合“变化监听”规范。如果你对可观察对象的规范感兴趣，可以参见https：//github.com/jhusain/observable-spec。</p><p class="content">想监听控件的变化，我们要：</p><p class="content">（1）通过调用control.valueChanges访问到这个EventEmitter；</p><p class="content">（2）然后使用.subscribe方法添加一个<b>监听器</b>。</p><p class="content">下面是一个例子。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_with_events.ts</b></p><p class="daima">　constructor（fb：FormBuilder）{</p><p class="daima">　　this.myForm = fb.group（{</p><p class="daima">　　　'sku'：['', Validators.required]</p><p class="daima">　　}）;</p><p class="daima">　　this.sku = this.myForm.controls['sku'];</p><p class="daima">　　this.sku.valueChanges.subscribe（</p><p class="daima">　　　（value：string）=&gt; {</p><p class="daima">　　　　console.log（'sku changed to：', value）;</p><p class="daima">　　　}</p><p class="daima">　　）;</p><p class="daima">　　this.myForm.valueChanges.subscribe（</p><p class="daima">　　　（form：any）=&gt; {</p><p class="daima">　　　　console.log（'form changed to：', form）;</p><p class="daima">　　　}</p><p class="daima">　　）;</p><p class="daima">　}</p><p class="content">在这里我们监听了两个事件：sku字段的变化和整个表单的变化。</p><p class="content">我们传递了一个带有next键的对象（也可以传递其他键，但目前还不用关心它们）。next就是我们希望当值发生变化时被调用的函数。</p><p class="content">如果在输入框中输入kj，就会在控制台中看到：</p><p class="daima">sku changed to：　k</p><p class="daima">form changed to：　Object {sku："k"}</p><p class="daima">sku changed to：　kj</p><p class="daima">form changed to：　Object {sku："kj"}</p><p class="content">如你所见，每一次按键都会触发控件的变化，我们的可观察对象也会被触发。监听单个FormControl时，我们会得到一个值（例如kj）；而监听整个表单时，我们会得到一个包含键值对的对象（例如{sku："kj"}）。</p><p class="sectionTitle biaoti3"><a id="sec008"></a>5.8 ngModel</p><p class="content">ngModel是一个特殊的指令，它将模型绑定到表单中。ngModel的特殊之处在于它<b>实现了双向绑定</b>。相对于单向绑定来说，双向绑定更加复杂和难以推断。Angular通常的数据流向是单向的：自顶向下。但对于表单来说，双向绑定有时会更容易。</p><p class="reference"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17728/48/2715397358/11728/16045511/5b03d541N9720f866.jpg" class="inline1" alt="" href="./image/a-4.jpg" />　不要仅仅因为你以前在AngularJS中用过ng-model而急于使用ngModel，因为有很多避免使用双向绑定的理由。当然，ngModel确实用起来更方便，但要记住Angular已经不像AngularJS那样必须依赖双向绑定了。</p><p class="content">下面对表单稍作修改：我们希望能输入产品名称productName。这次要用ngModel来保持组件实例和视图的同步。</p><p class="content">首先，我们的组件定义类如下所示。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_ng_model.ts</b></p><p class="daima">export class DemoFormNgModel {</p><p class="daima">　myForm：FormGroup;</p><p class="daima">　productName：string;</p><p class="daima">　constructor（fb：FormBuilder）{</p><p class="daima">　　this.myForm = fb.group（{</p><p class="daima">　　　'productName'：['', Validators.required]</p><p class="daima">　　}）;</p><p class="daima">　}</p><p class="daima">　onSubmit（value：string）：void {</p><p class="daima">　　console.log（'you submitted value：', value）;</p><p class="daima">　}</p><p class="daima">}</p><p class="content">注意，我们只是简单地将productName：string存成了实例变量。</p><p class="content">紧接着，我们在input标签上使用ngModel。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_ng_model.ts</b></p><p class="daima">　　　&lt;label for="productNameInput"&gt;Product Name&lt;/label&gt;</p><p class="daima">　　　&lt;input type="text"</p><p class="daima">　　　　　　 id="productNameInput"</p><p class="daima">　　　　　　 placeholder="Product Name"</p><p class="daima">　　　　　　 [formControl]="myForm.get（'productName'）"</p><p class="daima">　　　　　　 [（ngModel）]="productName"&gt;</p><p class="content">注意，这里ngModel的语法很有意思：我们在ngModel属性上同时使用了（）和[]。我们既使用了表示输入属性（@Input）的方括号[]，又使用了表示输出属性（@Output）的圆括号（），这就是双向绑定的标志。</p><p class="content">另外还需要注意的是：我们仍然用formControl指定此input应该绑定到表单上的FormControl。这是因为ngModel只负责将input绑定到对象实例上，但FormControl的功能是与此独立的。由于我们还需要对这个值加以验证并把它作为表单的一部分提交上去，仍要保留formControl指令。</p><p class="content">最后，我们把产品名称productName值显示在视图中。</p><p class="reference"><b>code/forms/app/ts/forms/demo_form_ng_model.ts</b></p><p class="daima">　　&lt;div class="ui info message"&gt;</p><p class="daima">　　　The product name is：{{productName}}</p><p class="daima">　　&lt;/div&gt;</p><p class="content">运行效果图如图5-4所示。</p><p class="center"><img src="https://img30.360buyimg.com/ebookadmin/jfs/t17155/123/2688030817/65586/ffe7ac4c/5b03d541N9622ccbc.jpg" class="enlarge" alt="" href="./image/a-44.jpg" /></p><p class="descrip"><b>图5-4　带ngModel的演示表单</b></p><p class="content">很简单吧！</p><p class="sectionTitle biaoti3"><a id="sec009"></a>5.9 总结</p><p class="content">表单有很多零碎的知识，但Angular让它变得非常简明。只要我们掌握了如何使用FormGroup、FormControl和Validation，它就变得非常容易了！</p><ol class="mz-footnote"><li id="footnote1">https：//github.com/angular/angular/blob/master/modules/angular2/src/common/forms/model.ts</li><li id="footnote2">http：//semantic-ui.com/</li><li id="footnote3">http：//www.w3.org/TR/WCAG20-TECHS/H44.html</li></ol></body></html>